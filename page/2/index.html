<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">
  <link rel="manifest" href="/images/manifest.json">
  <meta name="msapplication-config" content="/images/browserconfig.xml">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">
<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"qianqians.github.io","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"remove","padding":18,"offset":12,"onmobile":true},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":true,"scrollpercent":true},"bookmark":{"enable":true,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="qianqians&#39;blog">
<meta property="og:url" content="https://qianqians.github.io/page/2/index.html">
<meta property="og:site_name" content="qianqians&#39;blog">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="qianqians">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://qianqians.github.io/page/2/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>qianqians'blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">qianqians'blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档<span class="badge">30</span></a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>分类<span class="badge">6</span></a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-fw fa-user"></i>关于</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <a role="button" class="book-mark-link book-mark-link-fixed"></a>

  <a href="https://github.com/qianqians" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://qianqians.github.io/2021/09/02/Wgpu%20Instancing/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="qianqians">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="qianqians'blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/09/02/Wgpu%20Instancing/" class="post-title-link" itemprop="url">Wgpu Instancing</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2021-09-02 14:49:22 / 修改时间：15:33:51" itemprop="dateCreated datePublished" datetime="2021-09-02T14:49:22+08:00">2021-09-02</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Wgpu/" itemprop="url" rel="index"><span itemprop="name">Wgpu</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>Our scene right now is very simple: we have one object centered at (0,0,0). What if we wanted more objects? This is were instancing comes in.</p>
<p>我们现在的场景非常简单：我们有一个以（0,0,0）为中心的对象。如果我们想要更多的东西呢？这是实例的目标。</p>
<p>Instancing allows us to draw the same object multiple times with different properties (position, orientation, size, color, etc.). There are multiple ways of doing instancing. One way would be to modify the uniform buffer to include these properties and then update it before we draw each instance of our object.</p>
<p>实例化允许我们使用不同的属性（位置、方向、大小、颜色等）多次绘制同一对象。有多种方法可以进行实例化。一种方法是修改uniform缓冲区以包含这些属性，然后在绘制对象的每个实例之前更新它。</p>
<p>We don’t want to use this method for performance reasons. Updating the uniform buffer for each instance would require multiple buffer copies each frame. On top of that, our method to update the uniform buffer currently requires use to create a new buffer to store the updated data. That’s a lot of time wasted between draw calls.</p>
<p>出于性能原因，我们不希望使用此方法。更新每个实例的uniform缓冲区将需要每个帧有多个缓冲区副本。除此之外，我们更新uniform缓冲区的方法目前需要创建一个新的缓冲区来存储更新后的数据。在两次draw calls之间浪费了很多时间。</p>
<p>If we look at the parameters for the draw_indexed function in the wgpu docs, we can see a solution to our problem.</p>
<p>如果我们查看wgpu文档中draw_indexed函数的参数，我们可以看到问题的解决方案。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">draw_indexed</span></span>(</span><br><span class="line">    &amp;<span class="keyword">mut</span> <span class="keyword">self</span>,</span><br><span class="line">    indices: Range&lt;<span class="built_in">u32</span>&gt;,</span><br><span class="line">    base_vertex: <span class="built_in">i32</span>,</span><br><span class="line">    instances: Range&lt;<span class="built_in">u32</span>&gt; <span class="comment">// &lt;-- This right here</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>The instances parameter takes a Range<u32>. This parameter tells the GPU how many copies, or instances, of our model we want to draw. Currently we are specifying 0..1, which instructs the GPU to draw our model once, and then stop. If we used 0..5, our code would draw 5 instances.</p>
<p>instances的参数为Range<u32>。此参数告诉GPU我们要绘制模型的多少副本或实例。目前我们正在指定0..1，它指示GPU绘制一次我们的模型，然后停止。如果我们使用0..5，我们的代码将绘制5个实例。</p>
<p>The fact that instances is a Range<u32> may seem weird as using 1..2 for instances would still draw 1 instance of our object. Seems like it would be simpler to just use a u32 right? The reason it’s a range is because sometimes we don’t want to draw all of our objects. Sometimes we want to draw a selection of them, because others are not in frame, or we are debugging and want to look at a particular set of instances.</p>
<p>instances是一个Range<u32>的事实可能看起来很奇怪，因为使用1..2 for instances仍然会绘制对象的一个实例。看起来使用u32会更简单，对吗？它是一个Range的原因是因为有时我们不想绘制所有的对象。有时，我们希望选择它们，因为其他的不在视野中，或者我们正在调试并希望查看一组特定的实例。</p>
<p>Ok, now we know how to draw multiple instances of an object, how do we tell wgpu what particular instance to draw? We are going to use something known as an instance buffer.</p>
<p>好的，现在我们知道了如何绘制一个对象的多个实例，我们如何告诉wgpu要绘制的特定实例？我们将使用实例缓冲区。</p>
<h1 id="The-Instance-Buffer"><a href="#The-Instance-Buffer" class="headerlink" title="The Instance Buffer"></a>The Instance Buffer</h1><p>We’ll create an instance buffer in a similar way to how we create a uniform buffer. First we’ll create a struct called Instance.</p>
<p>我们将以类似于创建uniform缓冲区的方式创建instance缓冲区。首先，我们将创建一个名为Instance的结构。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main.rs</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// NEW!</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Instance</span></span> &#123;</span><br><span class="line">    position: cgmath::Vector3&lt;<span class="built_in">f32</span>&gt;,</span><br><span class="line">    rotation: cgmath::Quaternion&lt;<span class="built_in">f32</span>&gt;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<div class="note">

<p>A Quaternion is a mathematical structure often used to represent rotation. The math behind them is beyond me (it involves imaginary numbers and 4D space) so I won’t be covering them here. If you really want to dive into them <a target="_blank" rel="noopener" href="https://mathworld.wolfram.com/Quaternion.html">here’s a Wolfram Alpha article</a>.</p>
<p>四元数是一种常用于表示旋转的数学结构。它们背后的数学是我无法理解的(它涉及虚数和4D空间)，所以我不会在这里讨论它们。如果你真的想深入了解它们，<a target="_blank" rel="noopener" href="https://mathworld.wolfram.com/Quaternion.html">这里有一篇Wolfram Alpha文章</a>。</p>
</div>

<p>Using these values directly in the shader would be a pain as quaternions don’t have a WGSL analog. I don’t feel like writing the math in the shader, so we’ll convert the Instance data into a matrix and store it into a struct called InstanceRaw.</p>
<p>直接在着色器中使用这些值会很痛苦，因为WGSL没有四元数模拟。我不想在着色器中编写数学，所以我们将实例数据转换为矩阵，并将其存储到名为InstanceRaw的结构中。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// NEW!</span></span><br><span class="line"><span class="meta">#[repr(C)]</span></span><br><span class="line"><span class="meta">#[derive(Copy, Clone, bytemuck::Pod, bytemuck::Zeroable)]</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">InstanceRaw</span></span> &#123;</span><br><span class="line">    model: [[<span class="built_in">f32</span>; <span class="number">4</span>]; <span class="number">4</span>],</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>This is the data that will go into the wgpu::Buffer. We keep these separate so that we can update the Instance as much as we want without needing to mess with matrices. We only need to update the raw data before we draw.</p>
<p>这是将进入wgpu::Buffer的数据。我们将它们分开，这样我们就可以随心所欲地更新实例，而无需弄乱矩阵。我们只需要在绘制之前更新原始数据。</p>
<p>Let’s create a method on Instance to convert to InstanceRaw.</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// NEW!</span></span><br><span class="line"><span class="keyword">impl</span> Instance &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">to_raw</span></span>(&amp;<span class="keyword">self</span>) -&gt; InstanceRaw &#123;</span><br><span class="line">        InstanceRaw &#123;</span><br><span class="line">            model: (cgmath::Matrix4::from_translation(<span class="keyword">self</span>.position) * cgmath::Matrix4::from(<span class="keyword">self</span>.rotation)).into(),</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Now we need to add 2 fields to State: instances, and instance_buffer.</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">State</span></span> &#123;</span><br><span class="line">    instances: <span class="built_in">Vec</span>&lt;Instance&gt;,</span><br><span class="line">    instance_buffer: wgpu::Buffer,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>We’ll create the instances in new(). We’ll use some constants to simplify things. We’ll display our instances in 10 rows of 10, and they’ll be spaced evenly apart.</p>
<p>我们将在new()中创建实例。我们将使用一些常量来简化事情。我们将以10行10列的形式显示我们的实例，并且它们将均匀地间隔开。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> NUM_INSTANCES_PER_ROW: <span class="built_in">u32</span> = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> NUM_INSTANCES: <span class="built_in">u32</span> = NUM_INSTANCES_PER_ROW * NUM_INSTANCES_PER_ROW;</span><br><span class="line"><span class="keyword">const</span> INSTANCE_DISPLACEMENT: cgmath::Vector3&lt;<span class="built_in">f32</span>&gt; = cgmath::Vector3::new(NUM_INSTANCES_PER_ROW <span class="keyword">as</span> <span class="built_in">f32</span> * <span class="number">0.5</span>, <span class="number">0.0</span>, NUM_INSTANCES_PER_ROW <span class="keyword">as</span> <span class="built_in">f32</span> * <span class="number">0.5</span>);</span><br></pre></td></tr></table></figure>

<p>Now we can create the actual instances.</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span> State &#123;</span><br><span class="line">    <span class="keyword">async</span> <span class="function"><span class="keyword">fn</span> <span class="title">new</span></span>(window: &amp;Window) -&gt; <span class="keyword">Self</span> &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="keyword">let</span> instances = (<span class="number">0</span>..NUM_INSTANCES_PER_ROW).flat_map(|z| &#123;</span><br><span class="line">            (<span class="number">0</span>..NUM_INSTANCES_PER_ROW).map(<span class="keyword">move</span> |x| &#123;</span><br><span class="line">                <span class="keyword">let</span> position = cgmath::Vector3 &#123; x: x <span class="keyword">as</span> <span class="built_in">f32</span>, y: <span class="number">0.0</span>, z: z <span class="keyword">as</span> <span class="built_in">f32</span> &#125; - INSTANCE_DISPLACEMENT;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">let</span> rotation = <span class="keyword">if</span> position.is_zero() &#123;</span><br><span class="line">                    <span class="comment">// this is needed so an object at (0, 0, 0) won&#x27;t get scaled to zero</span></span><br><span class="line">                    <span class="comment">// as Quaternions can effect scale if they&#x27;re not created correctly</span></span><br><span class="line">                    cgmath::Quaternion::from_axis_angle(cgmath::Vector3::unit_z(), cgmath::Deg(<span class="number">0.0</span>))</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    cgmath::Quaternion::from_axis_angle(position.normalize(), cgmath::Deg(<span class="number">45.0</span>))</span><br><span class="line">                &#125;;</span><br><span class="line"></span><br><span class="line">                Instance &#123;</span><br><span class="line">                    position, rotation,</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;).collect::&lt;<span class="built_in">Vec</span>&lt;_&gt;&gt;();</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Now that we have our data, we can create the actual instance_buffer.</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> instance_data = instances.iter().map(Instance::to_raw).collect::&lt;<span class="built_in">Vec</span>&lt;_&gt;&gt;();</span><br><span class="line"><span class="keyword">let</span> instance_buffer = device.create_buffer_init(</span><br><span class="line">    &amp;wgpu::util::BufferInitDescriptor &#123;</span><br><span class="line">        label: <span class="literal">Some</span>(<span class="string">&quot;Instance Buffer&quot;</span>),</span><br><span class="line">        contents: bytemuck::cast_slice(&amp;instance_data),</span><br><span class="line">        usage: wgpu::BufferUsage::VERTEX,</span><br><span class="line">    &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>We’re going to need to create a new VertexBufferLayout for InstanceRaw.</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span> InstanceRaw &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">desc</span></span>&lt;<span class="symbol">&#x27;a</span>&gt;() -&gt; wgpu::VertexBufferLayout&lt;<span class="symbol">&#x27;a</span>&gt; &#123;</span><br><span class="line">        <span class="keyword">use</span> std::mem;</span><br><span class="line">        wgpu::VertexBufferLayout &#123;</span><br><span class="line">            array_stride: mem::size_of::&lt;InstanceRaw&gt;() <span class="keyword">as</span> wgpu::BufferAddress,</span><br><span class="line">            <span class="comment">// We need to switch from using a step mode of Vertex to Instance</span></span><br><span class="line">            <span class="comment">// This means that our shaders will only change to use the next</span></span><br><span class="line">            <span class="comment">// instance when the shader starts processing a new instance</span></span><br><span class="line">            step_mode: wgpu::InputStepMode::Instance,</span><br><span class="line">            attributes: &amp;[</span><br><span class="line">                wgpu::VertexAttribute &#123;</span><br><span class="line">                    offset: <span class="number">0</span>,</span><br><span class="line">                    <span class="comment">// While our vertex shader only uses locations 0, and 1 now, in later tutorials we&#x27;ll</span></span><br><span class="line">                    <span class="comment">// be using 2, 3, and 4, for Vertex. We&#x27;ll start at slot 5 not conflict with them later</span></span><br><span class="line">                    shader_location: <span class="number">5</span>,</span><br><span class="line">                    format: wgpu::VertexFormat::Float32x4,</span><br><span class="line">                &#125;,</span><br><span class="line">                <span class="comment">// A mat4 takes up 4 vertex slots as it is technically 4 vec4s. We need to define a slot</span></span><br><span class="line">                <span class="comment">// for each vec4. We&#x27;ll have to reassemble the mat4 in</span></span><br><span class="line">                <span class="comment">// the shader.</span></span><br><span class="line">                wgpu::VertexAttribute &#123;</span><br><span class="line">                    offset: mem::size_of::&lt;[<span class="built_in">f32</span>; <span class="number">4</span>]&gt;() <span class="keyword">as</span> wgpu::BufferAddress,</span><br><span class="line">                    shader_location: <span class="number">6</span>,</span><br><span class="line">                    format: wgpu::VertexFormat::Float32x4,</span><br><span class="line">                &#125;,</span><br><span class="line">                wgpu::VertexAttribute &#123;</span><br><span class="line">                    offset: mem::size_of::&lt;[<span class="built_in">f32</span>; <span class="number">8</span>]&gt;() <span class="keyword">as</span> wgpu::BufferAddress,</span><br><span class="line">                    shader_location: <span class="number">7</span>,</span><br><span class="line">                    format: wgpu::VertexFormat::Float32x4,</span><br><span class="line">                &#125;,</span><br><span class="line">                wgpu::VertexAttribute &#123;</span><br><span class="line">                    offset: mem::size_of::&lt;[<span class="built_in">f32</span>; <span class="number">12</span>]&gt;() <span class="keyword">as</span> wgpu::BufferAddress,</span><br><span class="line">                    shader_location: <span class="number">8</span>,</span><br><span class="line">                    format: wgpu::VertexFormat::Float32x4,</span><br><span class="line">                &#125;,</span><br><span class="line">            ],</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>We need to add this descriptor to the render pipeline so that we can use it when we render.</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> render_pipeline = device.create_render_pipeline(&amp;wgpu::RenderPipelineDescriptor &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    vertex: wgpu::VertexState &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="comment">// UPDATED!</span></span><br><span class="line">        buffers: &amp;[Vertex::desc(), InstanceRaw::desc()],</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>Don’t forget to return our new variables!</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Self</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">// NEW!</span></span><br><span class="line">    instances,</span><br><span class="line">    instance_buffer,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>The last change we need to make is in the render() method. We need to bind our instance_buffer and we need to change the range we’re using in draw_indexed() to include the number of instances.</p>
<p>我们需要做的最后一个更改是render()方法。我们需要绑定实例缓冲区，并且需要更改在draw_indexed()中使用的范围，以包括实例数。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">render_pass.set_pipeline(&amp;<span class="keyword">self</span>.render_pipeline);</span><br><span class="line">render_pass.set_bind_group(<span class="number">0</span>, &amp;<span class="keyword">self</span>.diffuse_bind_group, &amp;[]);</span><br><span class="line">render_pass.set_bind_group(<span class="number">1</span>, &amp;<span class="keyword">self</span>.camera_bind_group, &amp;[]);</span><br><span class="line">render_pass.set_vertex_buffer(<span class="number">0</span>, <span class="keyword">self</span>.vertex_buffer.slice(..));</span><br><span class="line"><span class="comment">// NEW!</span></span><br><span class="line">render_pass.set_vertex_buffer(<span class="number">1</span>, <span class="keyword">self</span>.instance_buffer.slice(..));</span><br><span class="line">render_pass.set_index_buffer(<span class="keyword">self</span>.index_buffer.slice(..), wgpu::IndexFormat::Uint16);</span><br><span class="line"></span><br><span class="line"><span class="comment">// UPDATED!</span></span><br><span class="line">render_pass.draw_indexed(<span class="number">0</span>..<span class="keyword">self</span>.num_indices, <span class="number">0</span>, <span class="number">0</span>..<span class="keyword">self</span>.instances.len() <span class="keyword">as</span> _);</span><br></pre></td></tr></table></figure>

<div class="note">

<p>Make sure if you add new instances to the Vec, that you recreate the instance_buffer and as well as camera_bind_group, otherwise your new instances won’t show up correctly.</p>
<p>如果向Vec添加新实例，请确保重新创建instance_buffer和camera_bind_group，否则新实例将无法正确显示。</p>
</div>

<p>We need to reference the parts of our new matrix in shader.wgsl so that we can use it for our instances. Add the following to the top of shader.wgsl.</p>
<p>我们需要在shader.wgsl中引用新矩阵的部分，以便将其用于实例。将以下内容添加到shader.wgsl的顶部。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">InstanceInput</span></span> &#123;</span><br><span class="line">    [[location(<span class="number">5</span>)]] model_matrix_0: vec4&lt;<span class="built_in">f32</span>&gt;;</span><br><span class="line">    [[location(<span class="number">6</span>)]] model_matrix_1: vec4&lt;<span class="built_in">f32</span>&gt;;</span><br><span class="line">    [[location(<span class="number">7</span>)]] model_matrix_2: vec4&lt;<span class="built_in">f32</span>&gt;;</span><br><span class="line">    [[location(<span class="number">8</span>)]] model_matrix_3: vec4&lt;<span class="built_in">f32</span>&gt;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>We need to reassemble the matrix before we can use it.</p>
<p>我们需要重新组装矩阵才能使用它。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[[stage(vertex)]]</span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>(</span><br><span class="line">    model: VertexInput,</span><br><span class="line">    instance: InstanceInput,</span><br><span class="line">) -&gt; VertexOutput &#123;</span><br><span class="line">    <span class="keyword">let</span> model_matrix = mat4x4&lt;<span class="built_in">f32</span>&gt;(</span><br><span class="line">        instance.model_matrix_0,</span><br><span class="line">        instance.model_matrix_1,</span><br><span class="line">        instance.model_matrix_2,</span><br><span class="line">        instance.model_matrix_3,</span><br><span class="line">    );</span><br><span class="line">    <span class="comment">// Continued...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>We’ll apply the model_matrix before we apply camera_uniform.view_proj. We do this because the camera_uniform.view_proj changes the coordinate system from world space to camera space. Our model_matrix is a world space transformation, so we don’t want to be in camera space when using it.</p>
<p>在应用camera_uniform.view_proj项目之前，我们将应用model_matrix。我们这样做是因为camera_uniform.view_proj将坐标系从世界空间更改为camera空间。我们的model_matrix是一个世界空间变换，所以我们不希望在使用它时处于摄影机空间。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[[stage(vertex)]]</span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>(</span><br><span class="line">    model: VertexInput,</span><br><span class="line">    instance: InstanceInput,</span><br><span class="line">) -&gt; VertexOutput &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    var out: VertexOutput;</span><br><span class="line">    out.tex_coords = model.tex_coords;</span><br><span class="line">    out.clip_position = camera.view_proj * model_matrix * vec4&lt;<span class="built_in">f32</span>&gt;(model.position, <span class="number">1.0</span>);</span><br><span class="line">    <span class="keyword">return</span> out;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>With all that done, we should have a forest of trees!</p>
<p><img src="https://sotrh.github.io/learn-wgpu/assets/img/forest.5c5cf3ad.png" alt="trees"></p>
<h1 id="Challenge"><a href="#Challenge" class="headerlink" title="Challenge"></a>Challenge</h1><p>Modify the position and/or rotation of the instances every frame.</p>
<p><a target="_blank" rel="noopener" href="https://github.com/sotrh/learn-wgpu/tree/master/code/beginner/tutorial7-instancing/">Check out the code!</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://qianqians.github.io/2021/09/01/Wgpu%20Uniform%20buffers%20and%20a%203d%20camera/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="qianqians">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="qianqians'blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/09/01/Wgpu%20Uniform%20buffers%20and%20a%203d%20camera/" class="post-title-link" itemprop="url">Wgpu Uniform buffers and a 3d camera</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2021-09-01 15:16:02 / 修改时间：16:39:13" itemprop="dateCreated datePublished" datetime="2021-09-01T15:16:02+08:00">2021-09-01</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Wgpu/" itemprop="url" rel="index"><span itemprop="name">Wgpu</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>While all of our previous work has seemed to be in 2d, we’ve actually been working in 3d the entire time! That’s part of the reason why our Vertex structure has position be an array of 3 floats instead of just 2. We can’t really see the 3d-ness of our scene, because we’re viewing things head on. We’re going to change our point of view by creating a Camera.</p>
<p>虽然我们之前的所有工作似乎都是二维的，但实际上我们一直都在三维中工作！这就是为什么我们的顶点结构的位置是一个由3个浮点数组成的数组而不是2个浮点数的部分原因。我们无法真正看到场景的3d效果，因为我们是正面观看的。我们将通过创建一个摄影机来改变我们的视角。</p>
<h1 id="A-perspective-camera"><a href="#A-perspective-camera" class="headerlink" title="A perspective camera"></a>A perspective camera</h1><p>This tutorial is more about learning to use wgpu and less about linear algebra, so I’m going to gloss over a lot of the math involved. There’s plenty of reading material online if you’re interested in what’s going on under the hood. The first thing to know is that we need cgmath = “0.18” in our Cargo.toml.</p>
<p>本教程更多的是关于学习使用wgpu，而不是关于线性代数，所以我将对涉及的许多数学进行简单讲解。如果你对幕后发生的事情感兴趣，网上有很多阅读材料。首先要知道的是，我们需要在Cargo.toml中使用cgmath=”0.18”。</p>
<p>Now that we have a math library, let’s put it to use! Create a Camera struct above the State struct.</p>
<p>现在我们有了一个数学库，让我们使用它吧！在struct State上方创建struct Camera。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Camera</span></span> &#123;</span><br><span class="line">    eye: cgmath::Point3&lt;<span class="built_in">f32</span>&gt;,</span><br><span class="line">    target: cgmath::Point3&lt;<span class="built_in">f32</span>&gt;,</span><br><span class="line">    up: cgmath::Vector3&lt;<span class="built_in">f32</span>&gt;,</span><br><span class="line">    aspect: <span class="built_in">f32</span>,</span><br><span class="line">    fovy: <span class="built_in">f32</span>,</span><br><span class="line">    znear: <span class="built_in">f32</span>,</span><br><span class="line">    zfar: <span class="built_in">f32</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> Camera &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">build_view_projection_matrix</span></span>(&amp;<span class="keyword">self</span>) -&gt; cgmath::Matrix4&lt;<span class="built_in">f32</span>&gt; &#123;</span><br><span class="line">        <span class="comment">// 1.</span></span><br><span class="line">        <span class="keyword">let</span> view = cgmath::Matrix4::look_at_rh(<span class="keyword">self</span>.eye, <span class="keyword">self</span>.target, <span class="keyword">self</span>.up);</span><br><span class="line">        <span class="comment">// 2.</span></span><br><span class="line">        <span class="keyword">let</span> proj = cgmath::perspective(cgmath::Deg(<span class="keyword">self</span>.fovy), <span class="keyword">self</span>.aspect, <span class="keyword">self</span>.znear, <span class="keyword">self</span>.zfar);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3.</span></span><br><span class="line">        <span class="keyword">return</span> OPENGL_TO_WGPU_MATRIX * proj * view;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>The build_view_projection_matrix is where the magic happens.</p>
<p>build_view_projection_matrix就是魔法发生的地方。</p>
<ol>
<li>The view matrix moves the world to be at the position and rotation of the camera. It’s essentialy an inverse of whatever the transform matrix of the camera would be.</li>
<li>The proj matrix wraps the scene to give the effect of depth. Without this, objects up close would be the same size as objects far away.</li>
<li>The coordinate system in Wgpu is based on DirectX, and Metal’s coordinate systems. That means that in normalized device coordinates the x axis and y axis are in the range of -1.0 to +1.0, and the z axis is 0.0 to +1.0. The cgmath crate (as well as most game math crates) are built for OpenGL’s coordinate system. This matrix will scale and translate our scene from OpenGL’s coordinate sytem to WGPU’s. We’ll define it as follows.</li>
</ol>
<div></div>

<ol>
<li>视图矩阵将世界移动到摄影机的位置并旋转。它本质上是摄像机变换矩阵的逆矩阵。</li>
<li>proj矩阵包裹场景以提供深度效果。如果不这样做，近处的对象将与远处的对象大小相同。</li>
<li>Wgpu中的坐标系基于DirectX和Metal的坐标系。这意味着在标准化设备坐标中，x轴和y轴在-1.0到+1.0的范围内，z轴在0.0到+1.0的范围内。cgmath crate(以及大多数游戏数学库)是为OpenGL的坐标系构建的。该矩阵将缩放并将场景从OpenGL坐标系统转换为WGPU坐标系统。我们将对其进行如下定义。</li>
</ol>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[rustfmt::skip]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">const</span> OPENGL_TO_WGPU_MATRIX: cgmath::Matrix4&lt;<span class="built_in">f32</span>&gt; = cgmath::Matrix4::new(</span><br><span class="line">    <span class="number">1.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>,</span><br><span class="line">    <span class="number">0.0</span>, <span class="number">1.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>,</span><br><span class="line">    <span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">0.5</span>, <span class="number">0.0</span>,</span><br><span class="line">    <span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">0.5</span>, <span class="number">1.0</span>,</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<ul>
<li>Note: We don’t explicitly need the OPENGL_TO_WGPU_MATRIX, but models centered on (0, 0, 0) will be halfway inside the clipping area. This is only an issue if you aren’t using a camera matrix.</li>
</ul>
<div></div>

<ul>
<li>注: 我们并不明确需要OPENGL_TO_WGPU_MATRIX，但是以(0,0,0)为中心的模型将位于剪裁区域的一半。这只是一个问题，如果你不使用相机矩阵。</li>
</ul>
<p>Now let’s add a camera field to State.</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">State</span></span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    camera: Camera,</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">fn</span> <span class="title">new</span></span>(window: &amp;Window) -&gt; <span class="keyword">Self</span> &#123;</span><br><span class="line">    <span class="comment">// let diffuse_bind_group ...</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> camera = Camera &#123;</span><br><span class="line">        <span class="comment">// position the camera one unit up and 2 units back</span></span><br><span class="line">        <span class="comment">// +z is out of the screen</span></span><br><span class="line">        eye: (<span class="number">0.0</span>, <span class="number">1.0</span>, <span class="number">2.0</span>).into(),</span><br><span class="line">        <span class="comment">// have it look at the origin</span></span><br><span class="line">        target: (<span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>).into(),</span><br><span class="line">        <span class="comment">// which way is &quot;up&quot;</span></span><br><span class="line">        up: cgmath::Vector3::unit_y(),</span><br><span class="line">        aspect: sc_desc.width <span class="keyword">as</span> <span class="built_in">f32</span> / sc_desc.height <span class="keyword">as</span> <span class="built_in">f32</span>,</span><br><span class="line">        fovy: <span class="number">45.0</span>,</span><br><span class="line">        znear: <span class="number">0.1</span>,</span><br><span class="line">        zfar: <span class="number">100.0</span>,</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">Self</span> &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        camera,</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Now that we have our camera, and it can make us a view projection matrix, we need somewhere to put it. We also need some way of getting it into our shaders.</p>
<p>现在我们有了相机，它可以使我们成为一个视图投影矩阵，我们需要把它放在某个地方。我们还需要某种方法将其放入着色器中。</p>
<h1 id="The-uniform-buffer"><a href="#The-uniform-buffer" class="headerlink" title="The uniform buffer"></a>The uniform buffer</h1><p>Up to this point we’ve used Buffers to store our vertex and index data, and even to load our textures. We are going to use them again to create what’s known as a uniform buffer. A uniform is a blob of data that is available to every invocation of a set of shaders. We’ve technically already used uniforms for our texture and sampler. We’re going to use them again to store our view projection matrix. To start let’s create a struct to hold our uniform.</p>
<p>到目前为止，我们已经使用缓冲区来存储顶点和索引数据，甚至加载纹理。我们将再次使用它们来创建所谓的uniform缓冲区。uniform是一组着色器的每次调用都可用的数据块。从技术上讲，我们已经为我们的纹理和取样器使用了uniforms。我们将再次使用它们来存储视图投影矩阵。首先，让我们创建一个用于保存uniforms的struct。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// We need this for Rust to store our data correctly for the shaders</span></span><br><span class="line"><span class="meta">#[repr(C)]</span></span><br><span class="line"><span class="comment">// This is so we can store this in a buffer</span></span><br><span class="line"><span class="meta">#[derive(Debug, Copy, Clone, bytemuck::Pod, bytemuck::Zeroable)]</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">CameraUniform</span></span> &#123;</span><br><span class="line">    <span class="comment">// We can&#x27;t use cgmath with bytemuck directly so we&#x27;ll have</span></span><br><span class="line">    <span class="comment">// to convert the Matrix4 into a 4x4 f32 array</span></span><br><span class="line">    view_proj: [[<span class="built_in">f32</span>; <span class="number">4</span>]; <span class="number">4</span>],</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> CameraUniform &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">new</span></span>() -&gt; <span class="keyword">Self</span> &#123;</span><br><span class="line">        <span class="keyword">use</span> cgmath::SquareMatrix;</span><br><span class="line">        <span class="keyword">Self</span> &#123;</span><br><span class="line">            view_proj: cgmath::Matrix4::identity().into(),</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">update_view_proj</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, camera: &amp;Camera) &#123;</span><br><span class="line">        <span class="keyword">self</span>.view_proj = camera.build_view_projection_matrix().into();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Now that we have our data structured, let’s make our camera_buffer.</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// in new() after creating `camera`</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut</span> camera_uniform = CameraUniform::new();</span><br><span class="line">camera_uniform.update_view_proj(&amp;camera);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> camera_buffer = device.create_buffer_init(</span><br><span class="line">    &amp;wgpu::util::BufferInitDescriptor &#123;</span><br><span class="line">        label: <span class="literal">Some</span>(<span class="string">&quot;Camera Buffer&quot;</span>),</span><br><span class="line">        contents: bytemuck::cast_slice(&amp;[camera_uniform]),</span><br><span class="line">        usage: wgpu::BufferUsage::UNIFORM | wgpu::BufferUsage::COPY_DST,</span><br><span class="line">    &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<h1 id="Uniform-buffers-and-bind-groups"><a href="#Uniform-buffers-and-bind-groups" class="headerlink" title="Uniform buffers and bind groups"></a>Uniform buffers and bind groups</h1><p>Cool, now that we have a uniform buffer, what do we do with it? The answer is we create a bind group for it. First we have to create the bind group layout.</p>
<p>既然我们有了一个uniform的缓冲区，我们该怎么处理它呢？答案是我们为它创建一个bind group。首先，我们必须创建bind group layout。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> camera_bind_group_layout = device.create_bind_group_layout(&amp;wgpu::BindGroupLayoutDescriptor &#123;</span><br><span class="line">    entries: &amp;[</span><br><span class="line">        wgpu::BindGroupLayoutEntry &#123;</span><br><span class="line">            binding: <span class="number">0</span>,</span><br><span class="line">            visibility: wgpu::ShaderStage::VERTEX,</span><br><span class="line">            ty: wgpu::BindingType::Buffer &#123;</span><br><span class="line">                ty: wgpu::BufferBindingType::Uniform,</span><br><span class="line">                has_dynamic_offset: <span class="literal">false</span>,</span><br><span class="line">                min_binding_size: <span class="literal">None</span>,</span><br><span class="line">            &#125;,</span><br><span class="line">            count: <span class="literal">None</span>,</span><br><span class="line">        &#125;</span><br><span class="line">    ],</span><br><span class="line">    label: <span class="literal">Some</span>(<span class="string">&quot;camera_bind_group_layout&quot;</span>),</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<ol>
<li>We only really need camera information in the vertex shader, as that’s what we’ll use to manipulate our vertices.</li>
<li>The dynamic field indicates whether this buffer will change size or not. This is useful if we want to store an array of things in our uniforms.</li>
</ol>
<div></div>

<ol>
<li>我们只在顶点着色器中需要摄影机信息，因为我们将使用这些信息来操纵顶点。</li>
<li>dynamic字段指示此缓冲区是否将更改大小。如果我们想在制服中存储一系列的东西，这是很有用的。</li>
</ol>
<p>Now we can create the actual bind group.</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> camera_bind_group = device.create_bind_group(&amp;wgpu::BindGroupDescriptor &#123;</span><br><span class="line">    layout: &amp;camera_bind_group_layout,</span><br><span class="line">    entries: &amp;[</span><br><span class="line">        wgpu::BindGroupEntry &#123;</span><br><span class="line">            binding: <span class="number">0</span>,</span><br><span class="line">            resource: camera_buffer.as_entire_binding(),</span><br><span class="line">        &#125;</span><br><span class="line">    ],</span><br><span class="line">    label: <span class="literal">Some</span>(<span class="string">&quot;camera_bind_group&quot;</span>),</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>Like with our texture, we need to register our camera_bind_group_layout with the render pipeline.</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> render_pipeline_layout = device.create_pipeline_layout(</span><br><span class="line">    &amp;wgpu::PipelineLayoutDescriptor &#123;</span><br><span class="line">        label: <span class="literal">Some</span>(<span class="string">&quot;Render Pipeline Layout&quot;</span>),</span><br><span class="line">        bind_group_layouts: &amp;[</span><br><span class="line">            &amp;texture_bind_group_layout,</span><br><span class="line">            &amp;camera_bind_group_layout,</span><br><span class="line">        ],</span><br><span class="line">        push_constant_ranges: &amp;[],</span><br><span class="line">    &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>Now we need to add camera_buffer and camera_bind_group to State</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">State</span></span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    camera: Camera,</span><br><span class="line">    camera_uniform: CameraUniform,</span><br><span class="line">    camera_buffer: wgpu::Buffer,</span><br><span class="line">    camera_bind_group: wgpu::BindGroup,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">fn</span> <span class="title">new</span></span>(window: &amp;Window) -&gt; <span class="keyword">Self</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">Self</span> &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        camera,</span><br><span class="line">        camera_uniform,</span><br><span class="line">        camera_buffer,</span><br><span class="line">        camera_bind_group,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>The final thing we need to do before we get into shaders is use the bind group in render().</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">render_pass.set_pipeline(&amp;<span class="keyword">self</span>.render_pipeline);</span><br><span class="line">render_pass.set_bind_group(<span class="number">0</span>, &amp;<span class="keyword">self</span>.diffuse_bind_group, &amp;[]);</span><br><span class="line"><span class="comment">// NEW!</span></span><br><span class="line">render_pass.set_bind_group(<span class="number">1</span>, &amp;<span class="keyword">self</span>.camera_bind_group, &amp;[]);</span><br><span class="line">render_pass.set_vertex_buffer(<span class="number">0</span>, <span class="keyword">self</span>.vertex_buffer.slice(..));</span><br><span class="line">render_pass.set_index_buffer(<span class="keyword">self</span>.index_buffer.slice(..), wgpu::IndexFormat::Uint16);</span><br><span class="line"></span><br><span class="line">render_pass.draw_indexed(<span class="number">0</span>..<span class="keyword">self</span>.num_indices, <span class="number">0</span>, <span class="number">0</span>..<span class="number">1</span>);</span><br></pre></td></tr></table></figure>

<h1 id="Using-the-uniform-in-the-vertex-shader"><a href="#Using-the-uniform-in-the-vertex-shader" class="headerlink" title="Using the uniform in the vertex shader"></a>Using the uniform in the vertex shader</h1><p>Modify the vertex shader to include the following.</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Vertex shader</span></span><br><span class="line"></span><br><span class="line">[[block]] <span class="comment">// 1.</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">CameraUniform</span></span> &#123;</span><br><span class="line">    view_proj: mat4x4&lt;<span class="built_in">f32</span>&gt;;</span><br><span class="line">&#125;;</span><br><span class="line">[[group(<span class="number">1</span>), binding(<span class="number">0</span>)]] <span class="comment">// 2.</span></span><br><span class="line">var&lt;uniform&gt; camera: Camera;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">VertexInput</span></span> &#123;</span><br><span class="line">    [[location(<span class="number">0</span>)]] position: vec3&lt;<span class="built_in">f32</span>&gt;;</span><br><span class="line">    [[location(<span class="number">1</span>)]] tex_coords: vec2&lt;<span class="built_in">f32</span>&gt;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">VertexOutput</span></span> &#123;</span><br><span class="line">    [[builtin(position)]] clip_position: vec4&lt;<span class="built_in">f32</span>&gt;;</span><br><span class="line">    [[location(<span class="number">0</span>)]] tex_coords: vec2&lt;<span class="built_in">f32</span>&gt;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">[[stage(vertex)]]</span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>(</span><br><span class="line">    model: VertexInput,</span><br><span class="line">) -&gt; VertexOutput &#123;</span><br><span class="line">    var out: VertexOutput;</span><br><span class="line">    out.tex_coords = model.tex_coords;</span><br><span class="line">    out.clip_position = camera.view_proj * vec4&lt;<span class="built_in">f32</span>&gt;(model.position, <span class="number">1.0</span>); <span class="comment">// 3.</span></span><br><span class="line">    <span class="keyword">return</span> out;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>According to the <a target="_blank" rel="noopener" href="https://gpuweb.github.io/gpuweb/wgsl/">WGSL Spec</a>, The block decorator indicates this structure type represents the contents of a buffer resource occupying a single binding slot in the shader’s resource interface. Any structure used as a uniform must be annotated with [[block]]</li>
<li>Because we’ve created a new bind group, we need to specify which one we’re using in the shader. The number is determined by our render_pipeline_layout. The texture_bind_group_layout is listed first, thus it’s group(0), and camera_bind_group is second, so it’s group(1).</li>
<li>Multiplication order is important when it comes to matrices. The vector goes on the right, and the matrices gone on the left in order of importance.</li>
</ol>
<div></div>

<ol>
<li>根据<a target="_blank" rel="noopener" href="https://gpuweb.github.io/gpuweb/wgsl/">WGSL规范</a>，block decorator指示此结构类型表示占用着色器资源接口中单个绑定槽的缓冲区资源的内容。任何用作uniform的结构都必须用[[block]]注释</li>
<li>因为我们已经创建了一个新的bind group，所以需要指定在着色器中使用的bind group。编号由渲染管道布局决定。纹理绑定组布局列在第一位，因此它是group(0)，摄影机绑定组列在第二位，因此它是group(1)。</li>
<li>当涉及到矩阵时，乘法顺序很重要。向量在右边，矩阵按顺序在左边。</li>
</ol>
<h1 id="A-controller-for-our-camera"><a href="#A-controller-for-our-camera" class="headerlink" title="A controller for our camera"></a>A controller for our camera</h1><p>If you run the code right now, you should get something that looks like this.</p>
<p><img src="https://sotrh.github.io/learn-wgpu/assets/img/static-tree.e1f31949.png" alt="static-tree"></p>
<p>The shape’s less stretched now, but it’s still pretty static. You can experiment with moving the camera position around, but most cameras in games move around. Since this tutorial is about using wgpu and not how to process user input, I’m just going to post the CameraController code below.</p>
<p>该形状现在拉伸程度有所降低，但仍然相当静态。你可以尝试移动摄像机的位置，但游戏中的大多数摄像机都会移动。因为本教程是关于使用wgpu而不是如何处理用户输入的，所以我将在下面直接发布CameraController代码。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">CameraController</span></span> &#123;</span><br><span class="line">    speed: <span class="built_in">f32</span>,</span><br><span class="line">    is_up_pressed: <span class="built_in">bool</span>,</span><br><span class="line">    is_down_pressed: <span class="built_in">bool</span>,</span><br><span class="line">    is_forward_pressed: <span class="built_in">bool</span>,</span><br><span class="line">    is_backward_pressed: <span class="built_in">bool</span>,</span><br><span class="line">    is_left_pressed: <span class="built_in">bool</span>,</span><br><span class="line">    is_right_pressed: <span class="built_in">bool</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> CameraController &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">new</span></span>(speed: <span class="built_in">f32</span>) -&gt; <span class="keyword">Self</span> &#123;</span><br><span class="line">        <span class="keyword">Self</span> &#123;</span><br><span class="line">            speed,</span><br><span class="line">            is_up_pressed: <span class="literal">false</span>,</span><br><span class="line">            is_down_pressed: <span class="literal">false</span>,</span><br><span class="line">            is_forward_pressed: <span class="literal">false</span>,</span><br><span class="line">            is_backward_pressed: <span class="literal">false</span>,</span><br><span class="line">            is_left_pressed: <span class="literal">false</span>,</span><br><span class="line">            is_right_pressed: <span class="literal">false</span>,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">process_events</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, event: &amp;WindowEvent) -&gt; <span class="built_in">bool</span> &#123;</span><br><span class="line">        <span class="keyword">match</span> event &#123;</span><br><span class="line">            WindowEvent::KeyboardInput &#123;</span><br><span class="line">                input: KeyboardInput &#123;</span><br><span class="line">                    state,</span><br><span class="line">                    virtual_keycode: <span class="literal">Some</span>(keycode),</span><br><span class="line">                    ..</span><br><span class="line">                &#125;,</span><br><span class="line">                ..</span><br><span class="line">            &#125; =&gt; &#123;</span><br><span class="line">                <span class="keyword">let</span> is_pressed = *state == ElementState::Pressed;</span><br><span class="line">                <span class="keyword">match</span> keycode &#123;</span><br><span class="line">                    VirtualKeyCode::Space =&gt; &#123;</span><br><span class="line">                        <span class="keyword">self</span>.is_up_pressed = is_pressed;</span><br><span class="line">                        <span class="literal">true</span></span><br><span class="line">                    &#125;</span><br><span class="line">                    VirtualKeyCode::LShift =&gt; &#123;</span><br><span class="line">                        <span class="keyword">self</span>.is_down_pressed = is_pressed;</span><br><span class="line">                        <span class="literal">true</span></span><br><span class="line">                    &#125;</span><br><span class="line">                    VirtualKeyCode::W | VirtualKeyCode::Up =&gt; &#123;</span><br><span class="line">                        <span class="keyword">self</span>.is_forward_pressed = is_pressed;</span><br><span class="line">                        <span class="literal">true</span></span><br><span class="line">                    &#125;</span><br><span class="line">                    VirtualKeyCode::A | VirtualKeyCode::Left =&gt; &#123;</span><br><span class="line">                        <span class="keyword">self</span>.is_left_pressed = is_pressed;</span><br><span class="line">                        <span class="literal">true</span></span><br><span class="line">                    &#125;</span><br><span class="line">                    VirtualKeyCode::S | VirtualKeyCode::Down =&gt; &#123;</span><br><span class="line">                        <span class="keyword">self</span>.is_backward_pressed = is_pressed;</span><br><span class="line">                        <span class="literal">true</span></span><br><span class="line">                    &#125;</span><br><span class="line">                    VirtualKeyCode::D | VirtualKeyCode::Right =&gt; &#123;</span><br><span class="line">                        <span class="keyword">self</span>.is_right_pressed = is_pressed;</span><br><span class="line">                        <span class="literal">true</span></span><br><span class="line">                    &#125;</span><br><span class="line">                    _ =&gt; <span class="literal">false</span>,</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            _ =&gt; <span class="literal">false</span>,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">update_camera</span></span>(&amp;<span class="keyword">self</span>, camera: &amp;<span class="keyword">mut</span> Camera) &#123;</span><br><span class="line">        <span class="keyword">use</span> cgmath::InnerSpace;</span><br><span class="line">        <span class="keyword">let</span> forward = camera.target - camera.eye;</span><br><span class="line">        <span class="keyword">let</span> forward_norm = forward.normalize();</span><br><span class="line">        <span class="keyword">let</span> forward_mag = forward.magnitude();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Prevents glitching when camera gets too close to the</span></span><br><span class="line">        <span class="comment">// center of the scene.</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">self</span>.is_forward_pressed &amp;&amp; forward_mag &gt; <span class="keyword">self</span>.speed &#123;</span><br><span class="line">            camera.eye += forward_norm * <span class="keyword">self</span>.speed;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">self</span>.is_backward_pressed &#123;</span><br><span class="line">            camera.eye -= forward_norm * <span class="keyword">self</span>.speed;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> right = forward_norm.cross(camera.up);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Redo radius calc in case the up/ down is pressed.</span></span><br><span class="line">        <span class="keyword">let</span> forward = camera.target - camera.eye;</span><br><span class="line">        <span class="keyword">let</span> forward_mag = forward.magnitude();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">self</span>.is_right_pressed &#123;</span><br><span class="line">            <span class="comment">// Rescale the distance between the target and eye so </span></span><br><span class="line">            <span class="comment">// that it doesn&#x27;t change. The eye therefore still </span></span><br><span class="line">            <span class="comment">// lies on the circle made by the target and eye.</span></span><br><span class="line">            camera.eye = camera.target - (forward + right * <span class="keyword">self</span>.speed).normalize() * forward_mag;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">self</span>.is_left_pressed &#123;</span><br><span class="line">            camera.eye = camera.target - (forward - right * <span class="keyword">self</span>.speed).normalize() * forward_mag;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>This code is not perfect. The camera slowly moves back when you rotate it. It works for our purposes though. Feel free to improve it!</p>
<p>这个代码并不完美。旋转相机时，相机会慢慢向后移动。不过，它对我们的目的是有效的。请随意改进它！</p>
<p>We still need to plug this into our existing code to make it do anything. Add the controller to State and create it in new().</p>
<p>我们仍然需要将其插入到现有代码中，使其能够执行任何操作。将控制器添加到State并在new()中创建它。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">State</span></span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    camera: Camera,</span><br><span class="line">    <span class="comment">// NEW!</span></span><br><span class="line">    camera_controller: CameraController,</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">impl</span> State &#123;</span><br><span class="line">    <span class="keyword">async</span> <span class="function"><span class="keyword">fn</span> <span class="title">new</span></span>(window: &amp;Window) -&gt; <span class="keyword">Self</span> &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="keyword">let</span> camera_controller = CameraController::new(<span class="number">0.2</span>);</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">Self</span> &#123;</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">            camera_controller,</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>We’re finally going to add some code to input() (assuming you haven’t already)!</p>
<p>最后，我们将向input()添加一些代码(假设您还没有这样做)！</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">input</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, event: &amp;WindowEvent) -&gt; <span class="built_in">bool</span> &#123;</span><br><span class="line">    <span class="keyword">self</span>.camera_controller.process_events(event)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Up to this point, the camera controller isn’t actually doing anything. The values in our uniform buffer need to be updated. There are a few main methods to do that.</p>
<p>到目前为止，相机控制器实际上什么都没有做。我们的uniform缓冲区中的值需要更新。有几种主要的方法可以做到这一点。</p>
<ol>
<li>We can create a separate buffer and copy it’s contents to our camera_buffer. The new buffer is known as a staging buffer. This method is usually how it’s done as it allows the contents of the main buffer (in this case camera_buffer) to only be accessible by the gpu. The gpu can do some speed optimizations which it couldn’t if we could access the buffer via the cpu.</li>
<li>We can call on of the mapping method’s map_read_async, and map_write_async on the buffer itself. These allow us to access a buffer’s contents directly, but requires us to deal with the async aspect of these methods this also requires our buffer to use the BufferUsage::MAP_READ and/or BufferUsage::MAP_WRITE. We won’t talk about it here, but you check out Wgpu without a window tutorial if you want to know more.</li>
<li>We can use write_buffer on queue.</li>
</ol>
<div></div>

<ol>
<li>我们可以创建一个单独的缓冲区，并将其内容复制到我们的相机缓冲区。新缓冲区称为暂存缓冲区。这种方法通常是这样做的，因为它只允许gpu访问主缓冲区（在本例中为camera_缓冲区）的内容。gpu可以做一些速度优化，如果我们可以通过cpu访问缓冲区，它就无法做到。</li>
<li>我们可以在缓冲区本身上调用映射方法的map_read_async和map_write_async。这些允许我们直接访问缓冲区的内容，但要求我们处理这些方法的异步问题。这还要求我们的缓冲区使用BufferUsage::MAP_READ读取和BufferUsage::MAP_WRITE。我们这里不讨论它，但是如果您想了解更多，可以在没有窗口教程的情况下查看Wgpu。</li>
<li>我们可以在队列上使用write_buffer。</li>
</ol>
<p>We’re going to use option number 3.</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">update</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) &#123;</span><br><span class="line">    <span class="keyword">self</span>.camera_controller.update_camera(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>.camera);</span><br><span class="line">    <span class="keyword">self</span>.camera_uniform.update_view_proj(&amp;<span class="keyword">self</span>.camera);</span><br><span class="line">    <span class="keyword">self</span>.queue.write_buffer(&amp;<span class="keyword">self</span>.camera_buffer, <span class="number">0</span>, bytemuck::cast_slice(&amp;[<span class="keyword">self</span>.camera_uniform]));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>That’s all we need to do. If you run the code now you should see a pentagon with our tree texture that you can rotate around and zoom into with the wasd/arrow keys.</p>
<p>这就是我们需要做的。如果你现在运行代码，你会看到一个五边形和我们的树纹理，你可以通过wasd/箭头键旋转和放大。</p>
<h1 id="Challenge"><a href="#Challenge" class="headerlink" title="Challenge"></a>Challenge</h1><p>让我们的模型独立于相机旋转。提示：您需要另一个矩阵。</p>
<p><a target="_blank" rel="noopener" href="https://github.com/sotrh/learn-wgpu/tree/master/code/beginner/tutorial6-uniforms/">Check out the code!</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://qianqians.github.io/2021/08/25/Wgpu%20Textures%20and%20bind%20groups/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="qianqians">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="qianqians'blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/08/25/Wgpu%20Textures%20and%20bind%20groups/" class="post-title-link" itemprop="url">Wgpu Textures and bind groups</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-08-25 14:55:56" itemprop="dateCreated datePublished" datetime="2021-08-25T14:55:56+08:00">2021-08-25</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-08-26 15:50:42" itemprop="dateModified" datetime="2021-08-26T15:50:42+08:00">2021-08-26</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Wgpu/" itemprop="url" rel="index"><span itemprop="name">Wgpu</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>Up to this point we have been drawing super simple shapes. While we can make a game with just triangles, trying to draw highly detailed objects would massively limit what devices could even run our game. However, we can get around this problem with textures.</p>
<p>到目前为止，我们一直在画超级简单的形状。虽然我们可以制作一个只有三角形的游戏，但尝试绘制高度详细的对象将极大地限制哪些设备甚至可以运行我们的游戏。然而，我们可以通过纹理来解决这个问题。</p>
<p>Textures are images overlayed on a triangle mesh to make it seem more detailed. There are multiple types of textures such as normal maps, bump maps, specular maps and diffuse maps. We’re going to talk about diffuse maps, or more simply, the color texture.</p>
<p>纹理是叠加在三角形网格上的图像，使其看起来更详细。有多种类型的纹理，例如法线贴图、凹凸贴图、镜面反射贴图和漫反射贴图。我们将讨论漫反射贴图，或者更简单地说，颜色纹理。</p>
<h1 id="Loading-an-image-from-a-file"><a href="#Loading-an-image-from-a-file" class="headerlink" title="Loading an image from a file"></a>Loading an image from a file</h1><p>If we want to map an image to our mesh, we first need an image. Let’s use this happy little tree:</p>
<p>如果要将图像映射到网格，首先需要一个图像。让我们用这棵快乐的小树：</p>
<p><img src="https://sotrh.github.io/learn-wgpu/assets/img/happy-tree.bdff8a19.png" alt="小树"></p>
<p>We’ll use the image crate to load our tree. We already added to our dependencies in the first section, so all we have to do is use it.</p>
<p>我们将使用image crate来装载我们的树。我们已经在第一节中添加了依赖项，所以我们所要做的就是使用它。</p>
<p>In State’s new() method add the following just after creating the swap_chain:</p>
<p>在State的new()方法中，在创建swap_chain之后添加以下内容：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> swap_chain = device.create_swap_chain(&amp;surface, &amp;sc_desc);</span><br><span class="line"><span class="comment">// NEW!</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> diffuse_bytes = include_bytes!(<span class="string">&quot;happy-tree.png&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> diffuse_image = image::load_from_memory(diffuse_bytes).unwrap();</span><br><span class="line"><span class="keyword">let</span> diffuse_rgba = diffuse_image.as_rgba8().unwrap();</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> image::GenericImageView;</span><br><span class="line"><span class="keyword">let</span> dimensions = diffuse_image.dimensions();</span><br></pre></td></tr></table></figure>

<p>Here we grab the bytes from our image file and load them into an image which is then converted into a Vec of rgba bytes. We also save the image’s dimensions for when we create the actual Texture.</p>
<p>在这里，我们从图像文件中获取bytes，并将它们加载到图像中，然后将图像转换为rgba字节的Vec。我们还保存图像的尺寸，以便在创建实际纹理时使用。</p>
<p>Now, let’s create the Texture:</p>
<p>现在，让我们创建纹理：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> texture_size = wgpu::Extent3d &#123;</span><br><span class="line">    width: dimensions.<span class="number">0</span>,</span><br><span class="line">    height: dimensions.<span class="number">1</span>,</span><br><span class="line">    depth_or_array_layers: <span class="number">1</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> diffuse_texture = device.create_texture(</span><br><span class="line">    &amp;wgpu::TextureDescriptor &#123;</span><br><span class="line">        <span class="comment">// All textures are stored as 3D, we represent our 2D texture</span></span><br><span class="line">        <span class="comment">// by setting depth to 1.</span></span><br><span class="line">        size: texture_size,</span><br><span class="line">        mip_level_count: <span class="number">1</span>, <span class="comment">// We&#x27;ll talk about this a little later</span></span><br><span class="line">        sample_count: <span class="number">1</span>,</span><br><span class="line">        dimension: wgpu::TextureDimension::D2,</span><br><span class="line">        <span class="comment">// Most images are stored using sRGB so we need to reflect that here.</span></span><br><span class="line">        format: wgpu::TextureFormat::Rgba8UnormSrgb,</span><br><span class="line">        <span class="comment">// SAMPLED tells wgpu that we want to use this texture in shaders</span></span><br><span class="line">        <span class="comment">// COPY_DST means that we want to copy data to this texture</span></span><br><span class="line">        usage: wgpu::TextureUsage::SAMPLED | wgpu::TextureUsage::COPY_DST,</span><br><span class="line">        label: <span class="literal">Some</span>(<span class="string">&quot;diffuse_texture&quot;</span>),</span><br><span class="line">    &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<h1 id="Getting-data-into-a-Texture"><a href="#Getting-data-into-a-Texture" class="headerlink" title="Getting data into a Texture"></a>Getting data into a Texture</h1><p>The Texture struct has no methods to interact with the data directly. However, we can use a method on the queue we created earlier called write_texture to load the texture in. Let’s take a look at how we do that:</p>
<p>纹理结构没有直接与数据交互的方法。但是，我们可以在前面创建的队列上使用一个名为write_texture的方法来加载纹理。让我们来看看我们是如何做到这一点的：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">queue.write_texture(</span><br><span class="line">    <span class="comment">// Tells wgpu where to copy the pixel data</span></span><br><span class="line">    wgpu::ImageCopyTexture &#123;</span><br><span class="line">        texture: &amp;diffuse_texture,</span><br><span class="line">        mip_level: <span class="number">0</span>,</span><br><span class="line">        origin: wgpu::Origin3d::ZERO,</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// The actual pixel data</span></span><br><span class="line">    diffuse_rgba,</span><br><span class="line">    <span class="comment">// The layout of the texture</span></span><br><span class="line">    wgpu::ImageDataLayout &#123;</span><br><span class="line">        offset: <span class="number">0</span>,</span><br><span class="line">        bytes_per_row: std::num::NonZeroU32::new(<span class="number">4</span> * dimensions.<span class="number">0</span>),</span><br><span class="line">        rows_per_image: std::num::NonZeroU32::new(dimensions.<span class="number">1</span>),</span><br><span class="line">    &#125;,</span><br><span class="line">    texture_size,</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<dic class="note">

<p>The old way of writing data to a texture was to copy the pixel data to a buffer and then copy it to the texture. Using write_texture is a bit more efficient as it uses one less buffer - I’ll leave it here though in case you need it.</p>
<p>将数据写入纹理的旧方法是将像素数据复制到缓冲区，然后将其复制到纹理。使用write_texture更有效，因为它使用的缓冲区少了一个，不过我会把它放在这里，以备您需要。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> buffer = device.create_buffer_init(</span><br><span class="line">    &amp;wgpu::util::BufferInitDescriptor &#123;</span><br><span class="line">        label: <span class="literal">Some</span>(<span class="string">&quot;Temp Buffer&quot;</span>),</span><br><span class="line">        contents: &amp;diffuse_rgba,</span><br><span class="line">        usage: wgpu::BufferUsage::COPY_SRC,</span><br><span class="line">    &#125;</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut</span> encoder = device.create_command_encoder(&amp;wgpu::CommandEncoderDescriptor &#123;</span><br><span class="line">    label: <span class="literal">Some</span>(<span class="string">&quot;texture_buffer_copy_encoder&quot;</span>),</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">encoder.copy_buffer_to_texture(</span><br><span class="line">    wgpu::ImageCopyBuffer &#123;</span><br><span class="line">        buffer: &amp;buffer,</span><br><span class="line">        offset: <span class="number">0</span>,</span><br><span class="line">        bytes_per_row: <span class="number">4</span> * dimensions.<span class="number">0</span>,</span><br><span class="line">        rows_per_image: dimensions.<span class="number">1</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    wgpu::ImageCopyTexture &#123;</span><br><span class="line">        texture: &amp;diffuse_texture,</span><br><span class="line">        mip_level: <span class="number">0</span>,</span><br><span class="line">        array_layer: <span class="number">0</span>,</span><br><span class="line">        origin: wgpu::Origin3d::ZERO,</span><br><span class="line">    &#125;,</span><br><span class="line">    size,</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">queue.submit(std::iter::once(encoder.finish()));</span><br></pre></td></tr></table></figure>

<p>The bytes_per_row field needs some consideration. This value needs to be a multiple of 256. Check out the gif tutorial for more details.</p>
<p>每行字节数字段需要考虑。此值必须是256的倍数。有关详细信息，请查看gif教程。</p>
</div>

<h1 id="TextureViews-and-Samplers"><a href="#TextureViews-and-Samplers" class="headerlink" title="TextureViews and Samplers"></a>TextureViews and Samplers</h1><p>Now that our texture has data in it, we need a way to use it. This is where a TextureView and a Sampler come in. A TextureView offers us a view into our texture. A Sampler controls how the Texture is sampled. Sampling works similar to the eyedropper tool in GIMP/Photoshop. Our program supplies a coordinate on the texture (known as a texture coordinate), and the sampler then returns the corresponding color based on the texture and some internal parameters.</p>
<p>既然我们的纹理中有数据，我们需要一种使用它的方法。这就是TextureView和采样器的作用。纹理视图为我们提供了纹理视图。采样器控制纹理的采样方式。采样的工作原理类似于GIMP/Photoshop中的滴管工具。我们的程序在纹理上提供一个坐标(称为纹理坐标)，然后采样器根据纹理和一些内部参数返回相应的颜色。</p>
<p>Let’s define our diffuse_texture_view and diffuse_sampler now:</p>
<p>现在让我们定义diffuse_texture_view和diffuse_sampler：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// We don&#x27;t need to configure the texture view much, so let&#x27;s</span></span><br><span class="line"><span class="comment">// let wgpu define it.</span></span><br><span class="line"><span class="keyword">let</span> diffuse_texture_view = diffuse_texture.create_view(&amp;wgpu::TextureViewDescriptor::default());</span><br><span class="line"><span class="keyword">let</span> diffuse_sampler = device.create_sampler(&amp;wgpu::SamplerDescriptor &#123;</span><br><span class="line">    address_mode_u: wgpu::AddressMode::ClampToEdge,</span><br><span class="line">    address_mode_v: wgpu::AddressMode::ClampToEdge,</span><br><span class="line">    address_mode_w: wgpu::AddressMode::ClampToEdge,</span><br><span class="line">    mag_filter: wgpu::FilterMode::Linear,</span><br><span class="line">    min_filter: wgpu::FilterMode::Nearest,</span><br><span class="line">    mipmap_filter: wgpu::FilterMode::Nearest,</span><br><span class="line">    ..<span class="built_in">Default</span>::default()</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>The address_mode_* parameters determine what to do if the sampler gets a texture coordinate that’s outside of the texture itself. We have a few options to choose from:</p>
<p>address_mode_*参数决定了如果采样器获得的纹理坐标位于纹理本身之外，该怎么办。我们有几个选项可供选择：</p>
<ul>
<li>ClampToEdge: Any texture coordinates outside the texture will return the color of the nearest pixel on the edges of the texture.</li>
<li>Repeat: The texture will repeat as texture coordinates exceed the textures dimensions.</li>
<li>MirrorRepeat: Similar to Repeat, but the image will flip when going over boundaries.</li>
</ul>
<div></div>

<ul>
<li>ClampToEdge：纹理外部的任何纹理坐标都将返回纹理边缘上最近像素的颜色。</li>
<li>Repeat：纹理坐标超过纹理尺寸时，纹理将重复。</li>
<li>MirrorRepeat: 与“重复”类似，但图像在越过边界时将翻转。</li>
</ul>
<p><img src="https://sotrh.github.io/learn-wgpu/assets/img/address_mode.66a7cd1a.png" alt="sampler"></p>
<p>The mag_filter and min_filter options describe what to do when a fragment covers multiple pixels, or there are multiple fragments for a single pixel. This often comes into play when viewing a surface from up close, or from far away.</p>
<p>mag_filter和min_filter选项描述了当一个片段覆盖多个像素，或者一个像素有多个片段时该怎么做。这通常在从近距离或远处查看曲面时起作用。</p>
<p>There are 2 options:</p>
<p>有两种选择：</p>
<ul>
<li>Linear: Attempt to blend the in-between fragments so that they seem to flow together.</li>
<li>Nearest: In-between fragments will use the color of the nearest pixel. This creates an image that’s crisper from far away, but pixelated up close. This can be desirable, however, if your textures are designed to be pixelated, like in pixel art games, or voxel games like Minecraft.</li>
</ul>
<div></div>

<ul>
<li>Linear: 尝试将片段混合在一起，使它们看起来是一起流动的。</li>
<li>Nearest: 在片段之间，将使用最近像素的颜色。这将创建一个从远处看更清晰的图像，但在近距离内像素化。然而，如果你的纹理被设计成像素化，比如像素艺术游戏，或者像Minecraft这样的体素游戏，这可能是可取的。</li>
</ul>
<p>Mipmaps are a complex topic, and will require their own section in the future. For now, we can say that mipmap_filter functions similar to (mag/min)_filter as it tells the sampler how to blend between mipmaps.</p>
<p>mipmap是一个复杂的主题，将来需要的部分讨论。现在，我们可以说mipmap_filter的功能类似于(mag/min)_filter，因为它告诉采样器如何在mipmap之间混合。</p>
<p>I’m using some defaults for the other fields. If you want to see what they are, check <a target="_blank" rel="noopener" href="https://docs.rs/wgpu/0.7.0/wgpu/struct.SamplerDescriptor.html">the wgpu docs</a>.</p>
<p>我对其他字段使用了一些默认值。如果您想查看它们是什么，请查看<a target="_blank" rel="noopener" href="https://docs.rs/wgpu/0.7.0/wgpu/struct.SamplerDescriptor.html">wgpu文档</a>。</p>
<p>All these different resources are nice and all, but they don’t do us much good if we can’t plug them in anywhere. This is where BindGroups and PipelineLayouts come in.</p>
<p>所有这些不同的资源都很好，但是如果我们不能在任何地方插入它们，它们对我们没有多大好处。这就是BindGroups和PipelineLayouts的用武之地。</p>
<h1 id="The-BindGroup"><a href="#The-BindGroup" class="headerlink" title="The BindGroup"></a>The BindGroup</h1><p>A BindGroup describes a set of resources and how they can be accessed by a shader. We create a BindGroup using a BindGroupLayout. Let’s make one of those first.</p>
<p>BindGroup描述一组资源以及着色器如何访问这些资源。我们使用BindGroupLayout创建一个BindGroup。让我们先做一个。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> texture_bind_group_layout = device.create_bind_group_layout(</span><br><span class="line">    &amp;wgpu::BindGroupLayoutDescriptor &#123;</span><br><span class="line">        entries: &amp;[</span><br><span class="line">            wgpu::BindGroupLayoutEntry &#123;</span><br><span class="line">                binding: <span class="number">0</span>,</span><br><span class="line">                visibility: wgpu::ShaderStage::FRAGMENT,</span><br><span class="line">                ty: wgpu::BindingType::Texture &#123;</span><br><span class="line">                    multisampled: <span class="literal">false</span>,</span><br><span class="line">                    view_dimension: wgpu::TextureViewDimension::D2,</span><br><span class="line">                    sample_type: wgpu::TextureSampleType::Float &#123; filterable: <span class="literal">true</span> &#125;,</span><br><span class="line">                &#125;,</span><br><span class="line">                count: <span class="literal">None</span>,</span><br><span class="line">            &#125;,</span><br><span class="line">            wgpu::BindGroupLayoutEntry &#123;</span><br><span class="line">                binding: <span class="number">1</span>,</span><br><span class="line">                visibility: wgpu::ShaderStage::FRAGMENT,</span><br><span class="line">                ty: wgpu::BindingType::Sampler &#123;</span><br><span class="line">                    <span class="comment">// This is only for TextureSampleType::Depth</span></span><br><span class="line">                    comparison: <span class="literal">false</span>,</span><br><span class="line">                    <span class="comment">// This should be true if the sample_type of the texture is:</span></span><br><span class="line">                    <span class="comment">//     TextureSampleType::Float &#123; filterable: true &#125;</span></span><br><span class="line">                    <span class="comment">// Otherwise you&#x27;ll get an error.</span></span><br><span class="line">                    filtering: <span class="literal">true</span>,</span><br><span class="line">                &#125;,</span><br><span class="line">                count: <span class="literal">None</span>,</span><br><span class="line">            &#125;,</span><br><span class="line">        ],</span><br><span class="line">        label: <span class="literal">Some</span>(<span class="string">&quot;texture_bind_group_layout&quot;</span>),</span><br><span class="line">    &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>Our texture_bind_group_layout has two entries: one for a sampled texture at binding 0, and one for a sampler at binding 1. Both of these bindings are visible only to the fragment shader as specified by FRAGMENT. The possible values for this field are any bitwise combination of NONE, VERTEX, FRAGMENT, or COMPUTE. Most of the time we’ll only use FRAGMENT for textures and samplers, but it’s good to know what else is available.</p>
<p>我们的texture_bind_group_layout有两个条目：一个用于绑定0处的sampled texture，另一个用于绑定1处的sampler。这两个绑定仅对片段指定的片段着色器可见。visibility字段的可能值是NONE、VERTEX、FRAGMENT或COMPUTE的任意位组合。大多数情况下，我们只会对片段使用纹理和采样器，但最好知道还有什么可用的。</p>
<p>With texture_bind_group_layout, we can now create our BindGroup:</p>
<p>使用texture_bind_group_layout，我们现在可以创建BindGroup：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> diffuse_bind_group = device.create_bind_group(</span><br><span class="line">    &amp;wgpu::BindGroupDescriptor &#123;</span><br><span class="line">        layout: &amp;texture_bind_group_layout,</span><br><span class="line">        entries: &amp;[</span><br><span class="line">            wgpu::BindGroupEntry &#123;</span><br><span class="line">                binding: <span class="number">0</span>,</span><br><span class="line">                resource: wgpu::BindingResource::TextureView(&amp;diffuse_texture_view),</span><br><span class="line">            &#125;,</span><br><span class="line">            wgpu::BindGroupEntry &#123;</span><br><span class="line">                binding: <span class="number">1</span>,</span><br><span class="line">                resource: wgpu::BindingResource::Sampler(&amp;diffuse_sampler),</span><br><span class="line">            &#125;</span><br><span class="line">        ],</span><br><span class="line">        label: <span class="literal">Some</span>(<span class="string">&quot;diffuse_bind_group&quot;</span>),</span><br><span class="line">    &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>Looking at this you might get a bit of déjà vu! That’s because a BindGroup is a more specific declaration of the BindGroupLayout. The reason why they’re separate is it allows us to swap out BindGroups on the fly, so long as they all share the same BindGroupLayout. Each texture and sampler we create will need to be added to a BindGroup. For our purposes, we’ll create a new bind group for each texture.</p>
<p>看看这个，你可能会有点似曾相识！这是因为BindGroup是BindGroupLayout的更具体的声明。它们分开的原因是它允许我们动态地交换BindGroups，只要它们都共享相同的BindGroupLayout。我们创建的每个纹理和采样器都需要添加到BindGroup中。出于我们的目的，我们将为每个纹理创建一个新的绑定组。</p>
<p>Now that we have our diffuse_bind_group, let’s add it to our State struct:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">State</span></span> &#123;</span><br><span class="line">    surface: wgpu::Surface,</span><br><span class="line">    device: wgpu::Device,</span><br><span class="line">    queue: wgpu::Queue,</span><br><span class="line">    sc_desc: wgpu::SwapChainDescriptor,</span><br><span class="line">    swap_chain: wgpu::SwapChain,</span><br><span class="line">    size: winit::dpi::PhysicalSize&lt;<span class="built_in">u32</span>&gt;,</span><br><span class="line">    render_pipeline: wgpu::RenderPipeline,</span><br><span class="line">    vertex_buffer: wgpu::Buffer,</span><br><span class="line">    index_buffer: wgpu::Buffer,</span><br><span class="line">    num_indicies: <span class="built_in">u32</span>,</span><br><span class="line">    diffuse_bind_group: wgpu::BindGroup, <span class="comment">// NEW!</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>And make sure we return these fields in the new method:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span> State &#123;</span><br><span class="line">    <span class="keyword">async</span> <span class="function"><span class="keyword">fn</span> <span class="title">new</span></span>() -&gt; <span class="keyword">Self</span> &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="keyword">Self</span> &#123;</span><br><span class="line">            surface,</span><br><span class="line">            device,</span><br><span class="line">            queue,</span><br><span class="line">            sc_desc,</span><br><span class="line">            swap_chain,</span><br><span class="line">            size,</span><br><span class="line">            render_pipeline,</span><br><span class="line">            vertex_buffer,</span><br><span class="line">            index_buffer,</span><br><span class="line">            num_indices,</span><br><span class="line">            <span class="comment">// NEW!</span></span><br><span class="line">            diffuse_bind_group,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Now that we’ve got our BindGroup, we can use it in our render() function.</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// render()</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">render_pass.set_pipeline(&amp;<span class="keyword">self</span>.render_pipeline);</span><br><span class="line">render_pass.set_bind_group(<span class="number">0</span>, &amp;<span class="keyword">self</span>.diffuse_bind_group, &amp;[]); <span class="comment">// NEW!</span></span><br><span class="line">render_pass.set_vertex_buffer(<span class="number">0</span>, <span class="keyword">self</span>.vertex_buffer.slice(..));</span><br><span class="line">render_pass.set_index_buffer(<span class="keyword">self</span>.index_buffer.slice(..), wgpu::IndexFormat::Uint16);</span><br><span class="line"></span><br><span class="line">render_pass.draw_indexed(<span class="number">0</span>..<span class="keyword">self</span>.num_indices, <span class="number">0</span>, <span class="number">0</span>..<span class="number">1</span>);</span><br></pre></td></tr></table></figure>

<h1 id="PipelineLayout"><a href="#PipelineLayout" class="headerlink" title="PipelineLayout"></a>PipelineLayout</h1><p>Remember the PipelineLayout we created back in the pipeline section? Now we finally get to use it! The PipelineLayout contains a list of BindGroupLayouts that the pipeline can use. Modify render_pipeline_layout to use our texture_bind_group_layout.</p>
<p>还记得我们在管道部分创建的PipelineLayout吗？现在我们终于可以使用它了！PipelineLayout包含pipeline可以使用的BindGroupLayouts列表。修改render_pipeline_layout以使用texture_bind_group_layout。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">fn</span> <span class="title">new</span></span>(...) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">let</span> render_pipeline_layout = device.create_pipeline_layout(</span><br><span class="line">        &amp;wgpu::PipelineLayoutDescriptor &#123;</span><br><span class="line">            label: <span class="literal">Some</span>(<span class="string">&quot;Render Pipeline Layout&quot;</span>), <span class="comment">// NEW!</span></span><br><span class="line">            bind_group_layouts: &amp;[&amp;texture_bind_group_layout], <span class="comment">// NEW!</span></span><br><span class="line">            push_constant_ranges: &amp;[],</span><br><span class="line">        &#125;</span><br><span class="line">    );</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="A-change-to-the-VERTICES"><a href="#A-change-to-the-VERTICES" class="headerlink" title="A change to the VERTICES"></a>A change to the VERTICES</h1><p>There’s a few things we need to change about our Vertex definition. Up to now we’ve been using a color attribute to set the color of our mesh. Now that we’re using a texture, we want to replace our color with tex_coords. These coordinates will then be passed to the Sampler to retrieve the appropriate color.</p>
<p>关于顶点定义，我们需要更改一些内容。到目前为止，我们一直在使用颜色属性来设置网格的颜色。现在我们正在使用纹理，我们想用tex_coords替换我们的颜色。然后，这些坐标将传递给采样器以检索适当的颜色。</p>
<p>Since our tex_coords are two dimensional, we’ll change the field to take two floats instead of three.</p>
<p>由于tex_coords是二维的，因此我们将字段更改为采用两个浮点数，而不是三个浮点数。</p>
<p>First, we’ll change the Vertex struct:</p>
<p>首先，我们将更改顶点结构：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[repr(C)]</span></span><br><span class="line"><span class="meta">#[derive(Copy, Clone, Debug, bytemuck::Pod, bytemuck::Zeroable)]</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Vertex</span></span> &#123;</span><br><span class="line">    position: [<span class="built_in">f32</span>; <span class="number">3</span>],</span><br><span class="line">    tex_coords: [<span class="built_in">f32</span>; <span class="number">2</span>], <span class="comment">// NEW!</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>And then reflect these changes in the VertexBufferLayout:</p>
<p>然后在VertexBufferLayout中反映这些更改：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span> Vertex &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">desc</span></span>&lt;<span class="symbol">&#x27;a</span>&gt;() -&gt; wgpu::VertexBufferLayout&lt;<span class="symbol">&#x27;a</span>&gt; &#123;</span><br><span class="line">        <span class="keyword">use</span> std::mem;</span><br><span class="line">        wgpu::VertexBufferLayout &#123;</span><br><span class="line">            array_stride: mem::size_of::&lt;Vertex&gt;() <span class="keyword">as</span> wgpu::BufferAddress,</span><br><span class="line">            step_mode: wgpu::InputStepMode::Vertex,</span><br><span class="line">            attributes: &amp;[</span><br><span class="line">                wgpu::VertexAttribute &#123;</span><br><span class="line">                    offset: <span class="number">0</span>,</span><br><span class="line">                    shader_location: <span class="number">0</span>,</span><br><span class="line">                    format: wgpu::VertexFormat::Float32x3,</span><br><span class="line">                &#125;,</span><br><span class="line">                wgpu::VertexAttribute &#123;</span><br><span class="line">                    offset: mem::size_of::&lt;[<span class="built_in">f32</span>; <span class="number">3</span>]&gt;() <span class="keyword">as</span> wgpu::BufferAddress,</span><br><span class="line">                    shader_location: <span class="number">1</span>,</span><br><span class="line">                    format: wgpu::VertexFormat::Float32x2, <span class="comment">// NEW!</span></span><br><span class="line">                &#125;,</span><br><span class="line">            ]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Lastly we need to change VERTICES itself. Replace the existing definition with the following:</p>
<p>最后，我们需要改变顶点本身。将现有定义替换为以下内容：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Changed</span></span><br><span class="line"><span class="keyword">const</span> VERTICES: &amp;[Vertex] = &amp;[</span><br><span class="line">    Vertex &#123; position: [-<span class="number">0.0868241</span>, <span class="number">0.49240386</span>, <span class="number">0.0</span>], tex_coords: [<span class="number">0.4131759</span>, <span class="number">0.99240386</span>], &#125;, <span class="comment">// A</span></span><br><span class="line">    Vertex &#123; position: [-<span class="number">0.49513406</span>, <span class="number">0.06958647</span>, <span class="number">0.0</span>], tex_coords: [<span class="number">0.0048659444</span>, <span class="number">0.56958646</span>], &#125;, <span class="comment">// B</span></span><br><span class="line">    Vertex &#123; position: [-<span class="number">0.21918549</span>, -<span class="number">0.44939706</span>, <span class="number">0.0</span>], tex_coords: [<span class="number">0.28081453</span>, <span class="number">0.050602943</span>], &#125;, <span class="comment">// C</span></span><br><span class="line">    Vertex &#123; position: [<span class="number">0.35966998</span>, -<span class="number">0.3473291</span>, <span class="number">0.0</span>], tex_coords: [<span class="number">0.85967</span>, <span class="number">0.15267089</span>], &#125;, <span class="comment">// D</span></span><br><span class="line">    Vertex &#123; position: [<span class="number">0.44147372</span>, <span class="number">0.2347359</span>, <span class="number">0.0</span>], tex_coords: [<span class="number">0.9414737</span>, <span class="number">0.7347359</span>], &#125;, <span class="comment">// E</span></span><br><span class="line">];</span><br></pre></td></tr></table></figure>

<h1 id="Shader-time"><a href="#Shader-time" class="headerlink" title="Shader time"></a>Shader time</h1><p>With our new Vertex structure in place it’s time to update our shaders. We’ll first need to pass our tex_coords into the vertex shader and then use them over to our fragment shader to get the final color from the Sampler. Let’s start with the vertex shader:</p>
<p>随着新顶点结构的就位，是时候更新着色器了。我们首先需要将tex_coords传递到顶点着色器，然后将它们传递到片段着色器，以从采样器获得最终颜色。让我们从顶点着色器开始：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Vertex shader</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">VertexInput</span></span> &#123;</span><br><span class="line">    [[location(<span class="number">0</span>)]] position: vec3&lt;<span class="built_in">f32</span>&gt;;</span><br><span class="line">    [[location(<span class="number">1</span>)]] tex_coords: vec2&lt;<span class="built_in">f32</span>&gt;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">VertexOutput</span></span> &#123;</span><br><span class="line">    [[builtin(position)]] clip_position: vec4&lt;<span class="built_in">f32</span>&gt;;</span><br><span class="line">    [[location(<span class="number">0</span>)]] tex_coords: vec2&lt;<span class="built_in">f32</span>&gt;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">[[stage(vertex)]]</span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>(</span><br><span class="line">    model: VertexInput,</span><br><span class="line">) -&gt; VertexOutput &#123;</span><br><span class="line">    var out: VertexOutput;</span><br><span class="line">    out.tex_coords = model.tex_coords;</span><br><span class="line">    out.clip_position = vec4&lt;<span class="built_in">f32</span>&gt;(model.position, <span class="number">1.0</span>);</span><br><span class="line">    <span class="keyword">return</span> out;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Now that we have our vertex shader outputting our tex_coords, we need to change the fragment shader to take them in. With these coordinates, we’ll finally be able to use our sampler to get a color from our texture.</p>
<p>现在我们已经有了顶点着色器输出tex_coords，我们需要更改片段着色器以接收它们。有了这些坐标，我们最终可以使用采样器从纹理中获取颜色。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Fragment shader</span></span><br><span class="line"></span><br><span class="line">[[group(<span class="number">0</span>), binding(<span class="number">0</span>)]]</span><br><span class="line">var t_diffuse: texture_2d&lt;<span class="built_in">f32</span>&gt;;</span><br><span class="line">[[group(<span class="number">0</span>), binding(<span class="number">1</span>)]]</span><br><span class="line">var s_diffuse: sampler;</span><br><span class="line"></span><br><span class="line">[[stage(fragment)]]</span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>(<span class="keyword">in</span>: VertexOutput) -&gt; [[location(<span class="number">0</span>)]] vec4&lt;<span class="built_in">f32</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> textureSample(t_diffuse, s_diffuse, <span class="keyword">in</span>.tex_coords);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>The variables t_diffuse and s_diffuse are what’s known as uniforms. We’ll go over uniforms more in the cameras section. For now, all we need to know is that group() corresponds to the 1st parameter in set_bind_group() and binding() relates to the binding specified when we created the BindGroupLayout and BindGroup.</p>
<p>变量t_diffuse和s_diffuse称为uniforms。我们将在照相机部分详细介绍uniforms。现在，我们只需要知道group()对应于set_bind_group()中的第一个参数，binding()与创建BindGroupLayout和BindGroup时指定的绑定相关。</p>
<h1 id="The-results"><a href="#The-results" class="headerlink" title="The results"></a>The results</h1><p>If we run our program now we should get the following result:</p>
<p><img src="https://sotrh.github.io/learn-wgpu/assets/img/upside-down.d50c3643.png" alt="result"></p>
<p>That’s weird, our tree is upside down! This is because wgpu’s world coordinates have the y-axis pointing up, while texture coordinates have the y-axis pointing down. In other words, (0, 0) in texture coordinates coresponds to the top-left of the image, while (1, 1) is the bottom right.</p>
<p>真奇怪，我们的树倒了！这是因为wgpu的世界坐标的y轴指向上，而纹理坐标的y轴指向下。换句话说，纹理坐标中的（0，0）对应于图像的左上角，而（1，1）对应于右下角。</p>
<p><img src="https://sotrh.github.io/learn-wgpu/assets/img/happy-tree-uv-coords.aa3b7d36.png" alt="纹理"></p>
<p>We can get our triangle right-side up by inverting the y coordinate of each texture coordinate:</p>
<p>通过反转每个纹理坐标的y坐标，我们可以使三角形正面朝上：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> VERTICES: &amp;[Vertex] = &amp;[</span><br><span class="line">    <span class="comment">// Changed</span></span><br><span class="line">    Vertex &#123; position: [-<span class="number">0.0868241</span>, <span class="number">0.49240386</span>, <span class="number">0.0</span>], tex_coords: [<span class="number">0.4131759</span>, <span class="number">0.00759614</span>], &#125;, <span class="comment">// A</span></span><br><span class="line">    Vertex &#123; position: [-<span class="number">0.49513406</span>, <span class="number">0.06958647</span>, <span class="number">0.0</span>], tex_coords: [<span class="number">0.0048659444</span>, <span class="number">0.43041354</span>], &#125;, <span class="comment">// B</span></span><br><span class="line">    Vertex &#123; position: [-<span class="number">0.21918549</span>, -<span class="number">0.44939706</span>, <span class="number">0.0</span>], tex_coords: [<span class="number">0.28081453</span>, <span class="number">0.949397</span>], &#125;, <span class="comment">// C</span></span><br><span class="line">    Vertex &#123; position: [<span class="number">0.35966998</span>, -<span class="number">0.3473291</span>, <span class="number">0.0</span>], tex_coords: [<span class="number">0.85967</span>, <span class="number">0.84732914</span>], &#125;, <span class="comment">// D</span></span><br><span class="line">    Vertex &#123; position: [<span class="number">0.44147372</span>, <span class="number">0.2347359</span>, <span class="number">0.0</span>], tex_coords: [<span class="number">0.9414737</span>, <span class="number">0.2652641</span>], &#125;, <span class="comment">// E</span></span><br><span class="line">];</span><br></pre></td></tr></table></figure>

<p>With that in place, we now have our tree right-side up on our hexagon:</p>
<p>有了它，我们的树就在六边形的正确位置：</p>
<p><img src="https://sotrh.github.io/learn-wgpu/assets/img/rightside-up.75f852e2.png" alt="纹理"></p>
<h1 id="Cleaning-things-up"><a href="#Cleaning-things-up" class="headerlink" title="Cleaning things up"></a>Cleaning things up</h1><p>For convenience sake, let’s pull our texture code into its module. We’ll first need to add the anyhow crate to our Cargo.toml file to simplify error handling;</p>
<p>为了方便起见，让我们将纹理代码拉入其模块。我们首先需要将anyhow crate添加到Cargo.toml文件中，以简化错误处理；</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[dependencies]</span><br><span class="line">image = <span class="string">&quot;0.23&quot;</span></span><br><span class="line">cgmath = <span class="string">&quot;0.18&quot;</span></span><br><span class="line">winit = <span class="string">&quot;0.25&quot;</span></span><br><span class="line">env_logger = <span class="string">&quot;0.9&quot;</span></span><br><span class="line">log = <span class="string">&quot;0.4&quot;</span></span><br><span class="line">pollster = <span class="string">&quot;0.2&quot;</span></span><br><span class="line">wgpu = <span class="string">&quot;0.9&quot;</span></span><br><span class="line">bytemuck = &#123; version = <span class="string">&quot;1.4&quot;</span>, features = [ <span class="string">&quot;derive&quot;</span> ] &#125;</span><br><span class="line">anyhow = <span class="string">&quot;1.0&quot;</span> <span class="comment">// NEW!</span></span><br></pre></td></tr></table></figure>

<p>Then, in a new file called src/texture.rs, add the following:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> image::GenericImageView;</span><br><span class="line"><span class="keyword">use</span> anyhow::*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">Texture</span></span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> texture: wgpu::Texture,</span><br><span class="line">    <span class="keyword">pub</span> view: wgpu::TextureView,</span><br><span class="line">    <span class="keyword">pub</span> sampler: wgpu::Sampler,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> Texture &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">from_bytes</span></span>(</span><br><span class="line">        device: &amp;wgpu::Device,</span><br><span class="line">        queue: &amp;wgpu::Queue,</span><br><span class="line">        bytes: &amp;[<span class="built_in">u8</span>], </span><br><span class="line">        label: &amp;<span class="built_in">str</span></span><br><span class="line">    ) -&gt; <span class="built_in">Result</span>&lt;<span class="keyword">Self</span>&gt; &#123;</span><br><span class="line">        <span class="keyword">let</span> img = image::load_from_memory(bytes)?;</span><br><span class="line">        Self::from_image(device, queue, &amp;img, <span class="literal">Some</span>(label))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">from_image</span></span>(</span><br><span class="line">        device: &amp;wgpu::Device,</span><br><span class="line">        queue: &amp;wgpu::Queue,</span><br><span class="line">        img: &amp;image::DynamicImage,</span><br><span class="line">        label: <span class="built_in">Option</span>&lt;&amp;<span class="built_in">str</span>&gt;</span><br><span class="line">    ) -&gt; <span class="built_in">Result</span>&lt;<span class="keyword">Self</span>&gt; &#123;</span><br><span class="line">        <span class="keyword">let</span> rgba = img.as_rgba8().unwrap();</span><br><span class="line">        <span class="keyword">let</span> dimensions = img.dimensions();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> size = wgpu::Extent3d &#123;</span><br><span class="line">            width: dimensions.<span class="number">0</span>,</span><br><span class="line">            height: dimensions.<span class="number">1</span>,</span><br><span class="line">            depth_or_array_layers: <span class="number">1</span>,</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">let</span> texture = device.create_texture(</span><br><span class="line">            &amp;wgpu::TextureDescriptor &#123;</span><br><span class="line">                label,</span><br><span class="line">                size,</span><br><span class="line">                mip_level_count: <span class="number">1</span>,</span><br><span class="line">                sample_count: <span class="number">1</span>,</span><br><span class="line">                dimension: wgpu::TextureDimension::D2,</span><br><span class="line">                format: wgpu::TextureFormat::Rgba8UnormSrgb,</span><br><span class="line">                usage: wgpu::TextureUsage::SAMPLED | wgpu::TextureUsage::COPY_DST,</span><br><span class="line">            &#125;</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        queue.write_texture(</span><br><span class="line">            wgpu::ImageCopyTexture &#123;</span><br><span class="line">                texture: &amp;texture,</span><br><span class="line">                mip_level: <span class="number">0</span>,</span><br><span class="line">                origin: wgpu::Origin3d::ZERO,</span><br><span class="line">            &#125;,</span><br><span class="line">            rgba,</span><br><span class="line">            wgpu::ImageDataLayout &#123;</span><br><span class="line">                offset: <span class="number">0</span>,</span><br><span class="line">                bytes_per_row: std::num::NonZeroU32::new(<span class="number">4</span> * dimensions.<span class="number">0</span>),</span><br><span class="line">                rows_per_image: std::num::NonZeroU32::new(dimensions.<span class="number">1</span>),</span><br><span class="line">            &#125;,</span><br><span class="line">            size,</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> view = texture.create_view(&amp;wgpu::TextureViewDescriptor::default());</span><br><span class="line">        <span class="keyword">let</span> sampler = device.create_sampler(</span><br><span class="line">            &amp;wgpu::SamplerDescriptor &#123;</span><br><span class="line">                address_mode_u: wgpu::AddressMode::ClampToEdge,</span><br><span class="line">                address_mode_v: wgpu::AddressMode::ClampToEdge,</span><br><span class="line">                address_mode_w: wgpu::AddressMode::ClampToEdge,</span><br><span class="line">                mag_filter: wgpu::FilterMode::Linear,</span><br><span class="line">                min_filter: wgpu::FilterMode::Nearest,</span><br><span class="line">                mipmap_filter: wgpu::FilterMode::Nearest,</span><br><span class="line">                ..<span class="built_in">Default</span>::default()</span><br><span class="line">            &#125;</span><br><span class="line">        );</span><br><span class="line">        </span><br><span class="line">        <span class="literal">Ok</span>(<span class="keyword">Self</span> &#123; texture, view, sampler &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Note that we’re returning a CommandBuffer with our texture. This means we can load multiple textures at the same time, and then submit all their command buffers at once.</p>
<p>请注意，我们返回CommandBuffer使用纹理。这意味着我们可以同时加载多个纹理，然后一次提交它们的所有命令缓冲区。</p>
<p>We need to import texture.rs as a module, so somewhere at the top of main.rs add the following.</p>
<p>我们需要将texture.rs作为一个模块导入，因此在main.rs顶部的某处添加以下内容。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mod</span> texture;</span><br></pre></td></tr></table></figure>

<p>The texture creation code in new() now gets a lot simpler:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> swap_chain = device.create_swap_chain(&amp;surface, &amp;sc_desc);</span><br><span class="line"><span class="keyword">let</span> diffuse_bytes = include_bytes!(<span class="string">&quot;happy-tree.png&quot;</span>); <span class="comment">// CHANGED!</span></span><br><span class="line"><span class="keyword">let</span> diffuse_texture = texture::Texture::from_bytes(&amp;device, &amp;queue, diffuse_bytes, <span class="string">&quot;happy-tree.png&quot;</span>).unwrap(); <span class="comment">// CHANGED!</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Everything up until `let texture_bind_group_layout = ...` can now be removed.</span></span><br></pre></td></tr></table></figure>

<p>We still need to store the bind group separately so that Texture doesn’t need know how the BindGroup is laid out. Creating the diffuse_bind_group changes slightly to use the view and sampler fields of our diffuse_texture:</p>
<p>我们仍然需要单独存储bind group，这样纹理就不需要知道BindGroup是如何布置的。创建diffuse_bind_group时会稍微更改，以使用diffuse_texture的view和sampler字段：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> diffuse_bind_group = device.create_bind_group(</span><br><span class="line">    &amp;wgpu::BindGroupDescriptor &#123;</span><br><span class="line">        layout: &amp;texture_bind_group_layout,</span><br><span class="line">        entries: &amp;[</span><br><span class="line">            wgpu::BindGroupEntry &#123;</span><br><span class="line">                binding: <span class="number">0</span>,</span><br><span class="line">                resource: wgpu::BindingResource::TextureView(&amp;diffuse_texture.view), <span class="comment">// CHANGED!</span></span><br><span class="line">            &#125;,</span><br><span class="line">            wgpu::BindGroupEntry &#123;</span><br><span class="line">                binding: <span class="number">1</span>,</span><br><span class="line">                resource: wgpu::BindingResource::Sampler(&amp;diffuse_texture.sampler), <span class="comment">// CHANGED!</span></span><br><span class="line">            &#125;</span><br><span class="line">        ],</span><br><span class="line">        label: <span class="literal">Some</span>(<span class="string">&quot;diffuse_bind_group&quot;</span>),</span><br><span class="line">    &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>Finally, let’s update our State field to use our shiny new Texture struct, as we’ll need it in future tutorials.</p>
<p>最后，让我们更新State字段以使用闪亮的新纹理结构，因为我们将在未来的教程中需要它。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">State</span></span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    diffuse_bind_group: wgpu::BindGroup,</span><br><span class="line">    diffuse_texture: texture::Texture, <span class="comment">// NEW</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span> State &#123;</span><br><span class="line">    <span class="keyword">async</span> <span class="function"><span class="keyword">fn</span> <span class="title">new</span></span>() -&gt; <span class="keyword">Self</span> &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="keyword">Self</span> &#123;</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">            num_indices,</span><br><span class="line">            diffuse_bind_group,</span><br><span class="line">            diffuse_texture, <span class="comment">// NEW</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Phew!</p>
<p>With these changes in place, the code should be working the same as it was before, but we now have a much easier way to create textures.</p>
<p>有了这些更改，代码应该和以前一样工作，但是我们现在有了一种更简单的方法来创建纹理。</p>
<h1 id="Challenge"><a href="#Challenge" class="headerlink" title="Challenge"></a>Challenge</h1><p>创建另一个纹理，并在按空格键时将其调出。</p>
<p><a target="_blank" rel="noopener" href="https://github.com/sotrh/learn-wgpu/tree/master/code/beginner/tutorial5-textures/">Check out the code!</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://qianqians.github.io/2021/08/24/Wgpu%20Buffers%20and%20Indices/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="qianqians">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="qianqians'blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/08/24/Wgpu%20Buffers%20and%20Indices/" class="post-title-link" itemprop="url">Wgpu Buffers and Indices</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-08-24 14:46:40" itemprop="dateCreated datePublished" datetime="2021-08-24T14:46:40+08:00">2021-08-24</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-09-15 16:51:26" itemprop="dateModified" datetime="2021-09-15T16:51:26+08:00">2021-09-15</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Wgpu/" itemprop="url" rel="index"><span itemprop="name">Wgpu</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="We’re-finally-talking-about-them"><a href="#We’re-finally-talking-about-them" class="headerlink" title="We’re finally talking about them!"></a>We’re finally talking about them!</h1><p>You were probably getting sick of me saying stuff like “we’ll get to that when we talk about buffers”. Well now’s the time to finally talk about buffers, but first…</p>
<p>你可能已经厌倦了我说的那些话，比如”当我们谈论缓冲区的时候，我们会说到那个”。现在是时候讨论缓冲区了，但是首先。。。</p>
<h1 id="What-is-a-buffer"><a href="#What-is-a-buffer" class="headerlink" title="What is a buffer?"></a>What is a buffer?</h1><p>A buffer is a blob of data on the GPU. A buffer is guaranteed to be contiguous, meaning that all the data is stored sequentially in memory. Buffers are generally used to store simple things like structs or arrays, but it can store more complex stuff such as graph structures like trees (provided all the nodes are stored together and don’t reference anything outside of the buffer). We are going to use buffers a lot, so let’s get started with two of the most important ones: the vertex buffer, and the index buffer.</p>
<p>缓冲区是GPU上的一团数据。缓冲区保证是连续的，这意味着所有数据都按顺序存储在内存中。缓冲区通常用于存储简单的东西，如结构或数组，但它可以存储更复杂的东西，如树等图形结构（前提是所有节点都存储在一起，并且不引用缓冲区之外的任何内容）。我们将大量使用缓冲区，因此让我们从两个最重要的缓冲区开始：顶点缓冲区和索引缓冲区。</p>
<h1 id="The-vertex-buffer"><a href="#The-vertex-buffer" class="headerlink" title="The vertex buffer"></a>The vertex buffer</h1><p>Previously we’ve stored vertex data directly in the vertex shader. While that worked fine to get our bootstraps on, it simply won’t do for the long-term. The types of objects we need to draw will vary in size, and recompiling the shader whenever we need to update the model would massively slow down our program. Instead we are going to use buffers to store the vertex data we want to draw. Before we do that though we need to describe what a vertex looks like. We’ll do this by creating a new struct.</p>
<p>之前，我们将顶点数据直接存储在顶点着色器中。虽然这样做可以很好地启动我们的引导系统，但从长远来看，这样做是行不通的。我们需要绘制的对象类型在大小上会有所不同，每当我们需要更新模型时重新编译着色器将大大降低我们的程序速度。相反，我们将使用缓冲区来存储要绘制的顶点数据。在我们这样做之前，我们需要描述一个顶点是什么样子的。我们将通过创建一个新的结构来实现这一点。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main.rs</span></span><br><span class="line"><span class="meta">#[repr(C)]</span></span><br><span class="line"><span class="meta">#[derive(Copy, Clone, Debug)]</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Vertex</span></span> &#123;</span><br><span class="line">    position: [<span class="built_in">f32</span>; <span class="number">3</span>],</span><br><span class="line">    color: [<span class="built_in">f32</span>; <span class="number">3</span>],</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Our vertices will all have a position and a color. The position represents the x, y, and z of the vertex in 3d space. The color is the red, green, and blue values for the vertex. We need the Vertex to be copyable so we can create a buffer with it.</p>
<p>我们的顶点都有一个位置和颜色。该位置表示三维空间中顶点的x、y和z。颜色是顶点的红色、绿色和蓝色值。我们需要顶点是可复制的，这样我们就可以用它创建一个缓冲区。</p>
<p>Next we need the actual data that will make up our triangle. Below Vertex add the following.</p>
<p>接下来，我们需要组成三角形的实际数据。在顶点下方添加以下内容。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//main.rs</span></span><br><span class="line"><span class="keyword">const</span> VERTICES: &amp;[Vertex] = &amp;[</span><br><span class="line">    Vertex &#123; position: [<span class="number">0.0</span>, <span class="number">0.5</span>, <span class="number">0.0</span>], color: [<span class="number">1.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>] &#125;,</span><br><span class="line">    Vertex &#123; position: [-<span class="number">0.5</span>, -<span class="number">0.5</span>, <span class="number">0.0</span>], color: [<span class="number">0.0</span>, <span class="number">1.0</span>, <span class="number">0.0</span>] &#125;,</span><br><span class="line">    Vertex &#123; position: [<span class="number">0.5</span>, -<span class="number">0.5</span>, <span class="number">0.0</span>], color: [<span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">1.0</span>] &#125;,</span><br><span class="line">];</span><br></pre></td></tr></table></figure>

<p>We arrange the vertices in counter clockwise order: top, bottom left, bottom right. We do it this way partially out of tradition, but mostly because we specified in the rasterization_state of the render_pipeline that we want the front_face of our triangle to be wgpu::FrontFace::Ccw so that we cull the back face. This means that any triangle that should be facing us should have its vertices in counter clockwise order.</p>
<p>我们按逆时针顺序排列顶点：顶部、左下角、右下角。我们这样做部分是出于传统，但主要是因为我们在渲染管道的光栅化状态中指定，我们希望三角形的前表面为wgpu::FrontFace::Ccw，以便剔除后表面。这意味着任何面向我们的三角形的顶点都应该按逆时针顺序排列。</p>
<p>Now that we have our vertex data, we need to store it in a buffer. Let’s add a vertex_buffer field to State.</p>
<p>现在我们有了顶点数据，我们需要将其存储在缓冲区中。让我们向State添加一个顶点vertex_buffer字段。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main.rs</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">State</span></span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    render_pipeline: wgpu::RenderPipeline,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// NEW!</span></span><br><span class="line">    vertex_buffer: wgpu::Buffer,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Now let’s create the buffer in new().</p>
<p>现在让我们在new()中创建缓冲区。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// new()</span></span><br><span class="line"><span class="keyword">let</span> vertex_buffer = device.create_buffer_init(</span><br><span class="line">    &amp;wgpu::util::BufferInitDescriptor &#123;</span><br><span class="line">        label: <span class="literal">Some</span>(<span class="string">&quot;Vertex Buffer&quot;</span>),</span><br><span class="line">        contents: bytemuck::cast_slice(VERTICES),</span><br><span class="line">        usage: wgpu::BufferUsage::VERTEX,</span><br><span class="line">    &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>To access the create_buffer_init method on wgpu::Device we’ll have to import the DeviceExt extension trait. For more information on extension traits, check out this article.</p>
<p>要访问wgpu::Device上的create_buffer_init方法，我们必须导入DeviceExt扩展特性。有关扩展特性的更多信息，请参阅本文。</p>
<p>To import the extension trait, this line somewhere near the top of main.rs.</p>
<p>要导入扩展特性，请在main.rs顶部附近的某个位置输入如下代码。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> wgpu::util::DeviceExt;</span><br></pre></td></tr></table></figure>

<p>You’ll note that we’re using bytemuck to cast our VERTICES as a &amp;[u8]. The create_buffer_init() method expects a &amp;[u8], and bytemuck::cast_slice does that for us. Add the following to your Cargo.toml.</p>
<p>您会注意到，我们使用bytemuck将顶点转换为&amp;[u8]。create_buffer_init()方法需要一个&amp;[u8]，而bytemuck::cast_slice则为我们这样做。将以下内容添加到Cargo.toml中。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bytemuck = &#123; version = <span class="string">&quot;1.4&quot;</span>, features = [ <span class="string">&quot;derive&quot;</span> ] &#125;</span><br></pre></td></tr></table></figure>

<p>We’re also going to need to implement two traits to get bytemuck to work. These are bytemuck::Pod and bytemuck::Zeroable. Pod indicates that our Vertex is “Plain Old Data”, and thus can be interpretted as a &amp;[u8]. Zeroable indicates that we can use std::mem::zeroed(). We can modify our Vertex struct to derive these methods.</p>
<p>为了让bytemuck发挥作用，我们还需要实现两个特性。它们是bytemuck::Pod和bytemuck::Zeroable。Pod表示我们的顶点是“普通的旧数据”，因此可以解释为a&amp;[u8]。Zeroable表示我们可以使用std::mem::zeroed()。我们可以修改顶点结构来派生这些方法。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[repr(C)]</span></span><br><span class="line"><span class="meta">#[derive(Copy, Clone, Debug, bytemuck::Pod, bytemuck::Zeroable)]</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Vertex</span></span> &#123;</span><br><span class="line">    position: [<span class="built_in">f32</span>; <span class="number">3</span>],</span><br><span class="line">    color: [<span class="built_in">f32</span>; <span class="number">3</span>],</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<div class="note">

<p>If your struct includes types that don’t implement Pod and Zeroable, you’ll need to implement these traits manually. These traits don’t require us to implement any methods, so we just need to use the following to get our code to work.</p>
<p>如果您的结构包含未实现Pod和Zeroable的类型，则需要手动实现这些特性。这些特性不需要我们实现任何方法，所以我们只需要使用以下方法来让代码正常工作。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unsafe</span> <span class="keyword">impl</span> bytemuck::Pod <span class="keyword">for</span> Vertex &#123;&#125;</span><br><span class="line"><span class="keyword">unsafe</span> <span class="keyword">impl</span> bytemuck::Zeroable <span class="keyword">for</span> Vertex &#123;&#125;</span><br></pre></td></tr></table></figure>

</div>

<p>Finally we can add our vertex_buffer to our State struct.</p>
<p>最后，我们可以将顶点缓冲区添加到结构体State中。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Self</span> &#123;</span><br><span class="line">    surface,</span><br><span class="line">    device,</span><br><span class="line">    queue,</span><br><span class="line">    sc_desc,</span><br><span class="line">    swap_chain,</span><br><span class="line">    size,</span><br><span class="line">    render_pipeline,</span><br><span class="line">    vertex_buffer,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="So-what-do-I-do-with-it"><a href="#So-what-do-I-do-with-it" class="headerlink" title="So what do I do with it?"></a>So what do I do with it?</h1><p>We need to tell the render_pipeline to use this buffer when we are drawing, but first we need to tell the render_pipeline how to read the buffer. We do this using VertexBufferLayouts and the vertex_buffers field that I promised we’d talk about when we created the render_pipeline.</p>
<p>我们需要告诉render_pipeline在绘图时使用此缓冲区，但首先我们需要告诉render_pipeline如何读取缓冲区。我们使用VertexBufferLayouts和vertex_buffers字段来实现这一点，我在创建render_pipeline时承诺过要讨论这个字段。</p>
<p>A VertexBufferLayout defines how a buffer is layed out in memory. Without this, the render_pipeline has no idea how to map the buffer in the shader. Here’s what the descriptor for a buffer full of Vertex would look like.</p>
<p>VertexBufferLayout定义缓冲区在内存中的布局方式。如果没有此选项，渲染管道将不知道如何映射着色器中的缓冲区。下面是一个充满顶点的缓冲区的描述符。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">wgpu::VertexBufferLayout &#123;</span><br><span class="line">    array_stride: std::mem::size_of::&lt;Vertex&gt;() <span class="keyword">as</span> wgpu::BufferAddress, <span class="comment">// 1.</span></span><br><span class="line">    step_mode: wgpu::InputStepMode::Vertex, <span class="comment">// 2.</span></span><br><span class="line">    attributes: &amp;[ <span class="comment">// 3.</span></span><br><span class="line">        wgpu::VertexAttribute &#123;</span><br><span class="line">            offset: <span class="number">0</span>, <span class="comment">// 4.</span></span><br><span class="line">            shader_location: <span class="number">0</span>, <span class="comment">// 5.</span></span><br><span class="line">            format: wgpu::VertexFormat::Float32x3, <span class="comment">// 6.</span></span><br><span class="line">        &#125;,</span><br><span class="line">        wgpu::VertexAttribute &#123;</span><br><span class="line">            offset: std::mem::size_of::&lt;[<span class="built_in">f32</span>; <span class="number">3</span>]&gt;() <span class="keyword">as</span> wgpu::BufferAddress,</span><br><span class="line">            shader_location: <span class="number">1</span>,</span><br><span class="line">            format: wgpu::VertexFormat::Float32x3,</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>The array_stride defines how wide a vertex is. When the shader goes to read the next vertex, it will skip over array_stride number of bytes. In our case, array_stride will probably be 24 bytes.</li>
<li>step_mode tells the pipeline how often it should move to the next vertex. This seems redundant in our case, but we can specify wgpu::InputStepMode::Instance if we only want to change vertices when we start drawing a new instance. We’ll cover instancing in a later tutorial.</li>
<li>Vertex attributes describe the individual parts of the vertex. Generally this is a 1:1 mapping with a struct’s fields, which it is in our case.</li>
<li>This defines the offset in bytes that this attribute starts. The first attribute is usually zero, and any future attributes are the collective size_of the previous attributes data.</li>
<li>This tells the shader what location to store this attribute at. For example layout(location=0) in vec3 x in the vertex shader would correspond to the position field of the struct, while layout(location=1) in vec3 x would be the color field.</li>
<li>format tells the shader the shape of the attribute. Float3 corresponds to vec3 in shader code. The max value we can store in an attribute is Float4 (Uint4, and Int4 work as well). We’ll keep this in mind for when we have to store things that are bigger than Float4.</li>
</ol>
<div></div>

<ol>
<li>array_stride定义顶点的宽度。当着色器读取下一个顶点时，它将跳过数组的字节数。在我们的例子中，数组的步长可能是24字节。</li>
<li>step_mode告诉管道它应该移动到下一个顶点的频率。在我们的例子中，这似乎是多余的，但如果我们只想在开始绘制新实例时更改顶点，则可以指定wgpu::InputStepMode::Instance。我们将在后面的教程中介绍实例化。</li>
<li>顶点属性描述顶点的各个部分。通常，这是一个1:1映射，带有结构的字段，在我们的例子中就是这样。</li>
<li>这定义了该属性开始的偏移量（以字节为单位）。第一个属性通常为零，任何未来属性都是前一个属性数据的集合大小。</li>
<li>这将告知着色器存储此属性的位置。例如，顶点着色器中vec3 x中的布局（位置=0）将对应于结构的位置字段，而vec3 x中的布局（位置=1）将对应于颜色字段。</li>
<li>format告诉着色器属性的布局。Float3对应于着色器代码中的vec3。我们可以存储在属性中的最大值是Float4（Uint4和Int4也可以使用）。当我们必须存储比Float4大的东西时，我们会注意这一点。</li>
</ol>
<p>For you visually learners, our vertex buffer looks like this.</p>
<p>对于您来说，我们的顶点缓冲区如下所示。</p>
<p><img src="https://sotrh.github.io/learn-wgpu/assets/img/vb_desc.63afb652.png" alt="顶点缓冲区"></p>
<p>Let’s create a static method on Vertex that returns this descriptor.</p>
<p>让我们在顶点上创建一个静态方法，返回这个描述符。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main.rs</span></span><br><span class="line"><span class="keyword">impl</span> Vertex &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">desc</span></span>&lt;<span class="symbol">&#x27;a</span>&gt;() -&gt; wgpu::VertexBufferLayout&lt;<span class="symbol">&#x27;a</span>&gt; &#123;</span><br><span class="line">        wgpu::VertexBufferLayout &#123;</span><br><span class="line">            array_stride: std::mem::size_of::&lt;Vertex&gt;() <span class="keyword">as</span> wgpu::BufferAddress,</span><br><span class="line">            step_mode: wgpu::InputStepMode::Vertex,</span><br><span class="line">            attributes: &amp;[</span><br><span class="line">                wgpu::VertexAttribute &#123;</span><br><span class="line">                    offset: <span class="number">0</span>,</span><br><span class="line">                    shader_location: <span class="number">0</span>,</span><br><span class="line">                    format: wgpu::VertexFormat::Float32x3,</span><br><span class="line">                &#125;,</span><br><span class="line">                wgpu::VertexAttribute &#123;</span><br><span class="line">                    offset: std::mem::size_of::&lt;[<span class="built_in">f32</span>; <span class="number">3</span>]&gt;() <span class="keyword">as</span> wgpu::BufferAddress,</span><br><span class="line">                    shader_location: <span class="number">1</span>,</span><br><span class="line">                    format: wgpu::VertexFormat::Float32x3,</span><br><span class="line">                &#125;</span><br><span class="line">            ]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<div class="note">

<p>Specifying the attributes as we did now is quite verbose. We could use the vertex_attr_array macro provided by wgpu to clean things up a bit. With it our VertexBufferLayout becomes</p>
<p>像我们现在这样指定属性是相当冗长的。我们可以使用wgpu提供的vertex_attr_array宏稍微清理一下。有了它，我们的VertexBuffer布局变得</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">wgpu::VertexBufferLayout &#123;</span><br><span class="line">    array_stride: std::mem::size_of::&lt;Vertex&gt;() <span class="keyword">as</span> wgpu::BufferAddress,</span><br><span class="line">    step_mode: wgpu::InputStepMode::Vertex,</span><br><span class="line">    attributes: &amp;wgpu::vertex_attr_array![<span class="number">0</span> =&gt; Float32x3, <span class="number">1</span> =&gt; Float32x3],</span><br><span class="line">&#125;   </span><br></pre></td></tr></table></figure>

<p>While this is definitely nice, we would have to change the lifetime on wgpu::VertexBufferLayout to ‘static as rust wouldn’t compile the code because the result of vertex_attr_array is a temporary value, which we can’t return from a function.</p>
<p>虽然这确实很好，但我们必须将wgpu::VertexBufferLayout上的生存期更改为“静态”，因为rust不会编译代码，因为vertex_attr_array数组的结果是一个临时值，我们无法从函数返回。</p>
<p>Beyond that, I feel it’s good to show how the data gets mapped, so I’ll forgo using this macro for now.</p>
<p>除此之外，我觉得展示数据是如何映射的很好，所以我现在放弃使用这个宏。</p>
</div>

<p>Now we can use it when we create the render_pipeline.</p>
<p>现在，我们可以在创建render_pipeline时使用它。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> render_pipeline = device.create_render_pipeline(&amp;wgpu::RenderPipelineDescriptor &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    vertex: wgpu::VertexState &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        buffers: &amp;[</span><br><span class="line">            Vertex::desc(),</span><br><span class="line">        ],</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>One more thing: we need to actually set the vertex buffer in the render method otherwise our program will crash.</p>
<p>还有一件事：我们需要在渲染方法中实际设置顶点缓冲区，否则我们的程序将崩溃。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// render()</span></span><br><span class="line">render_pass.set_pipeline(&amp;<span class="keyword">self</span>.render_pipeline);</span><br><span class="line"><span class="comment">// NEW!</span></span><br><span class="line">render_pass.set_vertex_buffer(<span class="number">0</span>, <span class="keyword">self</span>.vertex_buffer.slice(..));</span><br><span class="line">render_pass.draw(<span class="number">0</span>..<span class="number">3</span>, <span class="number">0</span>..<span class="number">1</span>);</span><br></pre></td></tr></table></figure>

<p>set_vertex_buffer takes two parameters. The first is what buffer slot to use for this vertex buffer. You can have multiple vertex buffers set at a time.</p>
<p>set_vertex_buffer采用两个参数。第一个是用于此顶点缓冲区的缓冲槽。一次可以设置多个顶点缓冲区。</p>
<p>The second parameter is the slice of the buffer to use. You can store as many objects in a buffer as your hardware allows, so slice allows us to specify which portion of the buffer to use. We use .. to specify the entire buffer.</p>
<p>第二个参数是要使用的缓冲区的切片。在硬件允许的情况下，可以在缓冲区中存储任意多的对象，因此slice允许我们指定要使用的缓冲区部分。我们用..指定整个缓冲区。</p>
<p>Before we continue, we should change the render_pass.draw() call to use the number of vertices specified by VERTICES. Add a num_vertices to State, and set it to be equal to VERTICES.len().</p>
<p>在继续之前，我们应该更改render_pass.draw()调用以使用顶点指定的顶点数。将num_vertices添加到状态，并将其设置为等于VERTICES.len()。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main.rs</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">State</span></span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    num_vertices: <span class="built_in">u32</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> State &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">new</span></span>(...) -&gt; <span class="keyword">Self</span> &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="keyword">let</span> num_vertices = VERTICES.len() <span class="keyword">as</span> <span class="built_in">u32</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">Self</span> &#123;</span><br><span class="line">            surface,</span><br><span class="line">            device,</span><br><span class="line">            queue,</span><br><span class="line">            sc_desc,</span><br><span class="line">            swap_chain,</span><br><span class="line">            render_pipeline,</span><br><span class="line">            vertex_buffer,</span><br><span class="line">            num_vertices,</span><br><span class="line">            size,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Then use it in the draw call.</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// render</span></span><br><span class="line">render_pass.draw(<span class="number">0</span>..<span class="keyword">self</span>.num_vertices, <span class="number">0</span>..<span class="number">1</span>);</span><br></pre></td></tr></table></figure>

<p>Before our changes will have any effect, we need to update our vertex shader to get its data from the vertex buffer. We’ll also have it include the vertex color as well.</p>
<p>在更改产生任何效果之前，我们需要更新顶点着色器以从顶点缓冲区获取其数据。我们还将让它包括顶点颜色。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Vertex shader</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">VertexInput</span></span> &#123;</span><br><span class="line">    [[location(<span class="number">0</span>)]] position: vec3&lt;<span class="built_in">f32</span>&gt;;</span><br><span class="line">    [[location(<span class="number">1</span>)]] color: vec3&lt;<span class="built_in">f32</span>&gt;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">VertexOutput</span></span> &#123;</span><br><span class="line">    [[builtin(position)]] clip_position: vec4&lt;<span class="built_in">f32</span>&gt;;</span><br><span class="line">    [[location(<span class="number">0</span>)]] color: vec3&lt;<span class="built_in">f32</span>&gt;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">[[stage(vertex)]]</span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>(</span><br><span class="line">    model: VertexInput,</span><br><span class="line">) -&gt; VertexOutput &#123;</span><br><span class="line">    var out: VertexOutput;</span><br><span class="line">    out.color = model.color;</span><br><span class="line">    out.clip_position = vec4&lt;<span class="built_in">f32</span>&gt;(model.position, <span class="number">1.0</span>);</span><br><span class="line">    <span class="keyword">return</span> out;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Fragment shader</span></span><br><span class="line"></span><br><span class="line">[[stage(fragment)]]</span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>(<span class="keyword">in</span>: VertexOutput) -&gt; [[location(<span class="number">0</span>)]] vec4&lt;<span class="built_in">f32</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> vec4&lt;<span class="built_in">f32</span>&gt;(<span class="keyword">in</span>.color, <span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>If you’ve done things correctly, you should see a triangle that looks something like this.</p>
<p>如果你做的正确，你应该看到一个三角形，看起来像这样。</p>
<p><img src="https://sotrh.github.io/learn-wgpu/assets/img/triangle.11560f32.png" alt="三角形"></p>
<h1 id="The-index-buffer"><a href="#The-index-buffer" class="headerlink" title="The index buffer"></a>The index buffer</h1><p>We technically don’t need an index buffer, but they still are plenty useful. An index buffer comes into play when we start using models with a lot of triangles. Consider this pentagon.</p>
<p>从技术上讲，我们不需要索引缓冲区，但它们仍然非常有用。当我们开始使用带有大量三角形的模型时，索引缓冲区就开始发挥作用。考虑一下这个五角大厦。</p>
<p><img src="https://sotrh.github.io/learn-wgpu/assets/img/pentagon.2c2be93b.png" alt="五角形"></p>
<p>It has a total of 5 vertices, and 3 triangles. Now if we wanted to display something like this using just vertices we would need something like the following.</p>
<p>它总共有5个顶点和3个三角形。现在，如果我们只想用顶点来显示这样的东西，我们需要下面这样的东西。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> VERTICES: &amp;[Vertex] = &amp;[</span><br><span class="line">    Vertex &#123; position: [-<span class="number">0.0868241</span>, <span class="number">0.49240386</span>, <span class="number">0.0</span>], color: [<span class="number">0.5</span>, <span class="number">0.0</span>, <span class="number">0.5</span>] &#125;, <span class="comment">// A</span></span><br><span class="line">    Vertex &#123; position: [-<span class="number">0.49513406</span>, <span class="number">0.06958647</span>, <span class="number">0.0</span>], color: [<span class="number">0.5</span>, <span class="number">0.0</span>, <span class="number">0.5</span>] &#125;, <span class="comment">// B</span></span><br><span class="line">    Vertex &#123; position: [<span class="number">0.44147372</span>, <span class="number">0.2347359</span>, <span class="number">0.0</span>], color: [<span class="number">0.5</span>, <span class="number">0.0</span>, <span class="number">0.5</span>] &#125;, <span class="comment">// E</span></span><br><span class="line"></span><br><span class="line">    Vertex &#123; position: [-<span class="number">0.49513406</span>, <span class="number">0.06958647</span>, <span class="number">0.0</span>], color: [<span class="number">0.5</span>, <span class="number">0.0</span>, <span class="number">0.5</span>] &#125;, <span class="comment">// B</span></span><br><span class="line">    Vertex &#123; position: [-<span class="number">0.21918549</span>, -<span class="number">0.44939706</span>, <span class="number">0.0</span>], color: [<span class="number">0.5</span>, <span class="number">0.0</span>, <span class="number">0.5</span>] &#125;, <span class="comment">// C</span></span><br><span class="line">    Vertex &#123; position: [<span class="number">0.44147372</span>, <span class="number">0.2347359</span>, <span class="number">0.0</span>], color: [<span class="number">0.5</span>, <span class="number">0.0</span>, <span class="number">0.5</span>] &#125;, <span class="comment">// E</span></span><br><span class="line"></span><br><span class="line">    Vertex &#123; position: [-<span class="number">0.21918549</span>, -<span class="number">0.44939706</span>, <span class="number">0.0</span>], color: [<span class="number">0.5</span>, <span class="number">0.0</span>, <span class="number">0.5</span>] &#125;, <span class="comment">// C</span></span><br><span class="line">    Vertex &#123; position: [<span class="number">0.35966998</span>, -<span class="number">0.3473291</span>, <span class="number">0.0</span>], color: [<span class="number">0.5</span>, <span class="number">0.0</span>, <span class="number">0.5</span>] &#125;, <span class="comment">// D</span></span><br><span class="line">    Vertex &#123; position: [<span class="number">0.44147372</span>, <span class="number">0.2347359</span>, <span class="number">0.0</span>], color: [<span class="number">0.5</span>, <span class="number">0.0</span>, <span class="number">0.5</span>] &#125;, <span class="comment">// E</span></span><br><span class="line">];</span><br></pre></td></tr></table></figure>

<p>You’ll note though that some of the vertices are used more than once. C, and B get used twice, and E is repeated 3 times. Assuming that each float is 4 bytes, then that means of the 216 bytes we use for VERTICES, 96 of them are duplicate data. Wouldn’t it be nice if we could list these vertices once? Well we can! That’s were an index buffer comes into play.</p>
<p>但您会注意到，有些顶点被多次使用。C、 B使用两次，E重复三次。假设每个浮点是4个字节，那么这意味着我们用于顶点的216个字节中，有96个是重复数据。如果我们能列出这些顶点一次，不是很好吗？我们可以！这就是索引缓冲区发挥作用的原因。</p>
<p>Basically we store all the unique vertices in VERTICES and we create another buffer that stores indices to elements in VERTICES to create the triangles. Here’s an example of that with our pentagon.</p>
<p>基本上，我们将所有唯一的顶点存储在VERTICES中，并创建另一个缓冲区来存储顶点中元素的索引以创建三角形。这是我们五角大楼的一个例子。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main.rs</span></span><br><span class="line"><span class="keyword">const</span> VERTICES: &amp;[Vertex] = &amp;[</span><br><span class="line">    Vertex &#123; position: [-<span class="number">0.0868241</span>, <span class="number">0.49240386</span>, <span class="number">0.0</span>], color: [<span class="number">0.5</span>, <span class="number">0.0</span>, <span class="number">0.5</span>] &#125;, <span class="comment">// A</span></span><br><span class="line">    Vertex &#123; position: [-<span class="number">0.49513406</span>, <span class="number">0.06958647</span>, <span class="number">0.0</span>], color: [<span class="number">0.5</span>, <span class="number">0.0</span>, <span class="number">0.5</span>] &#125;, <span class="comment">// B</span></span><br><span class="line">    Vertex &#123; position: [-<span class="number">0.21918549</span>, -<span class="number">0.44939706</span>, <span class="number">0.0</span>], color: [<span class="number">0.5</span>, <span class="number">0.0</span>, <span class="number">0.5</span>] &#125;, <span class="comment">// C</span></span><br><span class="line">    Vertex &#123; position: [<span class="number">0.35966998</span>, -<span class="number">0.3473291</span>, <span class="number">0.0</span>], color: [<span class="number">0.5</span>, <span class="number">0.0</span>, <span class="number">0.5</span>] &#125;, <span class="comment">// D</span></span><br><span class="line">    Vertex &#123; position: [<span class="number">0.44147372</span>, <span class="number">0.2347359</span>, <span class="number">0.0</span>], color: [<span class="number">0.5</span>, <span class="number">0.0</span>, <span class="number">0.5</span>] &#125;, <span class="comment">// E</span></span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> INDICES: &amp;[<span class="built_in">u16</span>] = &amp;[</span><br><span class="line">    <span class="number">0</span>, <span class="number">1</span>, <span class="number">4</span>,</span><br><span class="line">    <span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>,</span><br><span class="line">    <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>,</span><br><span class="line">    <span class="comment">/* padding */</span> <span class="number">0</span>,</span><br><span class="line">];</span><br></pre></td></tr></table></figure>

<p>Now with this setup our VERTICES take up about 120 bytes and INDICES is just 18 bytes given that u16 is 2 bytes wide. We add 2 bytes padding as wgpu requires buffers to be aligned to 4 bytes. All together our pentagon is 134 bytes in total. That means we saved 82 bytes! It may not seem like much, but when dealing with tri counts in the hundreds of thousands, indexing saves a lot of memory.</p>
<p>现在，在这个设置中，我们的顶点占用了大约120个字节，而索引仅为18个字节，因为u16的宽度为2个字节。我们添加了2个字节的填充，因为wgpu要求缓冲区与4个字节对齐。我们的五角大楼总共有134字节。这意味着我们节省了82字节！它可能看起来不太多，但在处理数十万的三重计数时，索引可以节省大量内存。</p>
<p>There’s a couple of things we need to change in order to use indexing. The first is we need to create a buffer to store the indices. In State’s new() method create the index_buffer after you create the vertex_buffer. Also change num_vertices to num_indices and set it equal to INDICES.len().</p>
<p>为了使用索引，我们需要改变一些事情。首先，我们需要创建一个缓冲区来存储索引。在State的new()方法中，在创建顶点缓冲区之后创建索引缓冲区。还可以将num_vertices更改为num_indices，并将其设置为INDICES.len()。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> vertex_buffer = device.create_buffer_init(</span><br><span class="line">    &amp;wgpu::util::BufferInitDescriptor &#123;</span><br><span class="line">        label: <span class="literal">Some</span>(<span class="string">&quot;Vertex Buffer&quot;</span>),</span><br><span class="line">        contents: bytemuck::cast_slice(VERTICES),</span><br><span class="line">        usage: wgpu::BufferUsage::VERTEX,</span><br><span class="line">    &#125;</span><br><span class="line">);</span><br><span class="line"><span class="comment">// NEW!</span></span><br><span class="line"><span class="keyword">let</span> index_buffer = device.create_buffer_init(</span><br><span class="line">    &amp;wgpu::util::BufferInitDescriptor &#123;</span><br><span class="line">        label: <span class="literal">Some</span>(<span class="string">&quot;Index Buffer&quot;</span>),</span><br><span class="line">        contents: bytemuck::cast_slice(INDICES),</span><br><span class="line">        usage: wgpu::BufferUsage::INDEX,</span><br><span class="line">    &#125;</span><br><span class="line">);</span><br><span class="line"><span class="keyword">let</span> num_indices = INDICES.len() <span class="keyword">as</span> <span class="built_in">u32</span>;</span><br></pre></td></tr></table></figure>

<p>We don’t need to implement Pod and Zeroable for our indices, because bytemuck has already implemented them for basic types such as u16. That means we can just add index_buffer and num_indices to the State struct.</p>
<p>我们不需要为索引实现Pod和Zeroable，因为bytemuck已经为u16等基本类型实现了它们。这意味着我们可以将index_buffer和num_indices添加到State结构中。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">State</span></span> &#123;</span><br><span class="line">    surface: wgpu::Surface,</span><br><span class="line">    device: wgpu::Device,</span><br><span class="line">    queue: wgpu::Queue,</span><br><span class="line">    sc_desc: wgpu::SwapChainDescriptor,</span><br><span class="line">    swap_chain: wgpu::SwapChain,</span><br><span class="line">    size: winit::dpi::PhysicalSize&lt;<span class="built_in">u32</span>&gt;,</span><br><span class="line">    render_pipeline: wgpu::RenderPipeline,</span><br><span class="line">    vertex_buffer: wgpu::Buffer,</span><br><span class="line">    <span class="comment">// NEW!</span></span><br><span class="line">    index_buffer: wgpu::Buffer, </span><br><span class="line">    num_indices: <span class="built_in">u32</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>And then populate these fields in the constructor:</p>
<p>然后在构造函数中填充这些字段：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Self</span> &#123;</span><br><span class="line">    surface,</span><br><span class="line">    device,</span><br><span class="line">    queue,</span><br><span class="line">    sc_desc,</span><br><span class="line">    swap_chain,</span><br><span class="line">    size,</span><br><span class="line">    render_pipeline,</span><br><span class="line">    vertex_buffer,</span><br><span class="line">    <span class="comment">// NEW!</span></span><br><span class="line">    index_buffer,</span><br><span class="line">    num_indices,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>All we have to do now is update the render() method to use the index_buffer.</p>
<p>我们现在要做的就是更新render()方法以使用index_buffer。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// render()</span></span><br><span class="line">render_pass.set_pipeline(&amp;<span class="keyword">self</span>.render_pipeline);</span><br><span class="line">render_pass.set_vertex_buffer(<span class="number">0</span>, <span class="keyword">self</span>.vertex_buffer.slice(..));</span><br><span class="line">render_pass.set_index_buffer(<span class="keyword">self</span>.index_buffer.slice(..), wgpu::IndexFormat::Uint16); <span class="comment">// 1.</span></span><br><span class="line">render_pass.draw_indexed(<span class="number">0</span>..<span class="keyword">self</span>.num_indices, <span class="number">0</span>, <span class="number">0</span>..<span class="number">1</span>); <span class="comment">// 2.</span></span><br></pre></td></tr></table></figure>

<p>A couple things to note:</p>
<ol>
<li>The method name is set_index_buffer not set_index_buffers. You can only have one index buffer set at a time.</li>
<li>When using an index buffer, you need to use draw_indexed. The draw method ignores the index buffer. Also make sure you use the number of indices (num_indices), not vertices as your model will either draw wrong, or the method will panic because there are not enough indices.</li>
</ol>
<p>有几件事需要注意：</p>
<ol>
<li>方法名称是set_index_buffer而不是set_index_buffers。一次只能设置一个索引缓冲区。</li>
<li>使用索引缓冲区时，需要使用draw_indexed。draw方法忽略索引缓冲区。还要确保使用的是索引的数量（num_index），而不是顶点，否则您的模型可能会绘制错误，或者该方法会因为索引不足而死机。</li>
</ol>
<p>With all that you should have a garishly magenta pentagon in your window.</p>
<p>所有这些，你应该有一个华丽的洋红色五角大楼在你的窗口。</p>
<p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAyIAAAJzCAYAAADz6Ke4AAAABHNCSVQICAgIfAhkiAAAABl0RVh0U29mdHdhcmUAZ25vbWUtc2NyZWVuc2hvdO8Dvz4AABxWSURBVHic7d1bsF31fdjx397nJkBIQkJHIMkgyR7AiICsCNKY4DQ2DlM3GafutONO7ekDY0/97LzVL50y09u00850PLVbj6e1k/SSJm2atDGBMWFC4hqZYIK5CoRs3c45SEdXdDln79UHIaHLkXQue//2unw+T9LR2Uv/EWit9d2/9d9qrV+/viiKZfGLX/nH8ZmbXojdh2+MtWvXxujoaAAAACzFzMxMTE9Px4svvhg7d+6MTqcTrVYrhouiiBUrRuK+2Tfjzvs/E1945JEYGxsb9HoBAICaOH78eOzcuTOee+65+O53vxvHjh2L4aGhofj85z8fX/3qVyMiYnp6Orrd7oCXCgAA1MXQ0FDcf//9sWPHjoiI+MY3vhHDO3bsiE996lPRarXi2LFjA14iAABQN51OJzqdTpw5cyYeeuih2LlzZwzfe++98cADD8SJEyeiKIpBrxEAAKixu+66K7Zt2xbD4+PjsWLFCtMQAACg74aHh2P16tXRHh0djU6nM+j1AAAADTEyMhLDEeee2fJYFgAAkEWIAAAA6doR4dEsgCrq7o8/+0//Nv7Nf3wqdp/t42v6vaYrdOKdJ78e//Jf/Kv47y+9F94mAxiciYmJ+PGPf3zJP+9RFEW89NJLceDAgSUd20QEoKqKiGJmNmbPdiOKbhRFa1GvKU7vi5f/8mAs37o9Nq+YxzF6vaY5jI61I6IVo2Nt1yeAefje974XERGPPfZYz445PT19IULa7XZs3bo1iqKIl19+OQ4cOBAHDx6MsbGxuOWWWxZ1/OGIiG6360QPUDXtTfFr/+ifx98uZuPY5LvxXnce5/ErXtONE2/8IJ7+88PxsTu3xaab2/lrukIRrdb7AVMUEUVhKgIwT728px8fH48tW7bErl27Yt++fdFqtaLT6VyYhHz4wx+O8fHxOHt2cSPwCxMRAAbtZLz0u/8hntxzU/z85x+PX9nQinf/4jvxn5+bjGL5tvg7X3o07mhPx/O//e3404m18Utf+Hgc+Xf/M16e2RKf+crfinuH344//ve/H29sfDQ+u3FvPPv8rnj3zEis3vIL8elf/flYPxYRs6/E73zt999/zWfj9rf/JP7o2XdittuNH/7Wv44ftm6In/vcP4zHNg/lrSkizk78ZfzJkz+IXYdm46aND8S2NWPRipMX/mSKU/vihWeejRfemoiTnbFYtfGe+IVf/qX46K1nF7a+f/CF+Gtrljj1AWiImZmZeOihh2J4eDhee+212Lt374Vfu+eee2L79u1x6NChRR/fo1kApbE87rp3Qzz9zt6YnDga3fWjMTk5HTEyEkOnpmLqaDc+tGwiDh4qor36nvjo+LJ4oR0RrbEYaxVRxFiMtSNm3v5+/N6em2P9nR+K1T/bHVOv/2k8ecuG+OLD66L9/vecf81sMRzLRiOK02Nx+70fi00rl8XGW1sXXRMS1jS7N577w+/Ha9NFjNyyPlaeeiWee/G9KKIdEUUU3UPxoz/4vXhm79lYtubO2HTDkfjpOz+K//Pue9H+wt9c2PrWRhQd1zugHp566qkr7uGffPLJCz/+9Kc/vaTjF0URU1NTsW3btpiYmIjp6emIiFi9enVs27YtpqamlnR8IQJQGp24YcPmWN3+aRzcdzBO3bcs9u/vxm3bH4zRnS/EgcnTMbNsf+ybibhxyx2xanbmg5cWxYXzeNEdjfv+/m/GF39uNN574dvxxH95JY4cOhxnivFYdvG5vmjH+gf/Rmx/86V45/hN8ZFHfi0+c2crTh89HMfPFmlrGj2wK3Yd7UZrzcPx+Fc/Fx8ZPRY/+OY/jd99oxsRRXQOvBJ/te9MtG/96/Hl3/z1uGPodLzyO/8svv3Cm/Hia0fi7o8sYH2dInQIkOGpp5665q8/+uijfV9DL+7vi6KIZ5999kKEREQcPnw4nnnmmdi6desHj9IugkezAEqke8sdsfnGiOf3H4yJqWWx//QNsfmue2P0zefjpYmpeHdsX7wXI3HvpvHoxr65D9LeEJtWT8f+A91oja2Km1oRx85ttbhMEWeOTceZ4tyPZ08ciqmpKy8o/V7TzKkTcbLbitFNm2Pl4X2xrzsUt25aG+03JiIiYub4kTjabcXIxvWxbHJf7C/asfKO9TH0ozfi0JHpmF3I+rzpBtTIl770pQs//uY3vxkREV/+8pcvfO3tt99e0vGLooif/OQncfDgwYiI2Lp1a3S73Xj11Vcv+dpiY8REBKBEitlbY9OmkXj+1ak4uGc0Drc2xC+uXhVjG4fizyf3x56RQ1G074zNtxWX3lRfNH2I9ki0u50oWhHd2fPf07r0ey685pLffY5Y6f+aon3uAtbqno1TnSLaMRNnO+cvakXE0Psb6Ltn43S3iKHoxOmZcx8j2WoPL359AH10cRDM5a233lry7zHXMXpx3POOHj0ak5OTERFx9913x3333RcR59rhjTfeiMnJydi4cWOsXLlyUcf3qVkAZVK0Yt3mjdH+yUS8s2csYs0DMT4UMbL+tmjt3h27h7vRWrclNgx3o5i96GWXRUXRKaJox0WfNlVc+T3vfxpVq92KKDoxM9ONopjjU7P6vKaRlbfE8lYRx362O/afXR8bhk/Gvp9ORffcQWJ07bpY0341pvbuiQNnN8aGkdOx950D0Wm1Y3zd6mh1Y/7r++Bj8AH6ateuXQP5fXv9qVmf/OQnY8+ePZfsCdm+fXt0u93YtGlTjI6OxunTpxd1/AsTkaU83wVAr3RjdP3mWNvaHQcPnIqxbbfFzUU3Yvz2uPHk83GwiFi5dWMsLyJmr3+weRiLVatvjFZxPH78f/9rTKxox+qPfS5+5cMjaWtqjW+N+9f8v3j20M74g9/aG2vHTsbUodmIeP+6tOZj8chdP4z/8foHvz4xeSLi5m3x8Y/eFNGZTf4zAyif8xOYXgbQ6dOnY/ny5bFjx46YmJi48PXJycl48MEH4+TJk3HixIlFH/9CiAwNDV3vewFI0Fn+odiyIuLgkVas37Amut0iYtXtcXu7iNc7N8SWO26J2W7nyunGHD+//ve0YsPDvxEfP/C/4vmfvRsTcVtsXnHlPyLYzzV1Z9fEL3/xc3Hiv/1x/NXE0Ti78VPx+GOT8Z3v/CiiiOieGYqP/r2vxN998n/H91/cHQdOjsaaux6JX/3so3Fn53CcKBawviX+twEoqzfffLMvxz1+/HgcP378iq+f3yOyFK2vf/3rxSc+8YkYGRm5/ncD0H+tG2N888ZYNVzEqcl34mdHZiKGV8bGzevixlYnju/fHQdOdCNaN8W6LRtiZftEHHxrfxwrLvt5N6J1w3hs+tCqGH5vMnbvPRKzl7+mG9EauTnGb18bN48NRXTOxpGDP4133yvy1hQR7WWrYt26NbF8NGLm5HRMnhiN22+7OU5PvB37jnYihpbFqltvjVXLb4iRdjdmTh2Pw1PvxrEz3YWtD4BSePrpp8+FyMMPPxzLli0b9HoAAIAGePrpp889mjU2NmazOgAAkGY4ore76wEAAK5njs9pBAAA6C8TEQAAIN1wRMQ/+e3vD3odAABAQzyyvuXRLAAAIJ8QAQAA0gkRAAAgnRABAADSCREAACCdEAEAANIJEQAAIJ0QAQAA0gkRAAAgnRABAADSCREAACCdEAEAANIJEQAAIJ0QAQAA0gkRAAAgnRABAADSCREAACCdEAEAANIJEQAAIJ0QAQAA0gkRAAAgnRABAADSCREAACCdEAEAANIJEQAAIJ0QAQAA0gkRAAAgnRABAADSCREAACCdEAEAANIJEQAAIJ0QAQAA0gkRAAAgnRABAADSCREAACCdEAEAANIJEQAAIJ0QAQAA0gkRAAAgnRABAADSCREAACCdEAEAANIJEQAAIJ0QAQAA0gkRAAAgnRABAADSCREAACCdEAEAANIJEQAAIJ0QAQAA0gkRAAAgnRABAADSCREAACCdEAEAANIJEQAAIJ0QAQAA0gkRAAAgnRABAADSCREAACCdEAEAANIJEQAAIJ0QAQAA0gkRAAAgnRABAADSCREAACCdEAEAANIJEQAAIJ0QAQAA0gkRAAAgnRABAADSCREAACCdEAEAANIJEQAAIJ0QAQAA0gkRAAAgnRABAADSCREAACCdEAEAANIJEQAAIJ0QAQAA0gkRAAAgnRABAADSCREAACCdEAEAANIJEQAAIJ0QAQAA0gkRAAAgnRABAADSCREAACCdEAEAANIJEQAAIJ0QAQAA0gkRAAAgnRABAADSCREAACCdEAEAANIJEQAAIJ0QAQAA0gkRAAAgnRABAADSCREAACCdEAEAANIJEQAAIJ0QAQAA0gkRAAAgnRABAADSCREAACCdEAEAANIJEQAAIJ0QAQAA0gkRAAAgnRABAADSCREAACCdEAEAANIJEQAAIJ0QAQAA0gkRAAAgnRABAADSCREAACCdEAEAANIJEQAAIJ0QAQAA0gkRAAAgnRABAADSCREAACCdEAEAANIJEQAAIJ0QAQAA0gkRAAAgnRABAADSCREAACCdEAEAANIJEQAAIJ0QAQAA0gkRAAAgnRABAADSCREAACCdEAEAANIJEQAAIJ0QAQAA0gkRAAAgnRABAADSCREAACCdEAEAANIJEQAAIJ0QAQAA0gkRAAAgnRABAADSCREAACCdEAEAANIJEQAAIJ0QAaiYx5+4e9BLAIAlGx70AgCYv/MRcnGMfOtrrw9qOQCwaEIEoAKuNQU5/2uCBIAqESIAJTffR7FMSQCoEiECUGKL3Q8iSgAoOyECUFK92pQuSgAoIyECUDL9/FQs+0kAKAshAlAiWR/Na0oCwKAJEYCSGNS/DyJKABgEIQIwYGX6Bwo9ugVAFiECMEBlipCLmZIA0G9CBGBAyhohlxMlAPSDEAEYgKpEyOVECQC9IkQAElU1QOZiPwkASyFEAJLUKUIuZkoCwGIIEYAEdY2Qy4kSAOZLiAD0UVMCZC6iBIBraQ96AQB11eQIudzjT9ztzwOAS5iIAPSBm+65mZIAcJ4QAegxETI/ogSg2YQIQI8IkMUTJQDNY48IQA+IkN6xnwSgGUxEAJbITXN/mJIA1JsQAVgkAZJHlADUj0ezABZBhAyOR7cA6sFEBGCB3ASXgykJQLUJEYAFECHlJEoAqkeIAMyDAKkOUQJQDfaIAFyHCKku+0kAystEBOAa3MTWgykJQPkIEYA5CJD6EiUA5SBEAC4jQppDlAAMjj0iABcRIc1lPwlALhMRgBAgfMCUBCCHEAEaT4RwNaIEoH+ECNBoIoT5EiUAvWWPCNBYIoTFsp8EYOlMRIDGcQNJr5iSACyeEAEaRYTQL6IEYGE8mgU0hgghi0e3AK7PRASoPTeEDIopCcDVCRGg1kQIZSFKAC4lRIDaEiGUlSgBsEcEqCkRQlXYTwI0lYkIUCtu6KgqUxKgaYQIUBsihLoQJUATCBGgFkQIdSVKgLoSIkClCRCa5Pz/74IEqAMhAlSWCKGpTEmAOhAiQCWJEDhHlABVJUSAyhEhMDdRAlSJEAEqQ4DA/NlPApSdEAEqQYTA4piSAGUlRIDSEyHQG6IEKBMhApSWAIH+ESXAoLUHvQCAuYgQyPP4E3f7OwekMxEBSscNEQyGKQmQSYgApSJCoBxECdBvQgQoBQEC5eWjgIF+ECLAwIkQqAZTEqCXhAgwUCIEqkmUAEslRICBECBQH6IEWAwf3wukEyFQXz4KGJgvExEglRsUaAZTEuB6hAiQRoRAM4kSYC5CBOg7AQKcJ0qA8+wRAfpKhABXYz8JNJuJCNA3bjCA+TAlgWYSIkDPCRBgsUQJNIcQAXpKhAC9Ikqg3uwRAXpGhAD9Yj8J1I+JCNATbhCADKYkUB9CBFgSAQIMiiiBavNoFrBoIgQoC49uQfWYiACL4oIPlJEpCVSHEAEWRIAAVSFKoNyECDBvIgSoKlEC5WOPCDAvIgSoC/tJoByECHBdLtgAQK95NAu4KgECAPSLiQgwJxECAPSTEAGuIEIAgH7zaBZwgQABALKYiAARIUKAZvERvjB4QgQQIQBAOiECDSdCAIBBsEcEGkqAAACDZCICDSRCAIBBEyLQMCIEACgDj2ZBQwgQgHN8YhaUg4kINIAIAQDKRohAzYkQAKCMhAjUmAgBAMrKHhGoIQECAJSdiQjUjAgBuDob1aE8hAjUiAgBAKrCo1lQAwIEAKgaExGoOBECAFSREIEKEyEAQFUJEagoEQKwMDaqQ7nYIwIVI0AAgDowEYEKESEAQF0IEagIEQIA1IlHs6DkBAgAUEcmIlBiIgQAqCshAiUlQgB6xydmQfkIESghEQIA1J09IlAiAgQAaAoTESgJEQIANIkQgRIQIQBA03g0CwZIgAD0n43qUE4mIjAgIgQAaDIhAgMgQgCApvNoFiQSIAAA55iIQBIRAgDwASECCUQIwGDYqA7lJUSgz0QIAMCV7BGBPhEgAABXZyICfSBCAACuTYhAj4kQAIDr82gW9IgAAQCYPxMR6AERAlA+PjELyk2IwBKJEACAhRMisAQiBABgcewRgUUQIAAAS2MiAgskQgAAlk6IwAKIEIBqsFEdyk+IwDyJEACA3hEiME/eXQMA6B0hAgsgRgAAekOIAAAA6YQILJCpCEC5OU9DNQgRWAQXOQCApREiAABAOiECi2QqAgCweEIElkCMAAAsjhCBJRIjAAALJ0QAgNrw5hBUhxCBHnDhAwBYGCECPSJGAADmT4gAAADphAj0kKkIAMD8CBHoMTECMBjOv1AtQgT6wMUQAODahAgAAJBOiECfmIoAAFydEIE+EiMAAHMTIgBA5XnjB6pHiECfuTgCAFxJiEACMQIAcCkhAknECADAB4QIAACQTohAIlMRAIBzhAgkEyMAveW8CtUkRAAAgHRCBAbAu3cAQNMJERgQMQIANJkQAQAA0gkRGCBTEYClcR6F6hIiMGAuogBAEwkRKAExAgA0jRABAADSCREoCVMRAKBJhAiUiBgBmD/nTKg2IQIAAKQTIlAy3uEDAJpAiEAJiREAoO6ECJSUGAEA6kyIAAAA6YQIlJipCMDcnB+h+oQIlJyLLQBQR0IEAABIJ0SgAkxFAIC6ESJQEWIEAKgTIQIVIkYAnAuhLoQIAACQTohAxXgnEACoAyECFSRGAICqEyIAAEA6IQIVZSoCNJFzH9SHEIEKc0EGAKpKiAAAAOmECFScqQgAUEVCBGpAjAAAVSNEoCbECABQJUIEAKgEb7hAvQgRqBEXaQCgKoQI1IwYAQCqQIgAAADphAjUkKkIAFB2QgRqSowAdeKcBvUjRKDGXLgBgLISIgAAQDohAjVnKgIAlJEQgQYQIwBA2QgRAKDUvJkC9SREoCFcyAGAMhEi0CBiBAAoCyECDSNGAIAyECIAAEA6IQINZCoCAAyaEIGGEiNAFThXQX0JEQAAIJ0QgQbzTiMAMChCBBpOjAAAgyBEADECAKQTIgBAKXmTBOpNiAAR4YIPAOQSIsAFYgQAyCJEAACAdEIEuISpCACQQYgAVxAjwKA5D0H9CREAACCdEAHm5N1IAKCfhAhwVWIEAOgXIQJckxgBAPpBiAAAAOmECHBdpiJAJuccaAYhAsyLGwMAoJeECAAAkE6IAPNmKgIA9IoQARZEjAAAvSBEgAUTI0C/OL9AcwgRAAAgnRABFsW7lgDAUggRYNHECACwWEIEAABIJ0SAJTEVAXrF+QSaRYgAS+bmAQBYKCEC9IQYAQAWQogAAADphAjQM6YiAMB8CRGgp8QIADAfQgQAGDhvYkDzCBGg59xQAADXI0SAvhAjAMC1CBEAACCdEAH6xlQEALgaIQL0lRgBrsd5AppJiAB95yYDALicEAEAANIJESCFqQgAcDEhAqQRIwDAeUIEABgYb1BAcwkRIJWbDgAgQogAAyBGAAAhAgyEGAGAZhMiAABAOiECDIypCAA0lxABBkqMQHP5+w/NJkQAAIB0QgQYOO+KAkDzCBGgFMQINMe3vva6v/NADA96AQDnfetrr8fjT9w96GUASyQygPkQIgDAgggNoBeECFAqpiJQDmID6DchApSOGIH+ExrAoAkRAKgpsQGUmRABSslUBK5PaABVJkSA0hIjIDaA+hIiQKmJEepOaABNJUQAoM/EBsCVhAhQeqYilJ3QAFg4IQJUghhhkIQGQO8JEQAIsQGQTYgAlWEqwlIIDYByESJApYgRrkVsAFSHEAGgMoQGQH0IEaByTEXqTWwANIMQASpJjFSX0AAgQogAFSZGykloADAfQgSABRMbACyVEAEqzVSkP4QGAP0mRIDKEyOLIzYAGCQhAlBTQgOAMhMiQC00dSoiNgCoKiEC1EYdY0RoAFBXQgSolSrGiNgAoImECECfCQ0AuJIQAWoneyoiNABg4YQIUEu9jhGxAQC9JUQAQmgAQDYhAtTW5VMRsQEA5SFEgFoTHwBQTu1BLwAAAGgeIQIAAKQTIgAAQDohAgAApBMiAABAOiECAACkEyIAAEA6IQIAAKQTIgAAQDohAgAApBMiAABAOiECAACkEyIAAEA6IQIAAKQTIgAAQDohAgAApBMiAABAOiECAACkEyIAAEA6IQIAAKQTIgAAQDohAgAApBMiAABAOiECAACkEyIAAEA6IQIAAKQTIgAAQDohAgAApBMiAABAOiECAACkEyIAAEA6IQIAAKQTIgAAQDohAgAApBMiAABAOiECAACkEyIAAEA6IQIAAKQTIgAAQDohAgAApBMiAABAOiECAACkEyIAAEA6IQIAAKQTIgAAQDohAgAApBMiAABAOiECAACkEyIAAEA6IQIAAKQTIgAAQDohAgAApBMiAABAOiECAACkEyIAAEA6IQIAAKQTIgAAQDohAgAApBMiAABAOiECAACkEyIAAEA6IQIAAKQTIgAAQDohAgAApBMiAABAOiECAACkEyIAAEA6IQIAAKQTIgAAQDohAgAApBMiAABAOiECAACkEyIAAEA6IQIAAKQTIgAAQDohAgAApBMiAABAOiECAACkEyIAAEA6IQIAAKQTIgAAQDohAgAApBMiAABAOiECAACkEyIAAEA6IQIAAKQTIgAAQDohAgAApBMiAABAOiECAACkEyIAAEA6IQIAAKQTIgAAQDohAgAApBMiAABAOiECAACkEyIAAEA6IQIAAKQTIgAAQDohAgAApBMiAABAOiECAACkEyIAAEA6IQIAAKQTIgAAQDohAgAApBMiAABAOiECAACkEyIAAEA6IQIAAKQTIgAAQDohAgAApBMiAABAOiECAACkEyIAAEA6IQIAAKQTIgAAQDohAgAApBMiAABAOiECAACkEyIAAEA6IQIAAKQTIgAAQDohAgAApBMiAABAOiECAACkEyIAAEA6IQIAAKQTIgAAQDohAgAApBMiAABAOiECAACkEyIAAEA6IQIAAKQTIgAAQDohAgAApBMiAABAOiECAACkEyIAAEA6IQIAAKQTIgAAQDohAgAApBMiAABAOiECAACkEyIAAEA6IQIAAKQTIgAAQDohAgAApBMiAABAOiECAACkEyIAAEA6IQIAAKQTIgAAQDohAgAApBMiAABAOiECAACkEyIAAEA6IQIAAKQTIgAAQDohAgAApBMiAABAOiECAACkEyIAAEA6IQIAAKQbjoh4ZH1r0OsAAAAa5P8D75CpLfCP/NcAAAAASUVORK5CYII=" alt="索引五角形"></p>
<h1 id="Color-Correction"><a href="#Color-Correction" class="headerlink" title="Color Correction"></a>Color Correction</h1><p>If you use a color picker on the magenta pentagon, you’ll get a hex value of #BC00BC. If you convert this to RGB values you’ll get (188, 0, 188). Dividing these values by 255 to get them into the [0, 1] range we get roughly (0.737254902, 0, 0.737254902). This is not the same as we are using for our vertex colors which is (0.5, 0.0, 0.5). The reason for this has to do with color spaces.</p>
<p>如果在洋红五角大楼上使用颜色选择器，将得到十六进制值#BC00BC。如果您将其转换为RGB值，您将得到(188,0188)。将这些值除以255得到[0,1]范围，我们大致得到(0.737254902,0,0.737254902)。这与我们使用的顶点颜色(0.5、0.0、0.5)不同。这与颜色空间有关。</p>
<p>Most monitors use a color space know as sRGB. Our swap chain is (most likely depending on what is returned from adapter.get_swap_chain_preferred_format()) using an sRGB texture format. The sRGB format stores colors according to their relative brightness instead of their actual brightness. The reason for this is that our eyes don’t perceive light linearly. We notice more differences in darker colors than we do lighter colors.</p>
<p>大多数显示器使用的颜色空间称为sRGB。我们的swap chain是(很可能取决于适配器返回的内容。adapter.get_swap_chain_preferred_format())使用sRGB纹理格式。sRGB格式根据颜色的相对亮度而不是实际亮度存储颜色。原因是我们的眼睛不能线性感知光线。我们注意到深色的差异比浅色的多。</p>
<p>You get an approximation of the correct color using the following formula: srgb_color = (rgb_color / 255) ^ 2.2. Doing this with an RGB value of (188, 0, 188) will give us (0.511397819, 0.0, 0.511397819). A little off from our (0.5, 0.0, 0.5). While you could tweak the formula to get the desired values, you’ll likely save a lot of time by using textures instead as they are stored as sRGB by default, so they don’t suffer from the same color inaccuracies that vertex colors do. We’ll cover textures in the next lesson.</p>
<p>使用以下公式可以获得正确颜色的近似值：srgb_color=(rgb_color/255)^2.2。在RGB值为（188,0188）的情况下执行此操作将得到（0.511397819,0.0,0.511397819）。离我们的（0.5,0.0,0.5）有点远。虽然可以调整公式以获得所需的值，但使用纹理可能会节省大量时间，因为默认情况下纹理存储为sRGB，因此它们不会像顶点颜色那样出现颜色不准确的情况。我们将在下一课中介绍纹理。</p>
<h1 id="Challenge"><a href="#Challenge" class="headerlink" title="Challenge"></a>Challenge</h1><p>Create a more complex shape than the one we made (aka. more than three triangles) using a vertex buffer and an index buffer. Toggle between the two with the space key.</p>
<p>创建一个比我们制作的形状更复杂的形状（aka。三个以上的三角形）使用顶点缓冲区和索引缓冲区。使用空格键在两者之间切换。</p>
<p><a target="_blank" rel="noopener" href="https://github.com/sotrh/learn-wgpu/tree/master/code/beginner/tutorial4-buffer/">Check out the code! </a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://qianqians.github.io/2021/08/20/Wgpu%20The%20Pipeline/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="qianqians">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="qianqians'blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/08/20/Wgpu%20The%20Pipeline/" class="post-title-link" itemprop="url">Wgpu The Pipeline</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-08-20 15:17:03" itemprop="dateCreated datePublished" datetime="2021-08-20T15:17:03+08:00">2021-08-20</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-08-24 16:28:38" itemprop="dateModified" datetime="2021-08-24T16:28:38+08:00">2021-08-24</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Wgpu/" itemprop="url" rel="index"><span itemprop="name">Wgpu</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="What’s-a-pipeline"><a href="#What’s-a-pipeline" class="headerlink" title="What’s a pipeline?"></a>What’s a pipeline?</h1><p>If you’re familiar with OpenGL, you may remember using shader programs. You can think of a pipeline as a more robust version of that. A pipeline describes all the actions the gpu will perform when acting on a set of data. In this section, we will be creating a RenderPipeline specifically.</p>
<p>如果您熟悉OpenGL，可能还记得使用着色器程序。您可以将管道视为更健壮的版本。管道描述了gpu在处理一组数据时将执行的所有操作。在本节中，我们将专门创建渲染管线。</p>
<h1 id="Wait-shaders"><a href="#Wait-shaders" class="headerlink" title="Wait shaders?"></a>Wait shaders?</h1><p>Shaders are mini programs that you send to the gpu to perform operations on your data. There are 3 main types of shader: vertex, fragment, and compute. There are others such as geometry shaders, but they’re more of an advanced topic. For now we’re just going to use vertex, and fragment shaders.</p>
<p>着色器是发送到gpu以对数据执行操作的小型程序。着色器有3种主要类型：顶点、片段和计算。还有其他一些，如几何体着色器，但它们更像是一个高级主题。现在我们将使用顶点和片段着色器。</p>
<h1 id="Vertex-fragment-what-are-those"><a href="#Vertex-fragment-what-are-those" class="headerlink" title="Vertex, fragment.. what are those?"></a>Vertex, fragment.. what are those?</h1><p>A vertex is a point in 3d space (can also be 2d). These vertices are then bundled in groups of 2s to form lines and/or 3s to form triangles.</p>
<p>顶点是三维空间中的一个点（也可以是二维的）。然后将这些顶点捆绑成2个一组，形成直线或3个一组，形成三角形。</p>
<p><img src="https://sotrh.github.io/learn-wgpu/assets/img/tutorial3-pipeline-vertices.5e39e8fc.png" alt="vertices"></p>
<p>Most modern rendering uses triangles to make all shapes, from simple shapes (such as cubes), to complex ones (such as people). These triangles are stored as vertices which are the points that make up the corners of the triangles.</p>
<p>大多数现代渲染使用三角形生成所有形状，从简单形状（如立方体）到复杂形状（如人）。这些三角形存储为顶点，这些顶点是构成三角形角的点。</p>
<p>We use a vertex shader to manipulate the vertices, in order to transform the shape to look the way we want it.</p>
<p>我们使用顶点着色器来操纵顶点，以便将形状变换为我们想要的样子。</p>
<p>The vertices are then converted into fragments. Every pixel in the result image gets at least one fragment. Each fragment has a color that will be copied to its corresponding pixel. The fragment shader decides what color the fragment will be.</p>
<p>然后将顶点转换为片段。结果图像中的每个像素至少获得一个片段。每个片段都有一个将被复制到其相应像素的颜色。片段着色器决定片段的颜色。</p>
<h1 id="WGSL"><a href="#WGSL" class="headerlink" title="WGSL"></a>WGSL</h1><p>WebGPU supports two shader languages natively: SPIR-V, and WGSL. SPIR-V is actually a binary format developed by Kronos to be a compilation target for other languages such as GLSL and HLSL. It allows for easy porting of code. The only problem is that it’s not human readable as it’s a binary language. WGSL is meant to fix that. WGSL’s development focuses on getting it to easily convert into SPIR-V. WGPU even allows us to supply WGSL for our shaders.</p>
<p>WebGPU本机支持两种着色器语言：SPIR-V和WGSL。SPIR-V实际上是Kronos开发的二进制格式，用于其他语言（如GLSL和HLSL）的编译目标。它允许轻松移植代码。唯一的问题是它不是人类可读的，因为它是一种二进制语言。WGSL旨在解决这一问题。WGSL的开发重点是使其能够轻松转换为SPIR-V。WGPU同样允许我们为着色器提供WGSL。</p>
<p>If you’ve gone through this tutorial before you’ll likely notice that I’ve switched from using GLSL to using WGSL. Given that GLSL support is a secondary concern and that WGSL is the first class language of WGPU, I’ve elected to convert all the tutorials to use WGSL. Some of the showcase examples still use GLSL, but the main tutorial and all examples going forward will be using WGSL.</p>
<p>如果您之前阅读过本教程，您可能会注意到我已从使用GLSL切换到使用WGSL。考虑到GLSL支持是第二个问题，而WGSL是WGPU的第一类语言，我选择将所有教程转换为使用WGSL。一些showcase示例仍然使用GLSL，但主教程和所有后续示例将使用WGSL。</p>
<p>The WGSL spec and it’s inclusion in WGPU is still in development. If you run into trouble using it, you may want the folks at <a target="_blank" rel="noopener" href="https://app.element.io/#/room/#wgpu:matrix.org">https://app.element.io/#/room/#wgpu:matrix.org</a> to take a look at your code.</p>
<p>WGSL规范及其包含在WGPU中的内容仍在开发中。如果你在使用它时遇到麻烦，你可能想让人们在<a target="_blank" rel="noopener" href="https://app.element.io/#/room/#wgpu:matrix.org">https://app.element.io/#/room/#wgpu:matrix.org</a> 来看看你的代码。</p>
<h1 id="Writing-the-shaders"><a href="#Writing-the-shaders" class="headerlink" title="Writing the shaders"></a>Writing the shaders</h1><p>In the same folder as main.rs, create a file shader.wgsl. Write the following code in shader.wgsl.</p>
<p>在与main.rs相同的文件夹中，创建文件shader.wgsl。在shader.wgsl中编写以下代码。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Vertex shader</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">VertexOutput</span></span> &#123;</span><br><span class="line">    [[builtin(position)]] clip_position: vec4&lt;<span class="built_in">f32</span>&gt;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">[[stage(vertex)]]</span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>(</span><br><span class="line">    [[builtin(vertex_index)]] in_vertex_index: <span class="built_in">u32</span>,</span><br><span class="line">) -&gt; VertexOutput &#123;</span><br><span class="line">    var out: VertexOutput;</span><br><span class="line">    <span class="keyword">let</span> x = <span class="built_in">f32</span>(<span class="number">1</span> - <span class="built_in">i32</span>(in_vertex_index)) * <span class="number">0.5</span>;</span><br><span class="line">    <span class="keyword">let</span> y = <span class="built_in">f32</span>(<span class="built_in">i32</span>(in_vertex_index &amp; <span class="number">1</span>u) * <span class="number">2</span> - <span class="number">1</span>) * <span class="number">0.5</span>;</span><br><span class="line">    out.clip_position = vec4&lt;<span class="built_in">f32</span>&gt;(x, y, <span class="number">0.0</span>, <span class="number">1.0</span>);</span><br><span class="line">    <span class="keyword">return</span> out;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>First we declare struct to store the output of our vertex shader. This consists of only one field currently which is our vertex’s clip_position. The [[builtin(position)]] bit tells WGPU that this is the value we want to use as the vertex’s clip coordinates. This is analogous to GLSL’s gl_Position variable.</p>
<p>首先，我们声明struct来存储顶点着色器的输出。这当前只包含一个字段，它是顶点的剪辑位置。[[builtin（position）]位告诉WGPU这是我们要用作顶点剪辑坐标的值。这类似于GLSL的gl_位置变量。</p>
<blockquote>
<p>Vector types such as vec4 are generic. Currently you must specify the type of value the vector will contain. Thus a 3D vector using 32bit floats would be vec3<f32>.</p>
</blockquote>
<blockquote>
<p>向量类型（如vec4）是泛型的。当前必须指定向量将包含的值的类型。因此，使用32位浮点的3D向量将是vec3<f32>。</p>
</blockquote>
<p>The next part of the shader code is the main function. We are using [[stage(vertex)]] to mark this function as a valid entry point for a vertex shader. We expect a u32 called in_vertex_index which gets its value from [[builtin(vertex_index)]].</p>
<p>着色器代码的下一部分是主函数。我们使用[[stage(vertex)]]将此函数标记为顶点着色器的有效入口点。我们期望一个名为in_vertex_index的u32，它的值来自[[builtin(vertex_index)]]。</p>
<p>We then declare a variable called out using our VertexOutput struct. We create two other variables for the x, and y, of a triangle.</p>
<p>然后，我们声明一个使用VertexOutput结构调用的变量。我们为三角形创建x和y及另外两个变量。</p>
<div class="note">

<p>The f32() and i32() bits are examples of casts.</p>
<p>f32()和i32()位是强制转换的示例。</p>
</div>

<div class="note">

<p>Variables defined with <code>var</code> can be modified, but must specify their type. Variables created with <code>let</code> can have their types inferred, but their value cannot be changed during the shader.</p>
<p>可以修改用’var’定义的变量，但必须指定其类型。使用’let’创建的变量可以推断其类型，但在着色器期间不能更改其值。</p>
</div>

<p>Now we can save our clip_position to out. We then just return out and we’re done with the vertex shader!</p>
<p>现在我们可以将clip_position保存为out。然后我们返回，顶点着色器就完成了！</p>
<div class="note">

<p>We technically didn’t need a struct for this example, and could have just done something like the following:</p>
<p>从技术上讲，本例不需要结构，只需执行以下操作即可：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[[stage(vertex)]]</span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>(</span><br><span class="line">    [[builtin(vertex_index)]] in_vertex_index: <span class="built_in">u32</span></span><br><span class="line">) -&gt; [[builtin(position)]] vec4&lt;<span class="built_in">f32</span>&gt; &#123;</span><br><span class="line">    <span class="comment">// Vertex shader code...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>We’ll be adding more fields to VertexOutput later, so we might as well start using it now.</p>
<p>稍后，我们将向VertexOutput添加更多字段，因此我们不妨现在就开始使用它。</p>
</div>

<p>Next up the fragment shader. Still in shader.wgsl add the follow:</p>
<p>接下来是片段着色器。仍在shader.wgsl中添加以下内容：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Fragment shader</span></span><br><span class="line"></span><br><span class="line">[[stage(fragment)]]</span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>(<span class="keyword">in</span>: VertexOutput) -&gt; [[location(<span class="number">0</span>)]] vec4&lt;<span class="built_in">f32</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> vec4&lt;<span class="built_in">f32</span>&gt;(<span class="number">0.3</span>, <span class="number">0.2</span>, <span class="number">0.1</span>, <span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>All this does is set the color of the current fragment to brown color.</p>
<p>所有这些操作都是将当前片段的颜色设置为棕色。</p>
<div class="note">

<p>Notice that this function is also called main. Because this function is marked as a fragment shader entry point, this is ok. You can change the names around if you like, but I’ve opted to keep them the same.</p>
<p>请注意，此函数也称为main。因为此函数被标记为片段着色器入口点，所以这是确定的。如果你愿意的话，你可以改变名字，但我还是选择了保持不变。</p>
</div>

<p>The [[location(0)]] bit tells WGPU to store the value the vec4 returned by this function in the first color target. We’ll get into what this is later.</p>
<p>[[location(0)]]位告诉WGPU将此函数返回的vec4值存储在第一个颜色目标中。我们以后再谈这件事。</p>
<h1 id="How-do-we-use-the-shaders"><a href="#How-do-we-use-the-shaders" class="headerlink" title="How do we use the shaders?"></a>How do we use the shaders?</h1><p>This is the part where we finally make the thing in the title: the pipeline. First let’s modify State to include the following.</p>
<p>接着我们最终制作标题中的东西的部分：pipeline。首先，让我们修改State以包括以下内容。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main.rs</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">State</span></span> &#123;</span><br><span class="line">    surface: wgpu::Surface,</span><br><span class="line">    device: wgpu::Device,</span><br><span class="line">    queue: wgpu::Queue,</span><br><span class="line">    sc_desc: wgpu::SwapChainDescriptor,</span><br><span class="line">    swap_chain: wgpu::SwapChain,</span><br><span class="line">    size: winit::dpi::PhysicalSize&lt;<span class="built_in">u32</span>&gt;,</span><br><span class="line">    <span class="comment">// NEW!</span></span><br><span class="line">    render_pipeline: wgpu::RenderPipeline,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Now let’s move to the new() method, and start making the pipeline. We’ll have to load in those shaders we made earlier, as the render_pipeline requires those.</p>
<p>现在让我们转到new()方法，开始制作pipeline。我们必须加载之前制作的着色器，因为render_pipeline需要这些着色器。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> shader = device.create_shader_module(&amp;wgpu::ShaderModuleDescriptor &#123;</span><br><span class="line">    label: <span class="literal">Some</span>(<span class="string">&quot;Shader&quot;</span>),</span><br><span class="line">    flags: wgpu::ShaderFlags::all(),</span><br><span class="line">    source: wgpu::ShaderSource::Wgsl(<span class="built_in">include_str!</span>(<span class="string">&quot;shader.wgsl&quot;</span>).into()),</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>One more thing, we need to create a PipelineLayout. We’ll get more into this after we cover Buffers.</p>
<p>还有一件事，我们需要创建一个PipelineLayout。在我们讨论缓冲区之后，我们将进一步讨论这个问题。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> render_pipeline_layout =</span><br><span class="line">    device.create_pipeline_layout(&amp;wgpu::PipelineLayoutDescriptor &#123;</span><br><span class="line">        label: <span class="literal">Some</span>(<span class="string">&quot;Render Pipeline Layout&quot;</span>),</span><br><span class="line">        bind_group_layouts: &amp;[],</span><br><span class="line">        push_constant_ranges: &amp;[],</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure>

<p>Finally we have all we need to create the render_pipeline.</p>
<p>最后，我们有了创建render_pipeline所需的一切。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> render_pipeline = device.create_render_pipeline(&amp;wgpu::RenderPipelineDescriptor &#123;</span><br><span class="line">    label: <span class="literal">Some</span>(<span class="string">&quot;Render Pipeline&quot;</span>),</span><br><span class="line">    layout: <span class="literal">Some</span>(&amp;render_pipeline_layout),</span><br><span class="line">    vertex: wgpu::VertexState &#123;</span><br><span class="line">        module: &amp;shader,</span><br><span class="line">        entry_point: <span class="string">&quot;main&quot;</span>, <span class="comment">// 1.</span></span><br><span class="line">        buffers: &amp;[], <span class="comment">// 2.</span></span><br><span class="line">    &#125;,</span><br><span class="line">    fragment: <span class="literal">Some</span>(wgpu::FragmentState &#123; <span class="comment">// 3.</span></span><br><span class="line">        module: &amp;shader,</span><br><span class="line">        entry_point: <span class="string">&quot;main&quot;</span>,</span><br><span class="line">        targets: &amp;[wgpu::ColorTargetState &#123; <span class="comment">// 4.</span></span><br><span class="line">            format: sc_desc.format,</span><br><span class="line">            blend: <span class="literal">Some</span>(wgpu::BlendState::REPLACE),</span><br><span class="line">            write_mask: wgpu::ColorWrite::ALL,</span><br><span class="line">        &#125;],</span><br><span class="line">    &#125;),</span><br><span class="line">    <span class="comment">// continued ...</span></span><br></pre></td></tr></table></figure>

<p>Two things to note here:<br>这里需要注意两件事：</p>
<ol>
<li>Here you can specify which function inside of the shader should be called, which is known as the entry_point. These are the functions we marked with [[stage(vertex)]] and [[stage(fragment)]]</li>
<li>The buffers field tells wgpu what type of vertices we want to pass to the vertex shader. We’re specifying the vertices in the vertex shader itself so we’ll leave this empty. We’ll put something there in the next tutorial.</li>
<li>The fragment is technically optional, so you have to wrap it in Some(). We need it if we want to store color data to the swap_chain.</li>
<li>The targets field tells wgpu what color outputs it should set up.Currently we only need one for the swap_chain. We use the swap_chain’s format so that copying to it is easy, and we specify that the blending should just replace old pixel data with new data. We also tell wgpu to write to all colors: red, blue, green, and alpha. We’ll talk more aboutcolor_state when we talk about textures.</li>
</ol>
<div></div>

<ol>
<li>在这里，您可以指定应该调用着色器内部的哪个函数，该函数称为入口点。这些是我们用[[stage(vertex)]]和[[stage(fragment)]标记的函数</li>
<li>buffers字段告诉wgpu要传递给顶点着色器的顶点类型。我们将在顶点着色器本身中指定顶点，因此将此项留空。我们将在下一个教程中介绍一些内容。</li>
<li>片段着色器在技术上是可选的，因此您必须将其包装在Some()中。如果我们想将颜色数据存储到交换链，就需要它。</li>
<li>targets字段告诉wgpu应该设置什么颜色输出。目前，我们只需要一个用于交换链。我们使用swap_chain的格式，以便复制到它是很容易的，并且我们指定混合应该只是用新数据替换旧的像素数据。我们还告诉wgpu写入所有颜色：红色、蓝色、绿色和alpha。在讨论纹理时，我们将更多地讨论颜色状态。</li>
</ol>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">primitive: wgpu::PrimitiveState &#123;</span><br><span class="line">    topology: wgpu::PrimitiveTopology::TriangleList, <span class="comment">// 1.</span></span><br><span class="line">    strip_index_format: <span class="literal">None</span>,</span><br><span class="line">    front_face: wgpu::FrontFace::Ccw, <span class="comment">// 2.</span></span><br><span class="line">    cull_mode: <span class="literal">Some</span>(wgpu::Face::Back),</span><br><span class="line">    <span class="comment">// Setting this to anything other than Fill requires Features::NON_FILL_POLYGON_MODE</span></span><br><span class="line">    polygon_mode: wgpu::PolygonMode::Fill,</span><br><span class="line">    <span class="comment">// Requires Features::DEPTH_CLAMPING</span></span><br><span class="line">    clamp_depth: <span class="literal">false</span>,</span><br><span class="line">    <span class="comment">// Requires Features::CONSERVATIVE_RASTERIZATION</span></span><br><span class="line">    conservative: <span class="literal">false</span>,</span><br><span class="line">&#125;,</span><br><span class="line"><span class="comment">// continued ...</span></span><br></pre></td></tr></table></figure>

<p>The primitive field describes how to interpret our vertices when converting them into triangles.<br>primitive字段描述了在将顶点转换为三角形时如何解释顶点。</p>
<ol>
<li>Using PrimitiveTopology::TriangleList means that each three vertices will correspond to one triangle.</li>
<li>The front_face and cull_mode fields tell wgpu how to determine whether a given triangle is facing forward or not. FrontFace::Ccw means that a triangle is facing forward if the vertices are arranged in a counter clockwise direction. Triangles that are not considered facing forward are culled (not included in the render) as specified by CullMode::Back. We’ll cover culling a bit more when we cover Buffers.</li>
</ol>
<div></div>

<ol>
<li>使用PrimitiveTopology::TriangleList意味着每三个顶点对应一个三角形。</li>
<li>front_face和cull_mode字段告诉wgpu如何确定给定三角形是否朝前。FrontFace:：Ccw表示如果顶点按逆时针方向排列，则三角形朝前。根据CullMode:：Back的指定，将剔除（不包括在渲染中）不被视为朝前的三角形。当我们讨论缓冲区时，我们将更多地讨论剔除。</li>
</ol>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">    depth_stencil: <span class="literal">None</span>, <span class="comment">// 1.</span></span><br><span class="line">    multisample: wgpu::MultisampleState &#123;</span><br><span class="line">        count: <span class="number">1</span>, <span class="comment">// 2.</span></span><br><span class="line">        mask: !<span class="number">0</span>, <span class="comment">// 3.</span></span><br><span class="line">        alpha_to_coverage_enabled: <span class="literal">false</span>, <span class="comment">// 4.</span></span><br><span class="line">    &#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>The rest of the method is pretty simple:<br>该方法的其余部分非常简单：</p>
<ol>
<li>We’re not using a depth/stencil buffer currently, so we leave depth_stencil as None. This will change later.</li>
<li>This determines how many samples this pipeline will use. Multisampling is a complex topic, so we won’t get into it here.</li>
<li>sample_mask specifies which samples should be active. In this case we are using all of them.</li>
<li>alpha_to_coverage_enabled has to do with anti-aliasing. We’re not covering anti-aliasing here, so we’ll leave this as false now.</li>
</ol>
<div></div>

<ol>
<li>我们目前没有使用depth/stencil缓冲区，因此我们将depth/stencil保留为无。这将在以后改变。</li>
<li>这将确定此pipeline将使用多少个样本。多重采样是一个复杂的主题，因此我们在这里不进行讨论。</li>
<li>sample_mask指定哪些样本应处于活动状态。在本例中，我们使用了所有这些。</li>
<li>启用alpha_to_coverage_enabled与抗锯齿有关。我们这里不讨论反走样，所以现在将其保留为false。</li>
</ol>
<p>Now all we have to do is save the render_pipeline to State and then we can use it!</p>
<p>现在我们所要做的就是将render_pipeline保存到State，然后我们就可以使用它了！</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// new()</span></span><br><span class="line"><span class="keyword">Self</span> &#123;</span><br><span class="line">    surface,</span><br><span class="line">    device,</span><br><span class="line">    queue,</span><br><span class="line">    sc_desc,</span><br><span class="line">    swap_chain,</span><br><span class="line">    size,</span><br><span class="line">    <span class="comment">// NEW!</span></span><br><span class="line">    render_pipeline,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Using-a-pipeline"><a href="#Using-a-pipeline" class="headerlink" title="Using a pipeline"></a>Using a pipeline</h1><p>If you run your program now, it’ll take a little longer to start, but it will still show the blue screen we got in the last section. That’s because while we created the render_pipeline, we need to modify the code in render() to actually use it.</p>
<p>如果你现在运行你的程序，它将需要更长的时间来启动，但它仍然会显示我们在上一节中得到的蓝屏。这是因为当我们创建render_pipeline时，我们需要修改render()中的代码以实际使用它。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// render()</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 1.</span></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> render_pass = encoder.begin_render_pass(&amp;wgpu::RenderPassDescriptor &#123;</span><br><span class="line">        label: <span class="literal">Some</span>(<span class="string">&quot;Render Pass&quot;</span>),</span><br><span class="line">        color_attachments: &amp;[</span><br><span class="line">            <span class="comment">// This is what [[location(0)]] in the fragment shader targets</span></span><br><span class="line">            wgpu::RenderPassColorAttachment &#123;</span><br><span class="line">                view: &amp;frame.view,</span><br><span class="line">                resolve_target: <span class="literal">None</span>,</span><br><span class="line">                ops: wgpu::Operations &#123;</span><br><span class="line">                    load: wgpu::LoadOp::Clear(</span><br><span class="line">                        wgpu::Color &#123;</span><br><span class="line">                            r: <span class="number">0.1</span>,</span><br><span class="line">                            g: <span class="number">0.2</span>,</span><br><span class="line">                            b: <span class="number">0.3</span>,</span><br><span class="line">                            a: <span class="number">1.0</span>,</span><br><span class="line">                        &#125;</span><br><span class="line">                    ),</span><br><span class="line">                    store: <span class="literal">true</span>,</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        ],</span><br><span class="line">        depth_stencil_attachment: <span class="literal">None</span>,</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// NEW!</span></span><br><span class="line">    render_pass.set_pipeline(&amp;<span class="keyword">self</span>.render_pipeline); <span class="comment">// 2.</span></span><br><span class="line">    render_pass.draw(<span class="number">0</span>..<span class="number">3</span>, <span class="number">0</span>..<span class="number">1</span>); <span class="comment">// 3.</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure>

<p>We didn’t change much, but let’s talk about what we did change.<br>我们变化不大，但让我们谈谈我们改变了什么。</p>
<ol>
<li>We renamed _render_pass to render_pass and made it mutable.</li>
<li>We set the pipeline on the render_pass using the one we just created.</li>
<li>We tell wgpu to draw something with 3 vertices, and 1 instance. This is where [[builtin(vertex_index)]] comes from.</li>
</ol>
<div></div>

<ol>
<li>我们将_render_pass重命名为render_pass并使其可变。</li>
<li>我们将刚才创建的pipeline设置在render_pass上。</li>
<li>我们告诉wgpu用3个顶点和1个实例绘制一些东西。这就是[[builtin(vertex_index)]]的来源。</li>
</ol>
<p>With all that you should be seeing a lovely brown triangle.<br>所有这些，你应该看到一个可爱的棕色三角形。</p>
<h1 id="Challenge"><a href="#Challenge" class="headerlink" title="Challenge"></a>Challenge</h1><p>Create a second pipeline that uses the triangle’s position data to create a color that it then sends to the fragment shader. Have the app swap between these when you press the spacebar. Hint: you’ll need to modify VertexOutput</p>
<p>创建第二条管道，该管道使用三角形的位置数据创建颜色，然后发送到片段着色器。按空格键时，让应用程序在这两者之间切换。提示：您需要修改VertexOutput</p>
<p><a target="_blank" rel="noopener" href="https://github.com/sotrh/learn-wgpu/tree/master/code/beginner/tutorial3-pipeline/">Check out the code!</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://qianqians.github.io/2021/08/19/Wgpu%20The%20Swapchain/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="qianqians">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="qianqians'blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/08/19/Wgpu%20The%20Swapchain/" class="post-title-link" itemprop="url">Wgpu The Swapchain</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-08-19 16:08:20" itemprop="dateCreated datePublished" datetime="2021-08-19T16:08:20+08:00">2021-08-19</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-08-24 16:28:42" itemprop="dateModified" datetime="2021-08-24T16:28:42+08:00">2021-08-24</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Wgpu/" itemprop="url" rel="index"><span itemprop="name">Wgpu</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="First-some-house-keeping-State"><a href="#First-some-house-keeping-State" class="headerlink" title="First, some house keeping: State"></a>First, some house keeping: State</h1><p>For convenience we’re going to pack all the fields into a struct, and create some methods on that.</p>
<p>为了方便起见，我们将把所有字段打包到一个结构中，并在此基础上创建一些方法。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main.rs</span></span><br><span class="line"><span class="keyword">use</span> winit::window::Window;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">State</span></span> &#123;</span><br><span class="line">    surface: wgpu::Surface,</span><br><span class="line">    device: wgpu::Device,</span><br><span class="line">    queue: wgpu::Queue,</span><br><span class="line">    sc_desc: wgpu::SwapChainDescriptor,</span><br><span class="line">    swap_chain: wgpu::SwapChain,</span><br><span class="line">    size: winit::dpi::PhysicalSize&lt;<span class="built_in">u32</span>&gt;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> State &#123;</span><br><span class="line">    <span class="comment">// Creating some of the wgpu types requires async code</span></span><br><span class="line">    <span class="keyword">async</span> <span class="function"><span class="keyword">fn</span> <span class="title">new</span></span>(window: &amp;Window) -&gt; <span class="keyword">Self</span> &#123;</span><br><span class="line">        todo!()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">resize</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, new_size: winit::dpi::PhysicalSize&lt;<span class="built_in">u32</span>&gt;) &#123;</span><br><span class="line">        todo!()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">input</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, event: &amp;WindowEvent) -&gt; <span class="built_in">bool</span> &#123;</span><br><span class="line">        todo!()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">update</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) &#123;</span><br><span class="line">        todo!()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">render</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) -&gt; <span class="built_in">Result</span>&lt;(), wgpu::SwapChainError&gt; &#123;</span><br><span class="line">        todo!()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>I’m glossing over States fields, but they’ll make more sense as I explain the code behind the methods.</p>
<p>我对States字段进行了润色，但当我解释方法背后的代码时，它们会更有意义。</p>
<h1 id="State-new"><a href="#State-new" class="headerlink" title="State::new()"></a>State::new()</h1><p>The code for this is pretty straight forward, but let’s break this down a bit.</p>
<p>这方面的代码非常简单，但是让我们把它分解一下。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span> State &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">async</span> <span class="function"><span class="keyword">fn</span> <span class="title">new</span></span>(window: &amp;Window) -&gt; <span class="keyword">Self</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> size = window.inner_size();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// The instance is a handle to our GPU</span></span><br><span class="line">        <span class="comment">// BackendBit::PRIMARY =&gt; Vulkan + Metal + DX12 + Browser WebGPU</span></span><br><span class="line">        <span class="keyword">let</span> instance = wgpu::Instance::new(wgpu::BackendBit::PRIMARY);</span><br><span class="line">        <span class="keyword">let</span> surface = <span class="keyword">unsafe</span> &#123; instance.create_surface(window) &#125;;</span><br><span class="line">        <span class="keyword">let</span> adapter = instance.request_adapter(</span><br><span class="line">            &amp;wgpu::RequestAdapterOptions &#123;</span><br><span class="line">                power_preference: wgpu::PowerPreference::default(),</span><br><span class="line">                compatible_surface: <span class="literal">Some</span>(&amp;surface),</span><br><span class="line">            &#125;,</span><br><span class="line">        ).<span class="keyword">await</span>.unwrap();</span><br></pre></td></tr></table></figure>

<p>The surface is used to create the swap_chain. Our window needs to implement raw-window-handle’s HasRawWindowHandle trait to access the native window implementation for wgpu to properly create the graphics backend. Fortunately, winit’s Window fits the bill. We also need it to request our adapter.</p>
<p>surface用于创建swap_chain。我们的窗口需要实现原始raw-window-handle’s HasRawWindowHandle特性，以便wgpu访问本机窗口实现，从而正确创建图形后端。幸运的是，winit的窗口符合要求。我们还需要它来请求适配器。</p>
<blockquote>
<p>The options I’ve passed to request_adapter aren’t guaranteed to work for all devices, but will work for most of them. If you want to get all adapters for a particular backend you can use enumerate_adapters. This will give you an iterator that you can loop over to check if one of the adapters works for your needs.<br>我传递给request_adapter的选项不能保证对所有设备都有效，但对大多数设备都有效。如果要获取特定后端的所有适配器，可以使用enumerate_adapters。这将为您提供一个迭代器，您可以循环检查其中一个适配器是否满足您的需要。</p>
</blockquote>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> adapter = instance</span><br><span class="line">   .enumerate_adapters(wgpu::BackendBit::PRIMARY)</span><br><span class="line">   .filter(|adapter| &#123;</span><br><span class="line">       <span class="comment">// Check if this adapter supports our surface</span></span><br><span class="line">       adapter.get_swap_chain_preferred_format(&amp;surface).is_some()</span><br><span class="line">   &#125;)</span><br><span class="line">   .first()</span><br><span class="line">   .unwrap()</span><br></pre></td></tr></table></figure>

<blockquote>
<p>For more fields you can use to refine you’re search check out the docs.<br>有关可用于优化搜索的更多字段，<a target="_blank" rel="noopener" href="https://docs.rs/wgpu/0.9.0/wgpu/struct.Adapter.html">请查看文档</a></p>
</blockquote>
<p>We need the adapter to create the device and queue.<br>我们需要适配器来创建设备和队列。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> (device, queue) = adapter.request_device(</span><br><span class="line">    &amp;wgpu::DeviceDescriptor &#123;</span><br><span class="line">        features: wgpu::Features::empty(),</span><br><span class="line">        limits: wgpu::Limits::default(),</span><br><span class="line">        label: <span class="literal">None</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="literal">None</span>, <span class="comment">// Trace path</span></span><br><span class="line">).<span class="keyword">await</span>.unwrap();</span><br></pre></td></tr></table></figure>
<p>The features field on DeviceDescriptor, allows us to specify what extra features we want. For this simple example, I’ve decided not to use any extra features.<br>DeviceDescriptor上的features字段允许我们指定所需的额外功能。对于这个简单的例子，我决定不使用任何额外的特性。</p>
<blockquote>
<p>The device you have limits the features you can use. If you want to use certain features you may need to limit what devices you support, or provide work arounds.<br>You can get a list of features supported by your device using adapter.features(), or device.features().<br>You can view a full list of features here.</p>
</blockquote>
<blockquote>
<p>您拥有的设备限制了您可以使用的功能。如果您想使用某些功能，您可能需要限制您支持的设备，或提供解决方案。<br>您可以使用adapter.features（）或device.features（）获取设备支持的功能列表。<br>您可以在此处查看功能的<a target="_blank" rel="noopener" href="https://docs.rs/wgpu/0.9.0/wgpu/struct.Features.html">完整列表</a>。</p>
</blockquote>
<p>The limits field describes the limit of certain types of resource we can create. We’ll use the defaults for this tutorial, so we can support most devices. You can view a list of limits here.</p>
<p>limits字段描述了我们可以创建的特定类型资源的限制。本教程将使用默认设置，因此我们可以支持大多数设备。您可以在此处查看<a target="_blank" rel="noopener" href="https://docs.rs/wgpu/0.9.0/wgpu/struct.Limits.html">limits列表</a>。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> sc_desc = wgpu::SwapChainDescriptor &#123;</span><br><span class="line">    usage: wgpu::TextureUsage::RENDER_ATTACHMENT,</span><br><span class="line">    format: adapter.get_swap_chain_preferred_format(&amp;surface).unwrap(),</span><br><span class="line">    width: size.width,</span><br><span class="line">    height: size.height,</span><br><span class="line">    present_mode: wgpu::PresentMode::Fifo,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> swap_chain = device.create_swap_chain(&amp;surface, &amp;sc_desc);</span><br></pre></td></tr></table></figure>

<p>Here we are defining and creating the swap_chain. The usage field describes how the swap_chain’s underlying textures will be used. RENDER_ATTACHMENT specifies that the textures will be used to write to the screen (we’ll talk about more TextureUsages later).</p>
<p>这里我们定义并创建swap_chain。usage字段描述如何使用swap_chain的基础纹理。RENDER_ATTACHMENT指定纹理将用于写入屏幕（稍后我们将讨论更多纹理图像）。</p>
<p>The format defines how the swap_chains textures will be stored on the gpu. Different displays prefer different formats. We use adapter.get_swap_chain_preferred_format() to figure out the best format to use.</p>
<p>该格式定义如何将swap_chains纹理存储在gpu上。不同的显示器喜欢不同的格式。我们使用adapter.get_swap_chain_preferred_format()来找出最佳的使用格式。</p>
<p>width and height, are the width and height in pixels of the swap chain. This should usually be the width and height of the window.</p>
<p>宽度和高度是swap_chain的宽度和高度(以像素为单位)。这通常应该是窗口的宽度和高度。</p>
<p>The present_mode uses the wgpu::PresentMode enum which determines how to sync the swap chain with the display. You can see all the options in the docs</p>
<p>当前模式使用wgpu::PresentMode枚举，该枚举确定如何将swap_chain与显示同步。您可以在文档中看到<a target="_blank" rel="noopener" href="https://docs.rs/wgpu/0.9.0/wgpu/enum.PresentMode.html">所有选项</a></p>
<p>At the end of the method, we simply return the resulting struct.</p>
<p>在方法的末尾，我们只返回结构体结果。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">        <span class="keyword">Self</span> &#123;</span><br><span class="line">            surface,</span><br><span class="line">            device,</span><br><span class="line">            queue,</span><br><span class="line">            sc_desc,</span><br><span class="line">            swap_chain,</span><br><span class="line">            size,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>We’ll want to call this in our main method before we enter the event loop.</p>
<p>在进入事件循环之前，我们希望在main方法中调用它。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Since main can&#x27;t be async, we&#x27;re going to need to block</span></span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut</span> state = pollster::block_on(State::new(&amp;window));</span><br></pre></td></tr></table></figure>

<blockquote>
<p>You can use heavier libraries like async_std and tokio to make main async, so you can await futures. I’ve elected not to use these crates as this tutorial is not about writing an async application, and the futures created by wgpu do not require special executor support. We just need some way to interact with wgpu’s async functions, and the pollster crate is enough for that.</p>
</blockquote>
<blockquote>
<p>您可以使用较重的库（如async_std和tokio）来实现main函数异步，因此您可以等待futures。我选择不使用这些crates，因为本教程不是关于编写异步应用程序的，而且wgpu创建的crates不需要特殊的执行器支持。我们只需要一些与wgpu的异步函数交互的方法，the pollster crate就足够了。</p>
</blockquote>
<h1 id="resize"><a href="#resize" class="headerlink" title="resize()"></a>resize()</h1><p>If we want to support resizing in our application, we’re going to need to recreate the swap_chain everytime the window’s size changes. That’s the reason we stored the physical size and the sc_desc used to create the swapchain. With all of these, the resize method is very simple.</p>
<p>如果我们想在应用程序中支持调整大小，我们需要在每次窗口大小更改时重新创建swap_chain。这就是我们存储用于创建swap_chain的物理大小和sc_desc的原因。有了所有这些，调整大小的方法非常简单。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// impl State</span></span><br><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">resize</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, new_size: winit::dpi::PhysicalSize&lt;<span class="built_in">u32</span>&gt;) &#123;</span><br><span class="line">    <span class="keyword">if</span> new_size.width &gt; <span class="number">0</span> &amp;&amp; new_size.height &gt; <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.size = new_size;</span><br><span class="line">        <span class="keyword">self</span>.sc_desc.width = new_size.width;</span><br><span class="line">        <span class="keyword">self</span>.sc_desc.height = new_size.height;</span><br><span class="line">        <span class="keyword">self</span>.swap_chain = <span class="keyword">self</span>.device.create_swap_chain(&amp;<span class="keyword">self</span>.surface, &amp;<span class="keyword">self</span>.sc_desc);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>There’s nothing really different here from creating the swap_chain initially, so I won’t get into it.</p>
<p>这里与最初创建swap_chain没有什么不同，所以我就不谈了。</p>
<p>We call this method in main() in the event loop for the following events.</p>
<p>对于以下事件，我们在main函数的事件循环的中调用此方法。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">match</span> event &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">if</span> window_id == window.id() =&gt; <span class="keyword">if</span> !state.input(event) &#123;</span><br><span class="line">        <span class="keyword">match</span> event &#123;</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">            WindowEvent::Resized(physical_size) =&gt; &#123;</span><br><span class="line">                state.resize(*physical_size);</span><br><span class="line">            &#125;</span><br><span class="line">            WindowEvent::ScaleFactorChanged &#123; new_inner_size, .. &#125; =&gt; &#123;</span><br><span class="line">                <span class="comment">// new_inner_size is &amp;&amp;mut so we have to dereference it twice</span></span><br><span class="line">                state.resize(**new_inner_size);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="input"><a href="#input" class="headerlink" title="input()"></a>input()</h1><p>input() returns a bool to indicate whether an event has been fully processed. If the method returns true, the main loop won’t process the event any further.</p>
<p>input函数返回一个bool以指示事件是否已被完全处理。如果该方法返回true，则主循环将不再进一步处理该事件。</p>
<p>We’re just going to return false for now because we don’t have any events we want to capture.</p>
<p>我们现在只返回false，因为我们没有任何要捕获的事件。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// impl State</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">input</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, event: &amp;WindowEvent) -&gt; <span class="built_in">bool</span> &#123;</span><br><span class="line">    <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>We need to do a little more work in the event loop. We want State to have priority over main(). Doing that (and previous changes) should have your loop looking like this.</p>
<p>我们需要在事件循环中做更多的工作。我们希望State优先于main（）。这样做（以及之前的更改）应该使循环看起来像这样。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main()</span></span><br><span class="line">event_loop.run(<span class="keyword">move</span> |event, _, control_flow| &#123;</span><br><span class="line">    <span class="keyword">match</span> event &#123;</span><br><span class="line">        Event::WindowEvent &#123;</span><br><span class="line">            <span class="keyword">ref</span> event,</span><br><span class="line">            window_id,</span><br><span class="line">        &#125; <span class="keyword">if</span> window_id == window.id() =&gt; <span class="keyword">if</span> !state.input(event) &#123; <span class="comment">// UPDATED!</span></span><br><span class="line">            <span class="keyword">match</span> event &#123;</span><br><span class="line">                WindowEvent::CloseRequested</span><br><span class="line">                | WindowEvent::KeyboardInput &#123;</span><br><span class="line">                    input:</span><br><span class="line">                        KeyboardInput &#123;</span><br><span class="line">                            state: ElementState::Pressed,</span><br><span class="line">                            virtual_keycode: <span class="literal">Some</span>(VirtualKeyCode::Escape),</span><br><span class="line">                            ..</span><br><span class="line">                        &#125;,</span><br><span class="line">                    ..</span><br><span class="line">                &#125; =&gt; *control_flow = ControlFlow::Exit,</span><br><span class="line">                WindowEvent::Resized(physical_size) =&gt; &#123;</span><br><span class="line">                    state.resize(*physical_size);</span><br><span class="line">                &#125;</span><br><span class="line">                WindowEvent::ScaleFactorChanged &#123; new_inner_size, .. &#125; =&gt; &#123;</span><br><span class="line">                    state.resize(**new_inner_size);</span><br><span class="line">                &#125;</span><br><span class="line">                _ =&gt; &#123;&#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        _ =&gt; &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h1 id="update"><a href="#update" class="headerlink" title="update()"></a>update()</h1><p>We don’t have anything to update yet, so leave the method empty.</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">update</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) &#123;</span><br><span class="line">    <span class="comment">// remove `todo!()`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="render"><a href="#render" class="headerlink" title="render()"></a>render()</h1><p>Here’s where the magic happens. First we need to get a frame to render to. This will include a wgpu::Texture and wgpu::TextureView that will hold the actual image we’re drawing to (we’ll cover this more when we talk about textures).</p>
<p>这就是魔法发生的地方。首先，我们需要得到一个帧来渲染。这将包括wgpu:：Texture和wgpu:：TextureView，它们将保存我们正在绘制的实际图像（我们将在讨论纹理时详细介绍这一点）。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// impl State</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">render</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) -&gt; <span class="built_in">Result</span>&lt;(), wgpu::SwapChainError&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> frame = <span class="keyword">self</span></span><br><span class="line">        .swap_chain</span><br><span class="line">        .get_current_frame()?</span><br><span class="line">        .output;</span><br></pre></td></tr></table></figure>

<p>We also need to create a CommandEncoder to create the actual commands to send to the gpu. Most modern graphics frameworks expect commands to be stored in a command buffer before being sent to the gpu. The encoder builds a command buffer that we can then send to the gpu.</p>
<p>我们还需要创建CommandEncoder来创建发送到gpu的实际命令。大多数现代图形框架都希望命令在发送到gpu之前存储在命令缓冲区中。编码器构建一个命令缓冲区，然后我们可以将其发送到gpu。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut</span> encoder = <span class="keyword">self</span>.device.create_command_encoder(&amp;wgpu::CommandEncoderDescriptor &#123;</span><br><span class="line">    label: <span class="literal">Some</span>(<span class="string">&quot;Render Encoder&quot;</span>),</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>Now we can actually get to clearing the screen (long time coming). We need to use the encoder to create a RenderPass. The RenderPass has all the methods to do the actual drawing. The code for creating a RenderPass is a bit nested, so I’ll copy it all here, and talk about the pieces.</p>
<p>现在我们可以开始清理屏幕了（很长一段时间就要到了）。我们需要使用编码器来创建一个RenderPass。RenderPass具有进行实际绘制的所有方法。创建RenderPass的代码有点嵌套，所以我将在这里全部复制，并讨论各个部分。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">let</span> _render_pass = encoder.begin_render_pass(&amp;wgpu::RenderPassDescriptor &#123;</span><br><span class="line">            label: <span class="literal">Some</span>(<span class="string">&quot;Render Pass&quot;</span>),</span><br><span class="line">            color_attachments: &amp;[</span><br><span class="line">                wgpu::RenderPassColorAttachment &#123;</span><br><span class="line">                    view: &amp;frame.view,</span><br><span class="line">                    resolve_target: <span class="literal">None</span>,</span><br><span class="line">                    ops: wgpu::Operations &#123;</span><br><span class="line">                        load: wgpu::LoadOp::Clear(wgpu::Color &#123;</span><br><span class="line">                            r: <span class="number">0.1</span>,</span><br><span class="line">                            g: <span class="number">0.2</span>,</span><br><span class="line">                            b: <span class="number">0.3</span>,</span><br><span class="line">                            a: <span class="number">1.0</span>,</span><br><span class="line">                        &#125;),</span><br><span class="line">                        store: <span class="literal">true</span>,</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            ],</span><br><span class="line">            depth_stencil_attachment: <span class="literal">None</span>,</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// submit will accept anything that implements IntoIter</span></span><br><span class="line">    <span class="keyword">self</span>.queue.submit(std::iter::once(encoder.finish()));</span><br><span class="line"></span><br><span class="line">    <span class="literal">Ok</span>(())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>First things first, let’s talk about the {}. encoder.begin_render_pass(…) borrows encoder mutably (aka &amp;mut self). We can’t call encoder.finish() until we release that mutable borrow. The {} around encoder.begin_render_pass(…) tells rust to drop any variables within them when the code leaves that scope thus releasing the mutable borrow on encoder and allowing us to finish() it. If you don’t like the {}, you can also use drop(render_pass) to achieve the same effect.</p>
<p>首先，让我们先谈谈{}包括的代码。 encoder.begin_render_pass(…)使encoder可变(aka &amp;mut self)。在释放该可变借用之前，我们无法调用encoder.finish()。使用{}包括encoder.begin_render_pass(…)告诉rust在代码离开该范围时删除其中的任何变量，从而释放借用的可变编码器，并允许我们完成它。如果不喜欢{}，也可以使用drop(render_pass)来实现相同的效果。</p>
<p>We can get the same results by removing the {}, and the let _render_pass = line, but we need access to the _render_pass in the next tutorial, so we’ll leave it as is.</p>
<p>我们可以通过删除{}和let _render_pass=line来获得相同的结果，但是我们需要在下一个教程中访问_render_pass，所以我们将保持原样。</p>
<p>The last lines of the code tell wgpu to finish the command buffer, and to submit it to the gpu’s render queue.</p>
<p>代码的最后几行告诉wgpu完成命令缓冲区，并将其提交到gpu的渲染队列。</p>
<p>We need to update the event loop again to call this method. We’ll also call update before it too.</p>
<p>我们需要再次更新事件循环以调用此方法。我们也会在更新之前调用update。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main()</span></span><br><span class="line">event_loop.run(<span class="keyword">move</span> |event, _, control_flow| &#123;</span><br><span class="line">    <span class="keyword">match</span> event &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        Event::RedrawRequested(_) =&gt; &#123;</span><br><span class="line">            state.update();</span><br><span class="line">            <span class="keyword">match</span> state.render() &#123;</span><br><span class="line">                <span class="literal">Ok</span>(_) =&gt; &#123;&#125;</span><br><span class="line">                <span class="comment">// Recreate the swap_chain if lost</span></span><br><span class="line">                <span class="literal">Err</span>(wgpu::SwapChainError::Lost) =&gt; state.resize(state.size),</span><br><span class="line">                <span class="comment">// The system is out of memory, we should probably quit</span></span><br><span class="line">                <span class="literal">Err</span>(wgpu::SwapChainError::OutOfMemory) =&gt; *control_flow = ControlFlow::Exit,</span><br><span class="line">                <span class="comment">// All other errors (Outdated, Timeout) should be resolved by the next frame</span></span><br><span class="line">                <span class="literal">Err</span>(e) =&gt; eprintln!(<span class="string">&quot;&#123;:?&#125;&quot;</span>, e),</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        Event::MainEventsCleared =&gt; &#123;</span><br><span class="line">            <span class="comment">// RedrawRequested will only trigger once, unless we manually</span></span><br><span class="line">            <span class="comment">// request it.</span></span><br><span class="line">            window.request_redraw();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h1 id="Wait-what’s-going-on-with-RenderPassDescriptor"><a href="#Wait-what’s-going-on-with-RenderPassDescriptor" class="headerlink" title="Wait, what’s going on with RenderPassDescriptor?"></a>Wait, what’s going on with RenderPassDescriptor?</h1><p>Some of you may be able to tell what’s going on just by looking at it, but I’d be remiss if I didn’t go over it. Let’s take a look at the code again.</p>
<p>你们中的一些人可能仅仅通过看它就能知道发生了什么，但如果我不仔细看一下，那我就是失职了。让我们再看一遍代码。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&amp;wgpu::RenderPassDescriptor &#123;</span><br><span class="line">    label: <span class="literal">Some</span>(<span class="string">&quot;Render Pass&quot;</span>),</span><br><span class="line">    color_attachments: &amp;[</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    ],</span><br><span class="line">    depth_stencil_attachment: <span class="literal">None</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>A RenderPassDescriptor only has three fields: label, color_attachments and depth_stencil_attachment. The color_attachements describe where we are going to draw our color to. We’ll use depth_stencil_attachment later, but we’ll set it to None for now.</p>
<p>RenderPassDescriptor只有三个字段：label、color_attachments和depth_stencil_attachment。color_attachments描述了我们将在何处绘制颜色。稍后我们将使用depth_stencil_attachment，但现在将其设置为None。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">wgpu::RenderPassColorAttachment &#123;</span><br><span class="line">    view: &amp;frame.view,</span><br><span class="line">    resolve_target: <span class="literal">None</span>,</span><br><span class="line">    ops: wgpu::Operations &#123;</span><br><span class="line">        load: wgpu::LoadOp::Clear(wgpu::Color &#123;</span><br><span class="line">            r: <span class="number">0.1</span>,</span><br><span class="line">            g: <span class="number">0.2</span>,</span><br><span class="line">            b: <span class="number">0.3</span>,</span><br><span class="line">            a: <span class="number">1.0</span>,</span><br><span class="line">        &#125;),</span><br><span class="line">        store: <span class="literal">true</span>,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>The RenderPassColorAttachment has the view field which informs wgpu what texture to save the colors to. In this case we specify frame.view that we created using swap_chain.get_current_frame(). This means that any colors we draw to this attachment will get drawn to the screen.</p>
<p>RenderPassColorAttachment有一个视图字段，用于通知wgpu要保存颜色的纹理。在本例中，我们指定使用swap_chain.get_current_frame()创建的frame.view。这意味着我们在此附件中绘制的任何颜色都将被绘制到屏幕上。</p>
<p>The resolve_target is the texture that will receive the resolved output. This will be the same as attachment unless multisampling is enabled. We don’t need to specify this, so we leave it as None.</p>
<p>resolve_target是将接收解析输出的纹理。除非启用了多重采样，否则这将与attachment相同。我们不需要指定它，所以我们将其保留为None。</p>
<p>The ops field takes a wpgu::Operations object. This tells wgpu what to do with the colors on the screen (specified by frame.view). The load field tells wgpu how to handle colors stored from the previous frame. Currently we are clearing the screen with a bluish color.</p>
<p>ops字段接受一个wpgu::Operations对象。这告诉wgpu如何处理屏幕上的颜色(由frame.view指定)。load字段告诉wgpu如何处理从上一帧存储的颜色。目前，我们正在清除带有蓝色的屏幕。</p>
<h1 id="Challenge"><a href="#Challenge" class="headerlink" title="Challenge"></a>Challenge</h1><p>Modify the input() method to capture mouse events, and update the clear color using that. Hint: you’ll probably need to use WindowEvent::CursorMoved.</p>
<p>修改input()方法以捕获鼠标事件，并使用该方法更新清除颜色。提示：您可能需要使用WindowEvent::CursorMoved。</p>
<p><a target="_blank" rel="noopener" href="https://github.com/sotrh/learn-wgpu/tree/master/code/beginner/tutorial2-swapchain/">Check out the code!</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://qianqians.github.io/2021/08/17/WebGPU%203.4.2.%20Memory%20Model/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="qianqians">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="qianqians'blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/08/17/WebGPU%203.4.2.%20Memory%20Model/" class="post-title-link" itemprop="url">WebGPU 3.4.2. Memory Model</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2021-08-17 16:53:49 / 修改时间：17:25:58" itemprop="dateCreated datePublished" datetime="2021-08-17T16:53:49+08:00">2021-08-17</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/WebGPU/" itemprop="url" rel="index"><span itemprop="name">WebGPU</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>Once a GPUDevice has been obtained during an application initialization routine, we can describe the WebGPU platform as consisting of the following layers:</p>
<ol>
<li>User agent implementing the specification.</li>
<li>Operating system with low-level native API drivers for this device.</li>
<li>Actual CPU and GPU hardware.</li>
</ol>
<p>在应用程序初始化例程中获得GPU设备后，我们可以将WebGPU平台描述为由以下层组成:</p>
<ol>
<li>实现规范的用户代理。</li>
<li>此设备具有低级本机API驱动的操作系统。</li>
<li>实际的CPU和GPU硬件。</li>
</ol>
<p>Each layer of the WebGPU platform may have different memory types that the user agent needs to consider when implementing the specification:</p>
<ul>
<li>The script-owned memory, such as an ArrayBuffer created by the script, is generally not accessible by a GPU driver.</li>
<li>A user agent may have different processes responsible for running the content and communication to the GPU driver. In this case, it uses inter-process shared memory to transfer data.</li>
<li>Dedicated GPUs have their own memory with high bandwidth, while integrated GPUs typically share memory with the system.</li>
</ul>
<p>WebGPU平台的每一层可能有不同的内存类型，用户代理在执行规范时需要考虑:</p>
<ul>
<li>脚本拥有的内存（如脚本创建的ArrayBuffer）通常不可由GPU驱动程序访问。</li>
<li>用户代理可以具有负责运行内容和与GPU驱动程序通信的不同进程。在这种情况下，它使用进程间共享内存来传输数据。</li>
<li>专用GPU拥有自己的高带宽内存，而集成GPU通常与系统共享内存。</li>
</ul>
<p>Most physical resources are allocated in the memory of type that is efficient for computation or rendering by the GPU. When the user needs to provide new data to the GPU, the data may first need to cross the process boundary in order to reach the user agent part that communicates with the GPU driver. Then it may need to be made visible to the driver, which sometimes requires a copy into driver-allocated staging memory. Finally, it may need to be transferred to the dedicated GPU memory, potentially changing the internal layout into one that is most efficient for GPUs to operate on.</p>
<p>大多数物理资源都分配在GPU高效计算或渲染的内存中。当用户需要向GPU提供新数据时，数据可能首先需要跨越进程边界以到达与GPU驱动程序通信的用户代理部分。然后可能需要使其对驱动程序可见，这有时需要将副本复制到驱动程序分配的暂存内存中。最后，可能需要将其传输到专用GPU内存，从而可能会将内部布局更改为GPU操作最有效的布局。</p>
<p>All of these transitions are done by the WebGPU implementation of the user agent.</p>
<p>所有这些转换都由用户代理的WebGPU实现完成。</p>
<blockquote>
<p>Note: This example describes the worst case, while in practice the implementation may not need to cross the process boundary, or may be able to expose the driver-managed memory directly to the user behind an ArrayBuffer, thus avoiding any data copies.</p>
</blockquote>
<blockquote>
<p>注: 本例描述了最坏的情况，而实际上实现可能不需要跨越进程边界，或者可能能够将驱动程序管理的内存直接暴露给ArrayBuffer后面的用户，从而避免任何数据拷贝。</p>
</blockquote>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://qianqians.github.io/2021/08/13/WebGPU%203.4.1.%20Timelines/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="qianqians">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="qianqians'blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/08/13/WebGPU%203.4.1.%20Timelines/" class="post-title-link" itemprop="url">WebGPU 3.4.1. Timelines</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-08-13 15:10:14" itemprop="dateCreated datePublished" datetime="2021-08-13T15:10:14+08:00">2021-08-13</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-08-17 16:45:14" itemprop="dateModified" datetime="2021-08-17T16:45:14+08:00">2021-08-17</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/WebGPU/" itemprop="url" rel="index"><span itemprop="name">WebGPU</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>A computer system with a user agent at the front-end and GPU at the back-end has components working on different timelines in parallel:</p>
<p>Content timeline<br>Associated with the execution of the Web script. It includes calling all methods described by this specification.<br>Steps executed on the content timeline look like this.</p>
<p>Device timeline<br>Associated with the GPU device operations that are issued by the user agent. It includes creation of adapters, devices, and GPU resources and state objects, which are typically synchronous operations from the point of view of the user agent part that controls the GPU, but can live in a separate OS process.<br>Steps executed on the device timeline look like this.</p>
<p>Queue timeline<br>Associated with the execution of operations on the compute units of the GPU. It includes actual draw, copy, and compute jobs that run on the GPU.<br>Steps executed on the queue timeline look like this.</p>
<p>一个前端有用户代理，后端有GPU的计算机系统的组件在不同的时间线上并行工作：</p>
<p>内容时间轴<br>与Web脚本的执行关联。它包括调用本规范描述的所有方法。<br>在内容时间轴上执行的步骤如下所示。</p>
<p>设备时间轴<br>与用户代理发出的GPU设备操作关联。它包括创建适配器、设备、GPU资源和状态对象，从控制GPU的用户代理部分的角度来看，这些通常是同步操作，并且可以存在于单独的操作系统进程中。<br>在设备时间轴上执行的步骤如下所示。</p>
<p>队列时间轴<br>与在GPU的计算单元上执行操作有关。它包括在GPU上运行的实际绘制、复制和计算作业。<br>在队列时间轴上执行的步骤如下所示。</p>
<p>In this specification, asynchronous operations are used when the result value depends on work that happens on any timeline other than the Content timeline. They are represented by callbacks and promises in JavaScript.</p>
<p>在本规范中，当结果值取决于除内容时间线以外的任何时间线上发生的工作时，将使用异步操作。它们由JavaScript中的回调和promises表示。</p>
<blockquote>
<p>EXAMPLE 1<br>GPUComputePassEncoder.dispatch():</p>
<blockquote>
<ol>
<li>User encodes a dispatch command by calling a method of the GPUComputePassEncoder which happens on the Content timeline.</li>
<li>User issues GPUQueue.submit() that hands over the GPUCommandBuffer to the user agent, which processes it on the Device timeline by calling the OS driver to do a low-level submission.</li>
<li>The submit gets dispatched by the GPU invocation scheduler onto the actual compute units for execution, which happens on the Queue timeline.</li>
</ol>
</blockquote>
<blockquote>
<ol>
<li>用户通过调用发生在内容时间轴上的GPUComputePassEncoder方法对调度命令进行编码。</li>
<li>用户发出GPUQueue.submit()，将GPUCommandBuffer移交给用户代理，用户代理通过调用操作系统驱动程序进行低级提交，在设备时间轴上对其进行处理。</li>
<li>提交由GPU调用调度器调度到实际的计算单元上执行，这发生在队列时间线上。</li>
</ol>
</blockquote>
</blockquote>
<blockquote>
<p>EXAMPLE 2<br>GPUDevice.createBuffer():</p>
<blockquote>
<ol>
<li>User fills out a GPUBufferDescriptor and creates a GPUBuffer with it, which happens on the Content timeline.</li>
<li>User agent creates a low-level buffer on the Device timeline.</li>
</ol>
</blockquote>
<blockquote>
<ol>
<li>用户填写一个GPUBufferDescriptor并用它创建一个GPUBuffer，这发生在内容时间轴上。</li>
<li>用户代理在设备时间轴上创建低级缓冲区。</li>
</ol>
</blockquote>
</blockquote>
<blockquote>
<p>EXAMPLE 3<br>GPUBuffer.mapAsync():</p>
<blockquote>
<ol>
<li>User requests to map a GPUBuffer on the Content timeline and gets a promise in return.</li>
<li>User agent checks if the buffer is currently used by the GPU and makes a reminder to itself to check back when this usage is over.</li>
<li>After the GPU operating on Queue timeline is done using the buffer, the user agent maps it to memory and resolves the promise.</li>
</ol>
</blockquote>
<blockquote>
<ol>
<li>用户请求将GPUBuffer映射到内容时间轴上，并得到一个promise作为返回值。</li>
<li>用户代理检查缓冲区当前是否由GPU使用，并提醒自己在使用结束时检查。</li>
<li>在GPU使用缓冲区对队列时间轴进行操作之后，用户代理将其映射到内存并resolves the promise。</li>
</ol>
</blockquote>
</blockquote>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://qianqians.github.io/2021/08/13/WebGPU%203.3.%20Coordinate%20Systems/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="qianqians">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="qianqians'blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/08/13/WebGPU%203.3.%20Coordinate%20Systems/" class="post-title-link" itemprop="url">WebGPU 3.3. Coordinate Systems</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2021-08-13 11:52:13 / 修改时间：14:49:34" itemprop="dateCreated datePublished" datetime="2021-08-13T11:52:13+08:00">2021-08-13</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/WebGPU/" itemprop="url" rel="index"><span itemprop="name">WebGPU</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <ul>
<li><p>Y-axis is up in normalized device coordinate (NDC): point(-1.0, -1.0) in NDC is located at the bottom-left corner of NDC. In addition, x and y in NDC should be between -1.0 and 1.0 inclusive, while z in NDC should be between 0.0 and 1.0 inclusive. Vertices out of this range in NDC will not introduce any errors, but they will be clipped.</p>
</li>
<li><p>Y-axis is down in framebuffer coordinate, viewport coordinate and fragment/pixel coordinate: origin(0, 0) is located at the top-left corner in these coordinate systems.</p>
</li>
<li><p>Window/present coordinate matches framebuffer coordinate.</p>
</li>
<li><p>UV of origin(0, 0) in texture coordinate represents the first texel (the lowest byte) in texture memory.</p>
</li>
<li><p>Y轴在归一化设备坐标（NDC）中向上：NDC中的点（-1.0，-1.0）位于NDC的左下角。此外，NDC中的x和y应介于-1.0和1.0之间，而NDC中的z应介于0.0和1.0之间。NDC中超出此范围的顶点不会引入任何错误，但它们将被剪裁。</p>
</li>
<li><p>Y轴在帧缓冲区坐标、视口坐标和片段/像素坐标中向下：原点（0，0）位于这些坐标系的左上角。</p>
</li>
<li><p>窗口/当前坐标与帧缓冲区坐标匹配。</p>
</li>
<li><p>纹理坐标中的UV原点（0,0）表示纹理内存中的第一个texel（最低字节）。</p>
</li>
</ul>
<p>Note: WebGPU’s coordinate systems match DirectX and Metal’s coordinate systems in a graphics pipeline.</p>
<p>注：WebGPU的坐标系在图形管道中与DirectX和Metal的坐标系匹配。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://qianqians.github.io/2021/08/10/WebGPU%203.2.%20Invalid%20Internal%20Objects%20&%20Contagious%20Invalidity/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="qianqians">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="qianqians'blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/08/10/WebGPU%203.2.%20Invalid%20Internal%20Objects%20&%20Contagious%20Invalidity/" class="post-title-link" itemprop="url">WebGPU 3.2. Invalid Internal Objects & Contagious Invalidity</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2021-08-10 14:46:03 / 修改时间：15:29:14" itemprop="dateCreated datePublished" datetime="2021-08-10T14:46:03+08:00">2021-08-10</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/WebGPU/" itemprop="url" rel="index"><span itemprop="name">WebGPU</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>If an object is successfully created, it is valid at that moment. An internal object may be invalid. It may become invalid during its lifetime, but it will never become valid again.</p>
<p>如果成功创建了一个对象，则该对象此时有效。内部对象可能无效。它可能在其生命周期内失效，并且永远不会再次生效。</p>
<p>Invalid objects result from a number of situations, including:<br>&nbsp;If there is an error in the creation of an object, it is immediately invalid. This can happen, for example, if the object descriptor doesn’t describe a valid object, or if there is not enough memory to allocate a resource.<br>&nbsp;If an object is explicitly destroyed (e.g. GPUBuffer.destroy()), it becomes invalid.<br>&nbsp;If the device that owns an object is lost, the object becomes invalid.</p>
<p>无效对象由多种情况造成，包括：<br>&nbsp;如果在创建对象时出错，则该对象立即无效。例如，如果对象描述符没有描述有效的对象，或者没有足够的内存来分配资源，就会发生这种情况。<br>&nbsp;如果对象被显式销毁(例如GPUBuffer.destroy())，则该对象将无效。<br>&nbsp;如果拥有对象的设备丢失，该对象将无效。</p>
<p>To determine if a given GPUObjectBase object is valid to use with a targetObject, run the following steps:<br>&nbsp;1.If any of the following conditions are unsatisfied return false:<br>&nbsp;&nbsp;object is valid<br>&nbsp;&nbsp;object.[[device]] is valid.<br>&nbsp;&nbsp;object.[[device]] is targetObject.[[device]].<br>&nbsp;2.Return true.</p>
<p>要确定给定的GPUObjectBase对象是否可与targetObject一起使用，请运行以下步骤：<br>&nbsp;1.如果以下任一条件不满足，则返回false：<br>&nbsp;&nbsp;对象是有效的<br>&nbsp;&nbsp;object.[[device]]是有效的<br>&nbsp;&nbsp;object.[[device]]是targetObject.[[device]].<br>&nbsp;2.返回true.</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">qianqians</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>

<script src="/js/bookmark.js"></script>




  















  

  

</body>
</html>
