<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">
  <link rel="manifest" href="/images/manifest.json">
  <meta name="msapplication-config" content="/images/browserconfig.xml">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">
<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"qianqians.github.io","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"remove","padding":18,"offset":12,"onmobile":true},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":true,"scrollpercent":true},"bookmark":{"enable":true,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="qianqians&#39;blog">
<meta property="og:url" content="https://qianqians.github.io/page/2/index.html">
<meta property="og:site_name" content="qianqians&#39;blog">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="qianqians">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://qianqians.github.io/page/2/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>qianqians'blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">qianqians'blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档<span class="badge">42</span></a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>分类<span class="badge">10</span></a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-fw fa-user"></i>关于</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <a role="button" class="book-mark-link book-mark-link-fixed"></a>

  <a href="https://github.com/qianqians" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://qianqians.github.io/2023/11/26/ice_Lexical_Rules/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="qianqians">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="qianqians'blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/11/26/ice_Lexical_Rules/" class="post-title-link" itemprop="url">Lexical Rules</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2023-11-26 22:46:10 / 修改时间：23:01:50" itemprop="dateCreated datePublished" datetime="2023-11-26T22:46:10+08:00">2023-11-26</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/ice/" itemprop="url" rel="index"><span itemprop="name">ice</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>Lexical Rules</p>
<p>Slice’s lexical rules are very similar to those of C++ and Java, except for some differences for identifiers.</p>
<p>Slice 的词法规则与 C++ 和 Java 的非常相似，除了标识符的一些差异之外。</p>
<p>Comments</p>
<p>Slice definitions permit both the C and the C++ style of writing comments:</p>
<p>Slice定义允许使用 C 和 C++ 风格编写注释：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * C-style comment.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// C++-style comment extending to the end of this line.</span></span><br></pre></td></tr></table></figure>

<p>Keywords<br>Slice uses a number of keywords, which must be spelled in lowercase. For example, class and dictionary are keywords and must be spelled as shown. There are three exceptions to this lowercase rule: LocalObject, Object and Value are keywords and must be capitalized as shown.</p>
<p>Slice 使用许多关键字，这些关键字必须以小写形式拼写。 例如，class 和dictionary 是关键字，必须按所示拼写。 此小写规则有三个例外：LocalObject、Object 和 Value 是关键字，必须大写，如图所示。</p>
<p>Identifiers</p>
<p>Identifiers begin with an alphabetic character followed by any number of alphabetic characters or digits. Underscores are also permitted in identifiers with the following limitations:</p>
<p>an identifier cannot begin or end with an underscore<br>an identifier cannot contain multiple consecutive underscores<br>Given these rules, the identifier get_account_name is legal but not <em>account, account</em>, or get__account.</p>
<p>Slice identifiers are restricted to the ASCII range of alphabetic characters and cannot contain non-English letters, such as Å. (Supporting non-ASCII identifiers would make it very difficult to map Slice to target languages that lack support for this feature.)</p>
<p>标识符以字母字符开头，后跟任意数量的字母字符或数字。 标识符中也允许使用下划线，但有以下限制：</p>
<p>标识符不能以下划线开头或结尾<br>标识符不能包含多个连续的下划线<br>根据这些规则，标识符 get_account_name 合法，但 <em>account、account</em> 或 get__account 不合法。</p>
<p>Slice标识符仅限于 ASCII 范围内的字母字符，不能包含非英文字母，例如 Å。 （支持非 ASCII 标识符将使将 Slice 映射到不支持此功能的目标语言变得非常困难。）</p>
<p>Case Sensitivity</p>
<p>Identifiers are case-insensitive but must be capitalized consistently. For example, TimeOfDay and TIMEOFDAY are considered the same identifier within a naming scope. However, Slice enforces consistent capitalization. After you have introduced an identifier, you must capitalize it consistently throughout; otherwise, the compiler will reject it as illegal. This rule exists to permit mappings of Slice to languages that ignore case in identifiers as well as to languages that treat differently capitalized identifiers as distinct.</p>
<p>标识符不区分大小写，但大小写必须一致。 例如，TimeOfDay 和 TIMEOFDAY 在命名范围内被视为相同的标识符。 然而，Slice 强制使用一致的大小写。 引入标识符后，必须始终将其大写； 否则，编译器将认为它是非法的而拒绝它。 存在此规则是为了允许将 Slice 映射到忽略标识符大小写的语言以及将不同大写标识符视为不同的语言。</p>
<p>Identifiers That Are Keywords</p>
<p>You can define Slice identifiers that are keywords in one or more implementation languages. For example, switch is a perfectly good Slice identifier but is a C++ and Java keyword. Each language mapping defines rules for dealing with such identifiers. The solution typically involves using a prefix to map away from the keyword. For example, the Slice identifier switch is mapped to _cpp_switch in C++ and _switch in Java.</p>
<p>The rules for dealing with keywords can result in hard-to-read source code. Identifiers such as native, throw, or export will clash with C++ or Java keywords (or both). To make life easier for yourself and others, try to avoid Slice identifiers that are implementation language keywords. Keep in mind that mappings for new languages may be added to Ice in the future. While it is not reasonable to expect you to compile a list of all keywords in all popular programming languages, you should make an attempt to avoid at least common keywords. Slice identifiers such as self, import, and while are definitely not a good idea.</p>
<p>您可以定义作为一种或多种实现语言中的关键字的Slice标识符。 例如，switch 是一个非常好的 Slice 标识符，但却是一个 C++ 和 Java 关键字。 每种语言映射都定义了处理此类标识符的规则。 该解决方案通常涉及使用前缀来映射关键字。 例如，Slice 标识符 switch 在 C++ 中映射为 _cpp_switch，在 Java 中映射为 _switch。</p>
<p>处理关键字的规则可能会导致源代码难以阅读。 诸如native、 throw 或export 之类的标识符将与C++ 或Java 关键字（或两者）发生冲突。 为了让您和他人的生活更轻松，请尽量避免使用作为实现语言关键字的Slice标识符。 请记住，将来可能会将新语言的映射添加到 Ice 中。 虽然期望您编译所有流行编程语言中的所有关键字的列表是不合理的，但您应该尝试至少避免常见关键字。 self、import 和 while 等Slice标识符绝对不是一个好主意。</p>
<p>Escaped Identifiers</p>
<p>It is possible to use a Slice keyword as an identifier by prefixing the keyword with a backslash, for example:</p>
<p>可以通过在关键字前面加上反斜杠来使用 Slice 关键字作为标识符，例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">dictionary</span>     <span class="comment">// Error!</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">struct</span> \dictionary    <span class="comment">// OK</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">struct</span> \foo           <span class="comment">// Legal, same as &quot;struct foo&quot;</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>The backslash escapes the usual meaning of a keyword; in the preceding example, \dictionary is treated as the identifier dictionary. The escape mechanism exists to permit keywords to be added to the Slice language over time with minimal disruption to existing specifications: if a pre-existing specification happens to use a newly-introduced keyword, that specification can be fixed by simply prepending a backslash to the new keyword. Note that, as a matter of style, you should avoid using Slice keywords as identifiers (even though the backslash escapes allow you to do this).</p>
<p>It is legal (though redundant) to precede an identifier that is not a keyword with a backslash — the backslash is ignored in that case.</p>
<p>反斜杠转义了关键字的通常含义； 在前面的示例中，\dictionary 被视为标识符dictionary 。 转义机制的存在是为了允许关键字随着时间的推移添加到 Slice 语言中，同时对现有规范的干扰最小：如果预先存在的规范碰巧使用了新引入的关键字，则只需在该规范前面添加一个反斜杠即可修复该规范。 新的关键字。 请注意，就风格而言，您应该避免使用 Slice 关键字作为标识符（即使反斜杠转义允许您这样做）。</p>
<p>在不是关键字的标识符前面加上反斜杠是合法的（尽管是多余的）——在这种情况下，反斜杠将被忽略。</p>
<p>Reserved Identifiers</p>
<p>Slice reserves the identifier Ice and all identifiers beginning with Ice (in any capitalization) for the Ice implementation. For example, if you try to define a type named Icecream, the Slice compiler will issue an error message.</p>
<p>Slice 为 Ice 实现保留了标识符 Ice 和所有以 Ice 开头的标识符（任何大小写）。 例如，如果您尝试定义名为 Icecream 的类型，Slice 编译器将发出错误消息。</p>
<p>You can suppress this behavior by using the ice-prefix Slice metadata directive, which enables definition of identifiers beginning with Ice. However, do not use this directive unless you are compiling the Slice definitions for the Ice run time itself.</p>
<p>您可以使用ice-prefix Slice元数据指令来抑制此行为，该指令允许定义以Ice开头的标识符。 但是，除非您正在为 Ice 运行时本身编译 Slice 定义，否则不要使用此指令。</p>
<p>Slice identifiers ending in any of the suffixes Async, Disp, Helper, Holder, Prx, and Ptr are also reserved. These endings are used by the various language mappings and are reserved to prevent name clashes in the generated code.</p>
<p>以任何后缀 Async、Disp、Helper、Holder、Prx 和 Ptr 结尾的Slice标识符也被保留。 这些结尾由各种语言映射使用，并被保留以防止生成的代码中发生名称冲突。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://qianqians.github.io/2023/11/24/ice_Slice_Source_Files/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="qianqians">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="qianqians'blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/11/24/ice_Slice_Source_Files/" class="post-title-link" itemprop="url">Slice Source Files</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2023-11-24 22:04:03 / 修改时间：22:31:58" itemprop="dateCreated datePublished" datetime="2023-11-24T22:04:03+08:00">2023-11-24</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/ice/" itemprop="url" rel="index"><span itemprop="name">ice</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>Slice defines a number of rules for the naming and contents of Slice source files.</p>
<p>Slice 定义了许多 Slice 源文件的命名和内容的规则。</p>
<p>File Naming<br>Files containing Slice definitions must end in a .ice file extension, for example, Clock.ice is a valid file name. Other file extensions are rejected by the compilers.</p>
<p>For case-insensitive file systems, the file extension may be written as uppercase or lowercase, so Clock.ICE is legal. For case-sensitive file systems (such as Unix), Clock.ICE is illegal. (The extension must be in lowercase.)</p>
<p>文件命名<br>包含Slice定义的文件必须以 .ice 文件扩展名结尾，例如，Clock.ice 是有效的文件名。 其他文件扩展名会被编译器拒绝。</p>
<p>对于不区分大小写的文件系统，文件扩展名可以写为大写或小写，因此 Clock.ICE 是合法的。 对于区分大小写的文件系统（例如Unix），Clock.ICE 是非法的。 （扩展名必须为小写。）</p>
<p>File Format<br>Slice is a free-form language so you can use spaces, horizontal and vertical tab stops, form feeds, and newline characters to lay out your code in any way you wish. (White space characters are token separators). Slice does not attach semantics to the layout of a definition. You may wish to follow the style we have used for the Slice examples throughout this book.</p>
<p>Slice files can be ASCII text files or use the UTF-8 character encoding with an optional byte order marker (BOM) at the beginning of each file. However, Slice identifiers are limited to ASCII letters and digits; non-ASCII letters can appear only in comments and string literals.</p>
<p>文件格式<br>Slice 是一种自由格式的语言，因此您可以使用空格、水平和垂直制表位、换页符和换行符以您希望的任何方式布局代码。 （空白字符是标记分隔符）。 Slice 不会将语义附加到定义的布局上。 您可能希望遵循我们在本书中使用的 Slice 示例的风格。</p>
<p>Slice文件可以是 ASCII 文本文件，也可以使用 UTF-8 字符编码，并在每个文件的开头带有可选的字节顺序标记 (BOM)。 然而，Slice标识符仅限于 ASCII 字母和数字； 非 ASCII 字母只能出现在注释和字符串文字中。</p>
<p>Preprocessing<br>Slice supports the same preprocessor directives as C++, so you can use directives such as #include and macro definitions. However, Slice permits #include directives only at the beginning of a file, before any Slice definitions.</p>
<p>If you use #include directives, it is a good idea to protect them with guards to prevent double inclusion of a file:</p>
<p>预处理<br>Slice 支持与 C++ 相同的预处理器指令，因此您可以使用 #include 和宏定义等指令。 但是，Slice 只允许在文件开头、任何 Slice 定义之前使用 #include 指令。</p>
<p>如果您使用 #include 指令，最好使用防护装置来保护它们，以防止文件的双重包含：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// File Clock.ice</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _CLOCK_ICE</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _CLOCK_ICE</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// #include directives here...</span></span><br><span class="line"><span class="comment">// Definitions here...</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> _CLOCK_ICE</span></span><br></pre></td></tr></table></figure>

<p>The following #pragma directive offers a simpler way to achieve the same result:</p>
<p>以下 #pragma 指令提供了一种更简单的方法来实现相同的结果：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// File Clock.ice</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// #include directives here...</span></span><br><span class="line"><span class="comment">// Definitions here...</span></span><br></pre></td></tr></table></figure>

<p>#include directives permit a Slice definition to use types defined in a different source file. The Slice compilers parse all of the code in a source file, including the code in subordinate #include files. However, the compilers generate code only for the top-level file(s) nominated on the command line. You must separately compile subordinate #include files to obtain generated code for all the files that make up your Slice definition.</p>
<p>Note that you should avoid #include with double quotes:</p>
<p>#include 指令允许 Slice 定义使用不同源文件中定义的类型。 Slice 编译器解析源文件中的所有代码，包括从属 #include 文件中的代码。 但是，编译器仅为命令行上指定的顶级文件生成代码。 您必须单独编译从属 #include 文件，以获得构成 Slice 定义的所有文件的生成代码。</p>
<p>请注意，您应该避免使用双引号#include：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Clock.ice&quot;</span> <span class="comment">// Not recommended!</span></span></span><br></pre></td></tr></table></figure>

<p>While double quotes will work, the directory in which the preprocessor tries to locate the file can vary depending on the operating system, so the included file may not always be found where you expect it. Instead, use angle brackets (&lt;&gt;); you can control which directories are searched for the file with the -I option of the Slice compiler.</p>
<p>Also note that, if you include a path separator in a #include directive, you must use a forward slash:</p>
<p>虽然双引号可以工作，但预处理器尝试在其中查找文件的目录可能会因操作系统而异，因此可能并不总是能在您期望的位置找到包含的文件。 相反，请使用尖括号 (&lt;&gt;)； 您可以使用 Slice 编译器的 -I 选项来控制在哪些目录中搜索文件。</p>
<p>另请注意，如果在 #include 指令中包含路径分隔符，则必须使用正斜杠：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;SliceDefs/Clock.ice&gt;</span>  <span class="comment">// OK</span></span></span><br></pre></td></tr></table></figure>

<p>You cannot use a backslash in #include directives:</p>
<p>您不能在 #include 指令中使用反斜杠：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;SliceDefs\Clock.ice&gt;</span>  <span class="comment">// Illegal</span></span></span><br></pre></td></tr></table></figure>

<p>Detecting Ice Versions<br>The Slice compilers define the preprocessor macro <strong>ICE_VERSION</strong> with a numeric representation of the Ice version. The value of this macro is the same as the C++ macro ICE_INT_VERSION. You can use this macro to make your Slice definitions backward-compatible with older Ice releases, while still taking advantage of newer Ice features when possible. For example, the Slice definition shown below makes use of custom enumerator values:</p>
<p>检测 Ice 版本<br>Slice 编译器使用 Ice 版本的数字表示来定义预处理器宏 <strong>ICE_VERSION</strong> 。 该宏的值与 C++ 宏 ICE_INT_VERSION 相同。 您可以使用此宏使您的 Slice 定义向后兼容较旧的 Ice 版本，同时尽可能利用较新的 Ice 功能。 例如，下面显示的 Slice 定义使用自定义枚举值：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">if</span> defined(__ICE_VERSION__) &amp;&amp; __ICE_VERSION__ &gt;= 030500</span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">Fruit</span> &#123; Apple, Pear = <span class="number">3</span>, Orange &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="keyword">enum</span> Fruit &#123; Apple, Pear, Orange &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>Although this example is intended to show how to use the ICE_VERSION macro, it also highlights a potential pitfall that you must be aware of when trying to maintain backward compatibility: the two definitions of Fruit are not wire-compatible. </p>
<p>尽管此示例旨在展示如何使用 ICE_VERSION 宏，但它也强调了在尝试保持向后兼容性时必须注意的潜在陷阱：Fruit 的两个定义不兼容。</p>
<p>Detecting Slice Compilers<br>Each Slice compiler defines its own macro so that you can customize your Slice code for certain language mappings. The macro name is <strong><compiler name in upper case></strong>, such as <strong>SLICE2CPP</strong> and <strong>SLICE2MATLAB</strong> for slice2cpp resp. slice2matlab.</p>
<p>检测Slice编译器<br>每个 Slice 编译器都定义自己的宏，以便您可以针对某些语言映射自定义 Slice 代码。 宏名称为 __&lt;大写的编译器名称&gt;__，例如 slice2cpp 的宏名称为 <strong>SLICE2CPP</strong> 和 __SLICE2MATLAB__。 slice2matlab。</p>
<p>For example, .NET developers may elect to avoid the use of default values for structure members because the presence of default values changes the C# mapping of the structure from struct to class:</p>
<p>例如，.NET 开发人员可能会选择避免对结构成员使用默认值，因为默认值的存在会更改结构从结构到类的 C# 映射：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Record</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> __SLICE2CS__</span></span><br><span class="line">    <span class="type">bool</span> active;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="type">bool</span> active = <span class="literal">true</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Definition Order<br>Slice constructs, such as modules, interfaces, or type definitions, can appear in any order you prefer. However, identifiers must be declared before they can be used.</p>
<p>定义顺序<br>Slice构造（例如模块、接口或类型定义）可以按您喜欢的任何顺序出现。 但是，标识符在使用之前必须先声明。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://qianqians.github.io/2023/11/22/ice_Slice_Compilation/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="qianqians">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="qianqians'blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/11/22/ice_Slice_Compilation/" class="post-title-link" itemprop="url">Slice Compilation</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2023-11-22 21:36:12 / 修改时间：21:52:05" itemprop="dateCreated datePublished" datetime="2023-11-22T21:36:12+08:00">2023-11-22</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/ice/" itemprop="url" rel="index"><span itemprop="name">ice</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>Slice Compilation</p>
<p>Compilation<br>A Slice compiler produces source files that must be combined with application code to produce client and server executables.</p>
<p>Slice 编译器生成的源文件必须与应用程序代码组合才能生成客户端和服务器可执行文件。</p>
<p>Single Development Environment for Client and Server</p>
<p>The figure below shows the situation when both client and server are developed in C++. The Slice compiler generates two files from a Slice definition in a source file Printer.ice: a header file (Printer.h) and a source file (Printer.cpp)</p>
<p>下图展示了客户端和服务器端均采用C++开发时的情况。 Slice 编译器根据源文件 Printer.ice 中的 Slice 定义生成两个文件：头文件 (Printer.h) 和源文件 (Printer.cpp)</p>
<p><img src="https://doc.zeroc.com/ice/files/3.7/14026220/25591829/1/1515168282000/Client_server_same_development_environment.gif" alt="Alt text"></p>
<p>Development process if client and server share the same development environment.</p>
<p>The Printer.h header file contains definitions that correspond to the types used in the Slice definition. It is included in the source code of both client and server to ensure that client and server agree about the types and interfaces used by the application.<br>The Printer.cpp source file provides an API to the client for sending messages to remote objects. The client source code (Client.cpp, written by the client developer) contains the client-side application logic. The generated source code and the client code are compiled and linked into the client executable.</p>
<p>客户端和服务器共享相同开发环境的开发流程。</p>
<p>Printer.h 头文件包含与 Slice 定义中使用的类型相对应的定义。 它包含在客户端和服务器的源代码中，以确保客户端和服务器就应用程序使用的类型和接口达成一致。<br>Printer.cpp 源文件向客户端提供 API，用于将消息发送到远程对象。 客户端源代码（Client.cpp，由客户端开发人员编写）包含客户端应用程序逻辑。 生成的源代码和客户端代码被编译并链接到客户端可执行文件中。</p>
<p>The Printer.cpp source file also contains source code that provides an up-call interface from the Ice run time into the server code written by the developer and provides the connection between the networking layer of Ice and the application code. The server implementation file (Server.cpp, written by the server developer) contains the server-side application logic (the object implementations, properly termed servants). The generated source code and the implementation source code are compiled and linked into the server executable.</p>
<p>Printer.cpp 源文件还包含源代码，该源代码提供从 Ice 运行时到开发人员编写的服务器代码的上行调用接口，并提供 Ice 网络层和应用程序代码之间的连接。 服务器实现文件（Server.cpp，由服务器开发人员编写）包含服务器端应用程序逻辑（对象实现，正确称为servants）。 生成的源代码和实现源代码被编译并链接到服务器可执行文件中。</p>
<p>Both client and server also link with an Ice library that provides the necessary run-time support.</p>
<p>客户端和服务器还与提供必要的运行时支持的 Ice 库链接。</p>
<p>You are not limited to a single implementation of a client or server. For example, you can build multiple servers, each of which implements the same interfaces but uses different implementations (for example, with different performance characteristics). Multiple such server implementations can coexist in the same system. This arrangement provides one fundamental scalability mechanism in Ice: if you find that a server process starts to bog down as the number of objects increases, you can run an additional server for the same interfaces on a different machine. Such federated servers provide a single logical service that is distributed over a number of processes on different machines. Each server in the federation implements the same interfaces but hosts different object instances. (Of course, federated servers must somehow ensure consistency of any databases they share across the federation.)</p>
<p>您不限于客户端或服务器的单一实现。 例如，您可以构建多个服务器，每个服务器都实现相同的接口，但使用不同的实现（例如，具有不同的性能特征）。 多个此类服务器实现可以共存于同一系统中。 这种安排在 Ice 中提供了一种基本的可扩展性机制：如果您发现服务器进程随着对象数量的增加而开始陷入困境，您可以为不同机器上的相同接口运行额外的服务器。 此类联合服务器提供分布在不同机器上的多个进程上的单一逻辑服务。 联合中的每个服务器都实现相同的接口，但托管不同的对象实例。 （当然，联合服务器必须以某种方式确保它们在联合中共享的任何数据库的一致性。）</p>
<p>Ice also provides support for replicated servers. Replication permits multiple servers to each implement the same set of object instances. This improves performance and scalability (because client load can be shared over a number of servers) as well as redundancy (because each object is implemented in more than one server).</p>
<p>Ice 还提供对复制服务器的支持。 复制允许多个服务器各自实现同一组对象实例。 这提高了性能和可伸缩性（因为客户端负载可以在多个服务器上共享）以及冗余（因为每个对象都在多个服务器中实现）。</p>
<p>Different Development Environments for Client and Server</p>
<p>Client and server cannot share any source or binary components if they are developed in different languages. For example, a client written in Java cannot include a C++ header file.</p>
<p>如果客户端和服务器使用不同语言开发，则不能共享任何源代码或二进制组件。 例如，用 Java 编写的客户端不能包含 C++ 头文件。</p>
<p>This figure shows the situation when a client written in Java and the corresponding server is written in C++. In this case, the client and server developers are completely independent, and each uses his or her own development environment and language mapping. The only link between client and server developers is the Slice definition each one uses.</p>
<p>该图显示了当客户端用Java编写而相应的服务器用C++编写时的情况。 在这种情况下，客户端和服务器开发人员是完全独立的，并且各自使用自己的开发环境和语言映射。 客户端和服务器开发人员之间的唯一联系是各自使用的 Slice 定义。</p>
<p><img src="https://doc.zeroc.com/ice/files/3.7/14026220/25591831/1/1515168283000/Development_process_different_development_environment.gif" alt="Alt text"></p>
<p>Development process for different development environments.</p>
<p>For Java, the slice compiler creates a number of files whose names depend on the names of various Slice constructs. (These files are collectively referred to as *.java in the above figure.)</p>
<p>针对不同开发环境的开发流程。</p>
<p>对于 Java，slice编译器创建许多文件，其名称取决于各种 Slice 构造的名称。 （这些文件在上图中统称为*.java。）</p>
<p>Slice Compilation and your Build Environment</p>
<p>One way to integrate Slice compilation in your build system is to compile your Slice files manually, and then keep (check-in) the generated files like other source files. Later on, each time you change a Slice file, you have to remember to recompile this Slice file and update the generated files. While simple, this approach can lead to inconsistencies and bugs if you forget to recompile a modified Slice file.</p>
<p>将 Slice 编译集成到构建系统中的一种方法是手动编译 Slice 文件，然后像其他源文件一样保留（签入）生成的文件。 以后，每次更改 Slice 文件时，都必须记住重新编译该 Slice 文件并更新生成的文件。 虽然简单，但如果您忘记重新编译修改后的 Slice 文件，这种方法可能会导致不一致和错误。</p>
<p>We recommend you use instead an Ice Builder for your build environment to manage the compilation of your Slice files. An Ice Builder is a simple plug-in or task for your build environment that compiles or recompiles Slice files when it detects the corresponding generated files are missing or out of date. A Builder performs this Slice compilation by invoking the Slice compiler for the target programming language–it does compile the files itself and usually supports several versions of Ice.</p>
<p>我们建议您在构建环境中使用 Ice Builder 来管理 Slice 文件的编译。 Ice Builder 是一个适用于构建环境的简单插件或任务，当它检测到相应的生成文件丢失或过期时，它会编译或重新编译 Slice 文件。 Builder 通过调用目标编程语言的 Slice 编译器来执行此 Slice 编译 - 它本身会编译文件，并且通常支持多个版本的 Ice。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://qianqians.github.io/2023/11/21/ice_slice/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="qianqians">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="qianqians'blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/11/21/ice_slice/" class="post-title-link" itemprop="url">Slice</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2023-11-21 22:26:12 / 修改时间：22:33:46" itemprop="dateCreated datePublished" datetime="2023-11-21T22:26:12+08:00">2023-11-21</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/ice/" itemprop="url" rel="index"><span itemprop="name">ice</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>Slice (Specification Language for Ice)</p>
<p>Each Ice object has an interface with a number of operations. Interfaces, operations, and the types of data that are exchanged between client and server are defined using the Slice language. Slice allows you to define the client-server contract in a way that is independent of a specific programming language, such as C++, Java, or C#. The Slice definitions are compiled by a compiler into an API for a specific programming language, that is, the part of the API that is specific to the interfaces and types you have defined consists of generated code.</p>
<p>每个 Ice 对象都有一个包含许多操作的接口。 客户端和服务器之间交换的接口、操作和数据类型都是使用 Slice 语言定义的。 Slice 允许您以独立于特定编程语言（例如 C++、Java 或 C#）的方式定义客户端-服务器协定。 Slice 定义由编译器编译为特定编程语言的 API，即 API 中特定于您定义的接口和类型的部分由生成的代码组成。</p>
<p>The Slice Language</p>
<p>Slice (Specification Language for Ice) is the fundamental abstraction mechanism for separating object interfaces from their implementations. Slice establishes a contract between client and server that describes the interfaces, operations and parameter types used by an application. This description is independent of the implementation language, so it does not matter whether the client is written in the same language as the server.</p>
<p>Even though Slice is an acronym, it is pronounced as a single syllable, like a slice of bread.</p>
<p>Slice definitions are compiled for a particular implementation language by a compiler. The language-specific Slice compiler translates the language-independent Slice definitions into language-specific type definitions and APIs. These types and APIs are used by the developer to provide application functionality and to interact with Ice. The translation algorithms for various implementation languages are known as language mappings, and Ice provides a number of language mappings (for C++, C#, Java, JavaScript, Python and more).</p>
<p>Because Slice describes interfaces and types (but not implementations), it is a purely declarative language; there is no way to write executable statements in Slice.</p>
<p>Slice definitions focus on object interfaces, the operations supported by those interfaces, and exceptions that may be raised by operations. This requires quite a bit of supporting machinery; in particular, much of Slice is concerned with the definition of data types. This is because data can be exchanged between client and server only if their types are defined in Slice. You cannot exchange arbitrary C++ data between a client and a server because it would destroy the language independence of Ice. However, you can always create a Slice type definition that corresponds to the C++ data you want to send, and then you can transmit the Slice type.</p>
<p>We present the full syntax and semantics of Slice here. Because much of Slice is based on C++ and Java, we focus on those areas where Slice differs from C++ or Java or constrains the equivalent C++ or Java feature in some way. Slice features that are identical to C++ and Java are mentioned mostly by example.</p>
<p>Slice（Ice 规范语言）是将对象接口与其实现分离的基本抽象机制。 Slice 在客户端和服务器之间建立契约，描述应用程序使用的接口、操作和参数类型。 这种描述与实现语言无关，因此客户端是否与服务器使用相同的语言编写并不重要。</p>
<p>尽管 Slice 是一个缩写词，但它的发音是一个音节，就像一片面包一样。</p>
<p>Slice定义由编译器针对特定的实现语言进行编译。 特定于语言的 Slice 编译器将独立于语言的 Slice 定义转换为特定于语言的类型定义和 API。 开发人员使用这些类型和 API 来提供应用程序功能并与 Ice 进行交互。 各种实现语言的翻译算法称为语言映射，Ice 提供了多种语言映射（针对 C++、C#、Java、JavaScript、Python 等）。</p>
<p>因为 Slice 描述了接口和类型（但不描述实现），所以它是一种纯粹的声明性语言； 无法在 Slice 中编写可执行语句。</p>
<p>Slice定义重点关注对象接口、这些接口支持的操作以及操作可能引发的异常。 这需要相当多的配套机械； 特别是，Slice 的大部分内容都与数据类型的定义有关。 这是因为只有在 Slice 中定义了数据类型，客户端和服务器之间才能交换数据。 您不能在客户端和服务器之间交换任意 C++ 数据，因为这会破坏 Ice 的语言独立性。 但是，您始终可以创建与要发送的 C++ 数据相对应的 Slice 类型定义，然后就可以传输该 Slice 类型。</p>
<p>我们在这里展示 Slice 的完整语法和语义。 由于 Slice 的大部分内容都基于 C++ 和 Java，因此我们重点关注 Slice 与 C++ 或 Java 不同的领域，或者以某种方式限制等效的 C++ 或 Java 功能的领域。 与 C++ 和 Java 相同的 Slice 功能主要通过示例来提及。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://qianqians.github.io/2023/11/20/ice_Terminology/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="qianqians">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="qianqians'blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/11/20/ice_Terminology/" class="post-title-link" itemprop="url">Terminology</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-11-20 22:55:48" itemprop="dateCreated datePublished" datetime="2023-11-20T22:55:48+08:00">2023-11-20</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-11-21 22:33:29" itemprop="dateModified" datetime="2023-11-21T22:33:29+08:00">2023-11-21</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/ice/" itemprop="url" rel="index"><span itemprop="name">ice</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>Every computing technology creates its own vocabulary as it evolves. Ice is no exception. However, the amount of new jargon used by Ice is minimal. Rather than inventing new terms, we have used existing terminology as much as possible. If you have used another middleware technology in the past, you will be familiar with much of what follows. (However, we suggest you at least skim the material because a few terms used by Ice do differ from the corresponding terms used by other middleware.)</p>
<p>每种计算技术都会随着其发展而创建自己的词汇表。 Ice也不例外。 然而，Ice 使用的新术语数量很少。 我们没有发明新术语，而是尽可能多地使用现有术语。 如果您过去使用过另一种中间件技术，您将会熟悉接下来的大部分内容。 （但是，我们建议您至少浏览一下材料，因为 Ice 使用的一些术语确实与其他中间件使用的相应术语不同。）</p>
<p>Clients and Servers<br>The terms client and server are not firm designations for particular parts of an application; rather, they denote roles that are taken by parts of an application for the duration of a request:</p>
<p>Clients are active entities. They issue requests for service to servers.<br>Servers are passive entities. They provide services in response to client requests.<br>Frequently, servers are not “pure” servers, in the sense that they never issue requests and only respond to requests. Instead, servers often act as a server on behalf of some client but, in turn, act as a client to another server in order to satisfy their client’s request.</p>
<p>Similarly, clients often are not “pure” clients, in the sense that they only request service from an object. Instead, clients are frequently client-server hybrids. For example, a client might start a long-running operation on a server; as part of starting the operation, the client can provide a callback object to the server that is used by the server to notify the client when the operation is complete. In that case, the client acts as a client when it starts the operation, and as a server when it is notified that the operation is complete.</p>
<p>Such role reversal is common in many systems, so, frequently, client-server systems could be more accurately described as peer-to-peer systems.</p>
<p>客户端和服务器<br>术语“客户端”和“服务器”并不是应用程序特定部分的固定名称。 相反，它们表示请求期间应用程序的各个部分所扮演的角色：</p>
<p>客户是活跃的实体。 他们向服务器发出服务请求。<br>服务器是被动实体。 他们根据客户的要求提供服务。<br>通常，服务器不是“纯”服务器，因为它们并不是从不发出请求而仅响应请求。 相反，服务器通常充当代表某个客户端的服务器，但反过来又充当另一个服务器的客户端以满足其客户端的请求。</p>
<p>类似地，客户端通常不是“纯粹”客户端，因为它们仅向对象请求服务。 相反，客户端通常是客户端-服务器混合体。 例如，客户端可能在服务器上启动长时间运行的操作； 作为启动操作的一部分，客户端可以向服务器提供回调对象，服务器使用该对象在操作完成时通知客户端。 在这种情况下，客户端在开始操作时充当客户端，并在收到操作完成通知时充当服务器。</p>
<p>这种角色反转在许多系统中很常见，因此，客户端-服务器系统通常可以更准确地描述为对等系统。</p>
<p>Ice Objects<br>An Ice object is a conceptual entity, or abstraction. An Ice object can be characterized by the following points:</p>
<p>An Ice object is an entity in the local or a remote address space that can respond to client requests.<br>A single Ice object can be instantiated in a single server or, redundantly, in multiple servers. If an object has multiple simultaneous instantiations, it is still a single Ice object.<br>Each Ice object has one or more interfaces. An interface is a collection of named operations that are supported by an object. Clients issue requests by invoking operations.<br>An operation has zero or more parameters as well as a return value. Parameters and return values have a specific type. Parameters are named and have a direction: in-parameters are initialized by the client and passed to the server; out-parameters are initialized by the server and passed to the client. (The return value is simply a special out-parameter.)<br>An Ice object has a distinguished interface, known as its main interface. In addition, an Ice object can provide zero or more alternate interfaces, known as facets. Clients can select among the facets of an object to choose the interface they want to work with.<br>Each Ice object has a unique object identity. An object’s identity is an identifying value that distinguishes the object from all other objects. The Ice object model assumes that object identities are globally unique, that is, no two objects within an Ice communication domain can have the same object identity.</p>
<p>In practice, you need not use object identities that are globally unique, such as UUIDs, only identities that do not clash with any other identity within your domain of interest. However, there are architectural advantages to using globally unique identifiers, which we explore in our discussion of object life cycle.</p>
<p>Ice对象<br>Ice对象是一个概念实体或抽象。 Ice对象可以具有以下几点特征：</p>
<p>Ice对象是本地或远程地址空间中可以响应客户端请求的实体。<br>单个Ice对象可以在单个服务器中实例化，或者冗余地在多个服务器中实例化。 如果一个对象有多个同时实例化，它仍然是单个Ice对象。<br>每个Ice对象都有一个或多个接口。 接口是对象支持的命名操作的集合。 客户端通过调用操作来发出请求。<br>操作具有零个或多个参数以及返回值。 参数和返回值具有特定的类型。 参数有名字并且有方向：内参数由客户端初始化并传递给服务器； 输出参数由服务器初始化并传递给客户端。 （返回值只是一个特殊的输出参数。）<br>Ice对象有一个独特的接口，称为主接口。 此外，Ice对象可以提供零个或多个备用接口，称为构面。客户可以在对象的各个方面进行选择，以选择他们想要使用的界面。<br>每个Ice对象都有一个唯一的对象标识。 对象的标识是将该对象与所有其他对象区分开来的标识值。 Ice对象模型假设对象标识是全局唯一的，即Ice通信域内的两个对象不能具有相同的对象标识。</p>
<p>在实践中，您不需要使用全局唯一的对象标识，例如 UUID，只需使用不与您感兴趣的域内的任何其他标识冲突的标识即可。 然而，使用全局唯一标识符具有架构优势，我们在对象生命周期的讨论中对此进行了探讨。</p>
<p>Proxies<br>For a client to be able to contact an Ice object, the client must hold a proxy for the Ice object. A proxy is an artifact that is local to the client’s address space; it represents the (possibly remote) Ice object for the client. A proxy acts as the local ambassador for an Ice object: when the client invokes an operation on the proxy, the Ice run time:</p>
<p>Locates the Ice object<br>Activates the Ice object’s server if it is not running<br>Activates the Ice object within the server<br>Transmits any in-parameters to the Ice object<br>Waits for the operation to complete<br>Returns any out-parameters and the return value to the client (or throws an exception in case of an error)<br>A proxy encapsulates all the necessary information for this sequence of steps to take place. In particular, a proxy contains:</p>
<p>Addressing information that allows the client-side run time to contact the correct server<br>An object identity that identifies which particular object in the server is the target of a request<br>An optional facet identifier that determines which particular facet of an object the proxy refers to</p>
<p>代理<br>为了使客户端能够联系Ice对象，客户端必须持有Ice对象的代理。 代理是客户端地址空间本地的工件； 它代表客户端的（可能是远程的Ice对象。 代理充当Ice对象的本地大使：当客户端调用代理上的操作时，Ice 运行时间：</p>
<p>找到Ice对象<br>如果Ice对象的服务器未运行，则激活它<br>激活服务器内的Ice对象<br>将任何内参数传输到Ice对象<br>等待操作完成<br>将任何输出参数和返回值返回给客户端（或者在出现错误时抛出异常）<br>代理封装了执行这一系列步骤所需的所有必要信息。 特别是，代理包含：</p>
<p>允许客户端运行时联系正确服务器的寻址信息<br>对象标识，用于标识服务器中哪个特定对象是请求的目标<br>可选的方面标识符，用于确定代理引用对象的哪个特定方面</p>
<p>Stringified Proxies<br>The information in a proxy can be expressed as a string. For example, the string:</p>
<p>SimplePrinter:default -p 10000<br>is a human-readable representation of a proxy. The Ice run time provides API calls that allow you to convert a proxy to its stringified form and vice versa. This is useful, for example, to store proxies in database tables or text files.</p>
<p>Provided that a client knows the identity of an Ice object and its addressing information, it can create a proxy “out of thin air” by supplying that information. In other words, no part of the information inside a proxy is considered opaque; a client needs to know only an object’s identity, addressing information, and (to be able to invoke an operation) the object’s type in order to contact the object.</p>
<p>字符串化代理<br>代理中的信息可以表示为字符串。 例如，字符串：</p>
<p>SimplePrinter：default -p 10000<br>是代理的人类可读表示。 Ice运行时提供API调用，允许您将代理转换为其字符串化形式，反之亦然。 例如，这对于将代理存储在数据库表或文本文件中非常有用。</p>
<p>如果客户端知道 Ice 对象的身份及其寻址信息，它就可以通过提供该信息“凭空”创建代理。 换句话说，代理内部的信息没有任何部分被认为是不透明的； 客户端只需要知道对象的身份、寻址信息和（能够调用操作）对象的类型即可联系该对象。</p>
<p>Direct Proxies<br>A direct proxy is a proxy that embeds an object’s identity, together with the address at which its server runs. The address is completely specified by:</p>
<p>a protocol identifier (such TCP/IP or UDP)<br>a protocol-specific address (such as a host name and port number)<br>To contact the object denoted by a direct proxy, the Ice run time uses the addressing information in the proxy to contact the server; the identity of the object is sent to the server with each request made by the client.</p>
<p>直接代理<br>直接代理是嵌入对象身份及其服务器运行地址的代理。 地址完全由以下方式指定：</p>
<p>协议标识符（例如 TCP/IP 或 UDP）<br>特定于协议的地址（例如主机名和端口号）<br>为了联系直接代理所表示的对象，Ice runtime 使用代理中的寻址信息来联系服务器； 对象的身份随着客户端发出的每个请求发送到服务器。</p>
<p>Indirect Proxies<br>An indirect proxy has two forms. It may provide only an object’s identity, or it may specify an identity together with an object adapter identifier. An object that is accessible using only its identity is called a well-known object, and the corresponding proxy is a well-known proxy. For example, the string:</p>
<p>SimplePrinter<br>is a valid proxy for a well-known object with the identity SimplePrinter.</p>
<p>An indirect proxy that includes an object adapter identifier has the stringified form</p>
<p>SimplePrinter@PrinterAdapter<br>Any object of the object adapter can be accessed using such a proxy, regardless of whether that object is also a well-known object.</p>
<p>Notice that an indirect proxy contains no addressing information. To determine the correct server, the client-side run time passes the proxy information to a location service. In turn, the location service uses the object identity or the object adapter identifier as the key in a lookup table that contains the address of the server and returns the current server address to the client. The client-side run time now knows how to contact the server and dispatches the client request as usual.</p>
<p>The entire process is similar to the mapping from Internet domain names to IP address by the Domain Name Service (DNS): when we use a domain name, such as <a target="_blank" rel="noopener" href="http://www.zeroc.com/">www.zeroc.com</a>, to look up a web page, the host name is first resolved to an IP address behind the scenes and, once the correct IP address is known, the IP address is used to connect to the server. With Ice, the mapping is from an object identity or object adapter identifier to a protocol-address pair, but otherwise very similar. The client-side run time knows how to contact the location service via configuration (just as web browsers know which DNS server to use via configuration).</p>
<p>间接代理<br>间接代理有两种形式。 它可以仅提供对象的标识，或者它可以与对象适配器标识符一起指定标识。 仅使用其身份即可访问的对象称为众所周知的对象，相应的代理也是众所周知的代理。 例如，字符串：</p>
<p>SimplePrinter<br>是具有标识 SimplePrinter 的知名对象的有效代理。</p>
<p>包含对象适配器标识符的间接代理具有字符串化形式</p>
<p>SimplePrinter@PrinterAdapter<br>对象适配器的任何对象都可以使用这样的代理来访问，无论该对象是否也是众所周知的对象。</p>
<p>请注意，间接代理不包含寻址信息。 为了确定正确的服务器，客户端运行时将代理信息传递给位置服务。 反过来，位置服务使用对象标识或对象适配器标识符作为包含服务器地址的查找表中的键，并将当前服务器地址返回给客户端。 客户端运行时现在知道如何联系服务器并像往常一样分派客户端请求。</p>
<p>整个过程类似于域名服务（DNS）从互联网域名到IP地址的映射：当我们使用域名（例如<a target="_blank" rel="noopener" href="http://www.zeroc.com)来查找网页时,主机名是/">www.zeroc.com）来查找网页时，主机名是</a> 首先在后台解析为 IP 地址，一旦知道正确的 IP 地址，就会使用该 IP 地址连接到服务器。 对于 Ice，映射是从对象标识或对象适配器标识符到协议地址对，但在其他方面非常相似。 客户端运行时知道如何通过配置联系位置服务（就像 Web 浏览器通过配置知道要使用哪个 DNS 服务器一样）。</p>
<p>Direct Versus Indirect Binding<br>The process of resolving the information in a proxy to protocol-address pair is known as binding. Not surprisingly, direct binding is used for direct proxies, and indirect binding is used for indirect proxies.</p>
<p>The main advantage of indirect binding is that it allows us to move servers around (that is, change their address) without invalidating existing proxies that are held by clients. In other words, direct proxies avoid the extra lookup to locate the server but no longer work if a server is moved to a different machine. On the other hand, indirect proxies continue to work even if we move (or migrate) a server.</p>
<p>直接绑定与间接绑定<br>将代理中的信息解析为协议地址对的过程称为绑定。 毫不奇怪，直接绑定用于直接代理，间接绑定用于间接代理。</p>
<p>间接绑定的主要优点是它允许我们移动服务器（即更改其地址），而不会使客户端持有的现有代理失效。 换句话说，直接代理避免了定位服务器的额外查找，但如果服务器移动到另一台计算机，则直接代理不再起作用。 另一方面，即使我们移动（或迁移）服务器，间接代理仍然可以继续工作。</p>
<p>Fixed Proxies<br>A fixed proxy is a proxy that is bound to a particular connection: instead of containing addressing information or an adapter name, the proxy contains a connection handle. The connection handle stays valid only for as long as the connection stays open so, once the connection is closed, the proxy no longer works (and will never work again). Fixed proxies cannot be marshaled, that is, they cannot be passed as parameters on operation invocations. Fixed proxies are used to allow bidirectional communication, so a server can make callbacks to a client without having to open a new connection.</p>
<p>固定代理<br>固定代理是绑定到特定连接的代理：代理包含连接句柄，而不是包含寻址信息或适配器名称。 连接句柄仅在连接保持打开状态时保持有效，因此，一旦连接关闭，代理就不再工作（并且永远不会再工作）。 固定代理无法封送，即它们无法作为操作调用的参数传递。 固定代理用于允许双向通信，因此服务器可以对客户端进行回调，而无需打开新连接。</p>
<p>Routed Proxies<br>A routed proxy is a proxy that forwards all invocations to a specific target object, instead of sending invocations directly to the actual target. Routed proxies are useful for implementing services such as Glacier2, which enables clients to communicate with servers that are behind a firewall.</p>
<p>路由代理<br>路由代理是将所有调用转发到特定目标对象的代理，而不是将调用直接发送到实际目标。 路由代理对于实现 Glacier2 等服务非常有用，它使客户端能够与防火墙后面的服务器进行通信。</p>
<p>Replication<br>In Ice, replication involves making object adapters (and their objects) available at multiple addresses. The goal of replication is usually to provide redundancy by running the same server on several computers. If one of the computers should happen to fail, a server still remains available on the others.</p>
<p>The use of replication implies that applications are designed for it. In particular, it means a client can access an object via one address and obtain the same result as from any other address. Either these objects are stateless, or their implementations are designed to synchronize with a database (or each other) in order to maintain a consistent view of each object’s state.</p>
<p>Ice supports a limited form of replication when a proxy specifies multiple addresses for an object. The Ice run time selects one of the addresses at random for its initial connection attempt and tries all of them in the case of a failure. For example, consider this proxy:</p>
<p>SimplePrinter:tcp -h server1 -p 10001:tcp -h server2 -p 10002<br>The proxy states that the object with identity SimplePrinter is available using TCP at two addresses, one on the host server1 and another on the host server2. The burden falls to users or system administrators to ensure that the servers are actually running on these computers at the specified ports.</p>
<p>复制<br>在 Ice 中，复制涉及使对象适配器（及其对象）在多个地址可用。 复制的目标通常是通过在多台计算机上运行同一服务器来提供冗余。 如果其中一台计算机发生故障，其他计算机上的服务器仍然可用。</p>
<p>复制的使用意味着应用程序是为此设计的。 具体来说，这意味着客户端可以通过一个地址访问一个对象，并获得与从任何其他地址访问相同的结果。 这些对象要么是无状态的，要么它们的实现被设计为与数据库（或彼此）同步，以便维护每个对象状态的一致视图。</p>
<p>当代理为对象指定多个地址时，Ice 支持有限形式的复制。 Ice run time 随机选择一个地址进行初始连接尝试，并在失败时尝试所有地址。 例如，考虑这个代理：</p>
<p>SimplePrinter:tcp -h server1 -p 10001:tcp -h server2 -p 10002<br>代理声明具有身份 SimplePrinter 的对象可通过 TCP 在两个地址上使用，一个位于主机 server1 上，另一个位于主机 server2 上。 用户或系统管理员有责任确保服务器实际上在这些计算机上的指定端口上运行。</p>
<p>Replica Groups<br>In addition to the proxy-based replication described above, Ice supports a more useful form of replication known as replica groups that requires the use of a location service.</p>
<p>A replica group has a unique identifier and consists of any number of object adapters. An object adapter may be a member of at most one replica group; such an adapter is considered to be a replicated object adapter.</p>
<p>After a replica group has been established, its identifier can be used in an indirect proxy in place of an adapter identifier. For example, a replica group identified as PrinterAdapters can be used in a proxy as shown below:</p>
<p>SimplePrinter@PrinterAdapters</p>
<p>The replica group is treated by the location service as a “virtual object adapter.” The behavior of the location service when resolving an indirect proxy containing a replica group id is an implementation detail. For example, the location service could decide to return the addresses of all object adapters in the group, in which case the client’s Ice run time would select one of the addresses at random using the limited form of replication discussed earlier. Another possibility is for the location service to return only one address, which it decided upon using some heuristic.</p>
<p>Regardless of the way in which a location service resolves a replica group, the key benefit is indirection: the location service as a middleman can add more intelligence to the binding process.</p>
<p>副本组<br>除了上述基于代理的复制之外，Ice还支持一种更有用的复制形式，称为副本组，它需要使用位置服务。</p>
<p>副本组具有唯一标识符并由任意数量的对象适配器组成。 一个对象适配器最多可以是一个副本组的成员； 这样的适配器被认为是复制对象适配器。</p>
<p>建立副本组后，可以在间接代理中使用其标识符来代替适配器标识符。 例如，标识为 PrinterAdapters 的副本组可以在代理中使用，如下所示：</p>
<p>SimplePrinter@PrinterAdapters</p>
<p>位置服务将副本组视为“虚拟对象适配器”。 解析包含副本组 ID 的间接代理时位置服务的行为是一个实现细节。 例如，位置服务可以决定返回组中所有对象适配器的地址，在这种情况下，客户端的 Ice run time 将使用前面讨论的有限复制形式随机选择地址之一。 另一种可能性是定位服务仅返回一个地址，这是它使用某种启发式方法决定的。</p>
<p>无论位置服务以何种方式解析副本组，关键的好处是间接性：位置服务作为中间人可以为绑定过程添加更多智能。</p>
<p>Servants<br>As we mentioned, an Ice Object is a conceptual entity that has a type, identity, and addressing information. However, client requests ultimately must end up with a concrete server-side processing entity that can provide the behavior for an operation invocation. To put this differently, a client request must ultimately end up executing code inside the server, with that code written in a specific programming language and executing on a specific processor.</p>
<p>The server-side artifact that provides behavior for operation invocations is known as a servant. A servant provides substance for (or incarnates) one or more Ice objects. In practice, a servant is simply an instance of a class that is written by the server developer and that is registered with the server-side run time as the servant for one or more Ice objects. Methods on the class correspond to the operations on the Ice object’s interface and provide the behavior for the operations.</p>
<p>A single servant can incarnate a single Ice object at a time or several Ice objects simultaneously. If the former, the identity of the Ice object incarnated by the servant is implicit in the servant. If the latter, the servant is provided the identity of the Ice object with each request, so it can decide which object to incarnate for the duration of the request.</p>
<p>Conversely, a single Ice object can have multiple servants. For example, we might choose to create a proxy for an Ice object with two different addresses for different machines. In that case, we will have two servers, with each server containing a servant for the same Ice object. When a client invokes an operation on such an Ice object, the client-side run time sends the request to exactly one server. In other words, multiple servants for a single Ice object allow you to build redundant systems: the client-side run time attempts to send the request to one server and, if that attempt fails, sends the request to the second server. An error is reported back to the client-side application code only if that second attempt also fails.</p>
<p>servant<br>正如我们提到的，Ice 对象是一个概念实体，具有类型、标识和寻址信息。 然而，客户端请求最终必须以一个具体的服务器端处理实体结束，该实体可以提供操作调用的行为。 换句话说，客户端请求最终必须在服务器内部执行代码，该代码用特定的编程语言编写并在特定的处理器上执行。</p>
<p>为操作调用提供行为的服务器端工件称为servant。 servant为一个或多个Ice 对象提供实例。 实际上，servant 只是由服务器开发人员编写的类的一个实例，并且在服务器端运行时注册为一个或多个 Ice 对象的servant。 类上的方法对应于 Ice 对象接口上的操作，并提供操作的行为。</p>
<p>单个servant可以一次化身一个 Ice 对象，也可以同时化身多个 Ice 对象。 如果是前者，servant所化身的Ice对象的身份就隐含在servant中。 如果是后者，则每次请求时都会向servant提供Ice对象的标识，因此它可以决定在请求期间具体化哪个对象。</p>
<p>相反，单个 Ice 对象可以有多个servant。 例如，我们可能选择为 Ice 对象创建一个代理，为不同的机器提供两个不同的地址。 在这种情况下，我们将有两个服务器，每个服务器都包含同一个 Ice 对象的servant。 当客户端调用此类 Ice 对象上的操作时，客户端运行时会将请求发送到一台服务器。 换句话说，单个 Ice 对象的多个servant 允许您构建冗余系统：客户端运行时尝试将请求发送到一台服务器，如果该尝试失败，则将请求发送到第二台服务器。 仅当第二次尝试也失败时，才会向客户端应用程序代码报告错误。</p>
<p>At-Most-Once Semantics<br>Ice requests have at-most-once semantics: the Ice run time does its best to deliver a request to the correct destination and, depending on the exact circumstances, may retry a failed request. Ice guarantees that it will either deliver the request, or, if it cannot deliver the request, inform the client with an appropriate exception; under no circumstances is a request delivered twice, that is, retries are attempted only if it is known that a previous attempt definitely failed.</p>
<p>One exception to this rule are datagram invocations over UDP transports. For these, duplicated UDP packets can lead to a violation of at-most-once semantics.</p>
<p>At-most-once semantics are important because they guarantee that operations that are not idempotent can be used safely. An idempotent operation is an operation that, if executed twice, has the same effect as if executed once. For example, x = 1; is an idempotent operation: if we execute the operation twice, the end result is the same as if we had executed it once. On the other hand, x++; is not idempotent: if we execute the operation twice, the end result is not the same as if we had executed it once.</p>
<p>Without at-most-once semantics, we can build distributed systems that are more robust in the presence of network failures. However, realistic systems require non-idempotent operations, so at-most-once semantics are a necessity, even though they make the system less robust in the presence of network failures. Ice permits you to mark individual operations as idempotent. For such operations, the Ice run time uses a more aggressive error recovery mechanism than for non-idempotent operations.</p>
<p>至多一次语义<br>Ice 请求具有至多一次语义：Ice 运行时会尽力将请求传递到正确的目的地，并且根据具体情况，可能会重试失败的请求。 Ice 保证它将交付请求，或者如果无法交付请求，则通知客户端并提供适当的例外； 在任何情况下，请求都不会发送两次，也就是说，只有在知道前一次尝试肯定失败的情况下才会尝试重试。</p>
<p>此规则的一个例外是通过 UDP 传输的数据报调用。 对于这些，重复的 UDP 数据包可能会导致违反最多一次语义。</p>
<p>至多一次语义很重要，因为它们保证可以安全地使用非幂等的操作。 幂等操作是指执行两次具有与执行一次相同效果的操作。 例如，x=1； 是一个幂等操作：如果我们执行该操作两次，最终结果与执行一次相同。 另一方面，x++； 不是幂等的：如果我们执行该操作两次，最终结果与执行一次不同。</p>
<p>没有至多一次语义，我们可以构建在出现网络故障时更加健壮的分布式系统。 然而，现实系统需要非幂等操作，因此至多一次语义是必要的，即使它们使系统在出现网络故障时变得不那么健壮。 Ice 允许您将单个操作标记为幂等。 对于此类操作，Ice run time 使用比非幂等操作更积极的错误恢复机制。</p>
<p>Synchronous Method Invocation<br>By default, the request dispatch model used by Ice is a synchronous remote procedure call: an operation invocation behaves like a local procedure call, that is, the client thread is suspended for the duration of the call and resumes when the call completes (and all its results are available).</p>
<p>同步方法调用<br>默认情况下，Ice 使用的请求调度模型是同步远程过程调用：操作调用的行为类似于本地过程调用，即客户端线程在调用期间挂起，并在调用完成时恢复（并且所有 其结果是可用的）。</p>
<p>Asynchronous Method Invocation<br>Ice also supports asynchronous method invocation (AMI): a client can invoke operations asynchronously, which means the client’s calling thread does not block while waiting for the invocation to complete. The client passes the normal parameters and, depending on the language mapping, might also pass a callback that the client-side run time invokes upon completion, or the invocation might return a future that the client can eventually use to obtain the results.</p>
<p>The server cannot distinguish an asynchronous invocation from a synchronous one — either way, the server simply sees that a client has invoked an operation on an object.</p>
<p>异步方法调用<br>Ice还支持异步方法调用（AMI）：客户端可以异步调用操作，这意味着客户端的调用线程在等待调用完成时不会阻塞。 客户端传递普通参数，并且根据语言映射，还可能传递客户端运行时在完成时调用的回调，或者调用可能返回客户端最终可以用来获取结果的 future。</p>
<p>服务器无法区分异步调用和同步调用——无论哪种方式，服务器都只是看到客户端调用了对象上的操作。</p>
<p>Asynchronous Method Dispatch<br>Asynchronous method dispatch (AMD) is the server-side equivalent of AMI. For synchronous dispatch (the default), the server-side run time up-calls into the application code in the server in response to an operation invocation. While the operation is executing (or sleeping, for example, because it is waiting for data), a thread of execution is tied up in the server; that thread is released only when the operation completes.</p>
<p>With asynchronous method dispatch, the server-side application code is informed of the arrival of an operation invocation. However, instead of being forced to process the request immediately, the server-side application can choose to delay processing of the request and, in doing so, releases the execution thread for the request. The server-side application code is now free to do whatever it likes. Eventually, once the results of the operation are available, the server-side application code makes an API call to inform the server-side Ice run time that a request that was dispatched previously is now complete; at that point, the results of the operation are returned to the client.</p>
<p>Asynchronous method dispatch is useful if, for example, a server offers operations that block clients for an extended period of time. For example, the server may have an object with a get operation that returns data from an external, asynchronous data source and that blocks clients until the data becomes available. With synchronous dispatch, each client waiting for data to arrive ties up an execution thread in the server. Clearly, this approach does not scale beyond a few dozen clients. With asynchronous dispatch, hundreds or thousands of clients can be blocked in the same operation invocation without tying up any threads in the server.</p>
<p>Synchronous and asynchronous method dispatch are transparent to the client, that is, the client cannot tell whether a server chose to process a request synchronously or asynchronously.</p>
<p>异步方法分派<br>异步方法分派 (AMD) 是 AMI 的服务器端等效项。 对于同步调度（默认），服务器端运行时向上调用服务器中的应用程序代码以响应操作调用。 当操作正在执行时（或者休眠，例如，因为它正在等待数据），执行线程被绑定在服务器中； 仅当操作完成时该线程才会被释放。</p>
<p>通过异步方法分派，服务器端应用程序代码会收到操作调用到达的通知。 然而，服务器端应用程序可以选择延迟处理请求，并释放请求的执行线程，而不是被迫立即处理请求。 服务器端应用程序代码现在可以自由地执行任何操作。 最终，一旦操作结果可用，服务器端应用程序代码就会进行 API 调用，通知服务器端 Ice run time 之前分派的请求现已完成； 此时，操作结果将返回给客户端。</p>
<p>例如，如果服务器提供长时间阻塞客户端的操作，则异步方法分派非常有用。 例如，服务器可能有一个带有 get 操作的对象，该操作从外部异步数据源返回数据，并阻止客户端直到数据可用。 通过同步调度，每个等待数据到达的客户端都会占用服务器中的一个执行线程。 显然，这种方法的规模不能超过几十个客户。 通过异步分派，可以在同一个操作调用中阻止数百或数千个客户端，而不会占用服务器中的任何线程。</p>
<p>同步和异步方法分派对客户端来说是透明的，也就是说，客户端无法判断服务器选择同步还是异步处理请求。</p>
<p>Oneway Method Invocation<br>Clients can invoke an operation as a oneway operation. A oneway invocation has “best effort” semantics. For a oneway invocation, the client-side run time hands the invocation to the local transport, and the invocation completes on the client side as soon as the local transport has buffered the invocation. The actual invocation is then sent asynchronously by the operating system. The server does not reply to oneway invocations, that is, traffic flows only from client to server, but not vice versa.</p>
<p>Oneway invocations are unreliable. For example, the target object may not exist, in which case the invocation is simply lost. Similarly, the operation may be dispatched to a servant in the server, but the operation may fail (for example, because parameter values are invalid); if so, the client receives no notification that something has gone wrong.</p>
<p>Oneway invocations are possible only on operations that do not have a return value, do not have out-parameters, and do not throw user exceptions.</p>
<p>To the application code on the server-side, oneway invocations are transparent, that is, there is no way to distinguish a twoway invocation from a oneway invocation.</p>
<p>Oneway invocations are available only if the target object offers a stream-oriented transport, such as TCP/IP or SSL.</p>
<p>Note that, even though oneway operations are sent over a stream-oriented transport, they may be processed out of order in the server. This can happen because each invocation may be dispatched in its own thread: even though the invocations are initiated in the order in which the invocations arrive at the server, this does not mean that they will be processed in that order — the vagaries of thread scheduling can result in a oneway invocation completing before other oneway invocations that were received earlier.</p>
<p>单向方法调用<br>客户端可以将操作作为单向操作来调用。 单向调用具有“尽力而为”的语义。 对于单向调用，客户端运行时将调用交给本地传输，并且一旦本地传输缓冲了该调用，该调用就会在客户端完成。 然后，操作系统异步发送实际的调用。 服务器不回复单向调用，即流量仅从客户端流向服务器，反之则不然。</p>
<p>单向调用是不可靠的。 例如，目标对象可能不存在，在这种情况下，调用就会丢失。 类似地，操作可能会被调度到服务器中的servant，但操作可能会失败（例如，因为参数值无效）； 如果是这样，客户端不会收到出现问题的通知。</p>
<p>单向调用仅适用于没有返回值、没有输出参数并且不引发用户异常的操作。</p>
<p>对于服务器端的应用程序代码来说，单向调用是透明的，即无法区分双向调用和单向调用。</p>
<p>仅当目标对象提供面向流的传输（例如 TCP/IP 或 SSL）时，单向调用才可用。</p>
<p>请注意，即使单向操作是通过面向流的传输发送的，它们在服务器中的处理也可能是无序的。 发生这种情况是因为每个调用都可能在其自己的线程中分派：即使调用是按照调用到达服务器的顺序启动的，但这并不意味着它们将按照该顺序进行处理 - 线程调度的变幻莫测 可能会导致单向调用先于之前收到的其他单向调用完成。</p>
<p>Batched Oneway Method Invocation<br>Each oneway invocation sends a separate message to the server. For a series of short messages, the overhead of doing so is considerable: the client- and server-side run time each must switch between user mode and kernel mode for each message and, at the networking level, each message incurs the overheads of flow-control and acknowledgement.</p>
<p>Batched oneway invocations allow you to send a series of oneway invocations as a single message: every time you invoke a batched oneway operation, the invocation is buffered in the client-side run time. Once you have accumulated all the oneway invocations you want to send, you make a separate API call to send all the invocations at once. The client-side run time then sends all of the buffered invocations in a single message, and the server receives all of the invocations in a single message. This avoids the overhead of repeatedly trapping into the kernel for both client and server, and is much easier on the network between them because one large message can be transmitted more efficiently than many small ones.</p>
<p>The individual invocations in a batched oneway message are dispatched by a single thread in the order in which they were placed into the batch. This guarantees that the individual operations in a batched oneway message are processed in order in the server.</p>
<p>Batched oneway invocations are particularly useful for messaging services, such as IceStorm, and for fine-grained interfaces that offer set operations for small attributes.</p>
<p>批量单向方法调用<br>每个单向调用都会向服务器发送一条单独的消息。 对于一系列短消息来说，这样做的开销是相当大的：客户端和服务器端运行时都必须为每条消息在用户模式和内核模式之间切换，并且在网络层面，每条消息都会产生流的开销 -控制和确认。</p>
<p>批量单向调用允许您将一系列单向调用作为单个消息发送：每次调用批量单向操作时，该调用都会在客户端运行时进行缓冲。 一旦您积累了要发送的所有单向调用，您就可以进行单独的 API 调用来一次发送所有调用。 然后，客户端运行时在单个消息中发送所有缓冲的调用，并且服务器在单个消息中接收所有调用。 这避免了客户端和服务器重复陷入内核的开销，并且在它们之间的网络上更容易，因为一条大消息可以比许多小消息更有效地传输。</p>
<p>批处理单向消息中的各个调用由单个线程按照它们放入批处理的顺序进行调度。 这保证了批量单向消息中的各个操作在服务器中按顺序处理。</p>
<p>批量单向调用对于消息服务（例如 IceStorm）以及为小属性提供设置操作的细粒度接口特别有用。</p>
<p>Datagram Invocations<br>Datagram invocations have “best effort” semantics similar to oneway invocations. However, datagram invocations require the object to offer UDP as a transport (whereas oneway invocations require TCP/IP).</p>
<p>Like a oneway invocation, a datagram invocation can be made only if the operation does not have a return value, out-parameters, or user exceptions. A datagram invocation uses UDP to invoke the operation. The operation returns as soon as the local UDP stack has accepted the message; the actual operation invocation is sent asynchronously by the network stack behind the scenes.</p>
<p>Datagrams, like oneway invocations, are unreliable: the target object may not exist in the server, the server may not be running, or the operation may be invoked in the server but fail due to invalid parameters sent by the client. As for oneway invocations, the client receives no notification of such errors.</p>
<p>However, unlike oneway invocations, datagram invocations have a number of additional error scenarios:</p>
<p>Individual invocations may simply be lost in the network.<br>This is due to the unreliable delivery of UDP packets. For example, if you invoke three operations in sequence, the middle invocation may be lost. (The same thing cannot happen for oneway invocations — because they are delivered over a connection-oriented transport, individual invocations cannot be lost.)<br>Individual invocations may arrive out of order.<br>Again, this is due to the nature of UDP datagrams. Because each invocation is sent as a separate datagram, and individual datagrams can take different paths through the network, it can happen that invocations arrive in an order that differs from the order in which they were sent.<br>Datagram invocations are well suited for small messages on LANs, where the likelihood of loss is small. They are also suited to situations in which low latency is more important than reliability, such as for fast, interactive internet applications. Finally, datagram invocations can be used to multicast messages to multiple servers simultaneously.</p>
<p>数据报调用<br>数据报调用具有与单向调用类似的“尽力而为”语义。 然而，数据报调用要求对象提供 UDP 作为传输（而单向调用则需要 TCP/IP）。</p>
<p>与单向调用一样，仅当操作没有返回值、输出参数或用户异常时才能进行数据报调用。 数据报调用使用 UDP 来调用操作。 一旦本地 UDP 堆栈接受了消息，操作就会返回； 实际的操作调用由幕后的网络堆栈异步发送。</p>
<p>数据报与单向调用一样，是不可靠的：目标对象可能不存在于服务器中，服务器可能未运行，或者操作可能在服务器中调用但由于客户端发送的无效参数而失败。 对于单向调用，客户端不会收到此类错误的通知。</p>
<p>然而，与单向调用不同，数据报调用有许多额外的错误场景：</p>
<p>单独的调用可能会在网络中丢失。<br>这是由于 UDP 数据包的传送不可靠造成的。 例如，如果您依次调用三个操作，则中间的调用可能会丢失。 （对于单向调用，不会发生同样的情况 - 因为它们是通过面向连接的传输传递的，单个调用不会丢失。）<br>个别调用可能会无序到达。<br>同样，这是由 UDP 数据报的性质决定的。 由于每个调用都作为单独的数据报发送，并且各个数据报可以采用不同的网络路径，因此调用到达的顺序可能与其发送的顺序不同。<br>数据报调用非常适合 LAN 上的小消息，因为丢失的可能性很小。 它们还适合低延迟比可靠性更重要的情况，例如快速、交互式互联网应用程序。 最后，数据报调用可用于同时将消息多播到多个服务器。</p>
<p>Batched Datagram Invocations<br>As for batched oneway invocations, batched datagram invocations allow you to accumulate a number of invocations in a buffer and then send the entire buffer as a single datagram by making an API call to flush the buffer. Batched datagrams reduce the overhead of repeated system calls and allow the underlying network to operate more efficiently. However, batched datagram invocations are useful only for batched messages whose total size does not substantially exceed the PDU limit of the network: if the size of a batched datagram gets too large, UDP fragmentation makes it more likely that one or more fragments are lost, which results in the loss of the entire batched message. However, you are guaranteed that either all invocations in a batch will be delivered, or none will be delivered. It is impossible for individual invocations within a batch to be lost.</p>
<p>Batched datagrams use a single thread in the server to dispatch the individual invocations in a batch. This guarantees that the invocations are made in the order in which they were queued — invocations cannot appear to be reordered in the server.</p>
<p>批量数据报调用<br>对于批量单向调用，批量数据报调用允许您在缓冲区中累积多个调用，然后通过调用 API 来刷新缓冲区，将整个缓冲区作为单个数据报发送。 批量数据报减少了重复系统调用的开销，并允许底层网络更有效地运行。 但是，批处理数据报调用仅适用于总大小未大幅超出网络 PDU 限制的批处理消息：如果批处理数据报的大小变得太大，则 UDP 碎片更有可能丢失一个或多个碎片， 这会导致整个批量消息丢失。 但是，您可以保证批次中的所有调用都将被传递，或者不会被传递。 批次内的各个调用不可能丢失。</p>
<p>批量数据报使用服务器中的单个线程来批量分派各个调用。 这保证了调用按照它们排队的顺序进行——调用在服务器中不会被重新排序。</p>
<p>Run-Time Exceptions<br>Any operation invocation can raise a run-time exception. Run-time exceptions are pre-defined by the Ice run time and cover common error conditions, such as connection failure, connection timeout, or resource allocation failure. Run-time exceptions are presented to the application as native exceptions and so integrate neatly with the native exception handling capabilities of languages that support exception handling.</p>
<p>运行时异常<br>任何操作调用都可能引发运行时异常。 运行时异常是由 Ice run time 预先定义的，涵盖常见的错误情况，例如连接失败、连接超时或资源分配失败。 运行时异常作为本机异常呈现给应用程序，因此与支持异常处理的语言的本机异常处理功能巧妙地集成。</p>
<p>User Exceptions<br>A server indicates application-specific error conditions by raising user exceptions to clients. User exceptions can carry an arbitrary amount of complex data and can be arranged into inheritance hierarchies, which makes it easy for clients to handle categories of errors generically, by catching an exception that is further up the inheritance hierarchy. Like run-time exceptions, user exceptions map to native exceptions.</p>
<p>用户异常<br>服务器通过向客户端引发用户异常来指示特定于应用程序的错误情况。 用户异常可以携带任意数量的复杂数据，并且可以排列成继承层次结构，这使得客户端可以通过捕获继承层次结构中更高的异常来轻松地一般处理错误类别。 与运行时异常一样，用户异常映射到本机异常。</p>
<p>Properties<br>Much of the Ice run time is configurable via properties. Properties are name-value pairs, such as Ice.Default.Protocol=tcp. Properties are typically stored in text files and parsed by the Ice run time to configure various options, such as the thread pool size, the level of tracing, and various other configuration parameters.</p>
<p>属性<br>Ice 的大部分运行时间都可以通过属性进行配置。 属性是名称-值对，例如 Ice.Default.Protocol=tcp。 属性通常存储在文本文件中，并由 Ice 运行时解析以配置各种选项，例如线程池大小、跟踪级别以及各种其他配置参数。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://qianqians.github.io/2023/10/11/ubuntu_mongodb/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="qianqians">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="qianqians'blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/10/11/ubuntu_mongodb/" class="post-title-link" itemprop="url">ubuntu_mongodb</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-10-11 21:15:35" itemprop="dateCreated datePublished" datetime="2023-10-11T21:15:35+08:00">2023-10-11</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-11-24 15:26:57" itemprop="dateModified" datetime="2023-11-24T15:26:57+08:00">2023-11-24</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/ubuntu/" itemprop="url" rel="index"><span itemprop="name">ubuntu</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/mongodb/" itemprop="url" rel="index"><span itemprop="name">mongodb</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><a target="_blank" rel="noopener" href="https://askubuntu.com/questions/823288/mongodb-loads-but-breaks-returning-status-14">https://askubuntu.com/questions/823288/mongodb-loads-but-breaks-returning-status-14</a></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sudo <span class="built_in">chown</span> -R mongodb:mongodb /var/lib/mongodb</span><br><span class="line">sudo <span class="built_in">chown</span> mongodb:mongodb /tmp/mongodb-27017.sock</span><br><span class="line"></span><br><span class="line">sudo service mongod restart</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://qianqians.github.io/2023/07/23/unity%E5%BE%AE%E4%BF%A1%E5%B0%8F%E6%B8%B8%E6%88%8F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="qianqians">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="qianqians'blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/07/23/unity%E5%BE%AE%E4%BF%A1%E5%B0%8F%E6%B8%B8%E6%88%8F/" class="post-title-link" itemprop="url">微信小游戏 unity websocket</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2023-07-23 15:20:31 / 修改时间：15:25:21" itemprop="dateCreated datePublished" datetime="2023-07-23T15:20:31+08:00">2023-07-23</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E6%B8%B8%E6%88%8F/" itemprop="url" rel="index"><span itemprop="name">微信小游戏</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <ol>
<li><a target="_blank" rel="noopener" href="https://github.com/wechat-miniprogram/minigame-unity-webgl-transform">https://github.com/wechat-miniprogram/minigame-unity-webgl-transform</a></li>
<li>websocket使用<a target="_blank" rel="noopener" href="https://github.com/psygames/UnityWebSocket">https://github.com/psygames/UnityWebSocket</a></li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://qianqians.github.io/2023/07/06/Rust%E5%BC%80%E5%8F%91%E5%B0%8F%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="qianqians">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="qianqians'blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/07/06/Rust%E5%BC%80%E5%8F%91%E5%B0%8F%E8%AE%B0/" class="post-title-link" itemprop="url">Rust开发小记</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-07-06 20:05:45" itemprop="dateCreated datePublished" datetime="2023-07-06T20:05:45+08:00">2023-07-06</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-02-17 21:01:47" itemprop="dateModified" datetime="2024-02-17T21:01:47+08:00">2024-02-17</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Rust/" itemprop="url" rel="index"><span itemprop="name">Rust</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <ol>
<li><p>多线程共享trait</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">trait</span> <span class="title class_">T</span> &#123;&#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">B</span> &#123;&#125;</span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">T</span> <span class="keyword">for</span> <span class="title class_">B</span> &#123;&#125;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">p</span>: Arc&lt;Mutex&lt;<span class="type">Box</span>&lt;<span class="keyword">dyn</span> T&gt;&gt;&gt; = Arc::<span class="title function_ invoke__">new</span>(Mutex::<span class="title function_ invoke__">new</span>(<span class="type">Box</span>::<span class="title function_ invoke__">new</span>(B&#123;&#125;)))</span><br></pre></td></tr></table></figure>
<p>需要注意struct类型的对象和trait之间不能互转,比如:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">trait</span> <span class="title class_">T</span> &#123;&#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">B</span> &#123;&#125;</span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">T</span> <span class="keyword">for</span> <span class="title class_">B</span> &#123;&#125;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">p</span>: Arc&lt;Mutex&lt;<span class="type">Box</span>&lt;B&gt;&gt;&gt; = Arc::<span class="title function_ invoke__">new</span>(Mutex::<span class="title function_ invoke__">new</span>(<span class="type">Box</span>::<span class="title function_ invoke__">new</span>(B&#123;&#125;)))</span><br><span class="line"><span class="keyword">let</span> <span class="variable">p_trait</span>: Arc&lt;Mutex&lt;<span class="type">Box</span>&lt;<span class="keyword">dyn</span> T&gt;&gt;&gt; = p <span class="comment">//会编译不过</span></span><br></pre></td></tr></table></figure></li>
<li><p>trait中声明async函数</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[async_trait]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">trait</span> <span class="title class_">T</span> &#123;</span><br><span class="line">    <span class="keyword">async</span> <span class="keyword">fn</span> <span class="title function_">send</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, buf: &amp;[<span class="type">u8</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>生命周期标注</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::fs;</span><br><span class="line"><span class="keyword">use</span> std::io;</span><br><span class="line"><span class="keyword">use</span> serde::&#123;Deserialize, Serialize&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">load_data_from_file</span>(cfg_file: <span class="type">String</span>) <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;<span class="type">String</span>, io::Error&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">data</span> = fs::<span class="title function_ invoke__">read_to_string</span>(cfg_file)?;</span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(data)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">load_cfg_from_data</span>&lt;<span class="symbol">&#x27;a</span>, C: Deserialize&lt;<span class="symbol">&#x27;a</span>&gt; + Serialize&gt;(data: &amp;<span class="symbol">&#x27;a</span> <span class="type">String</span>) <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;C, io::Error&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">cfg</span>: C = serde_json::from_str::&lt;C&gt;(&amp;data)?;</span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(cfg)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>data在外部调用load_data_from_file获取,然后调用load_cfg_from_data时传入<br>如在load_cfg_from_data中读取写做:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::fs;</span><br><span class="line"><span class="keyword">use</span> std::io;</span><br><span class="line"><span class="keyword">use</span> serde::&#123;Deserialize, Serialize&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">load_data_from_file</span>(cfg_file: <span class="type">String</span>) <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;<span class="type">String</span>, io::Error&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">data</span> = fs::<span class="title function_ invoke__">read_to_string</span>(cfg_file)?;</span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(data)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">load_cfg_from_data</span>&lt;<span class="symbol">&#x27;a</span>, C: Deserialize&lt;<span class="symbol">&#x27;a</span>&gt; + Serialize&gt;(cfg_file: <span class="type">String</span>) <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;C, io::Error&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">data</span> = <span class="title function_ invoke__">load_data_from_file</span>(cfg_file)?;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">cfg</span>: C = serde_json::from_str::&lt;C&gt;(&amp;data)?;</span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(cfg)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>会编译不过</p>
</li>
<li><p>tokio::spawn拉起线程,传入的变量使用Arc&lt;Mutex<H>&gt;,clone后传入</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">async</span> <span class="keyword">fn</span> <span class="title function_">f</span>(_handle: Arc&lt;Mutex&lt;H&gt;&gt;) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">_clone_h</span> = _handle.<span class="title function_ invoke__">clone</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">_join</span> = tokio::<span class="title function_ invoke__">spawn</span>(<span class="keyword">async</span> <span class="keyword">move</span> &#123;</span><br><span class="line">        <span class="keyword">loop</span> &#123;</span><br><span class="line">            <span class="comment">//...</span></span><br><span class="line">            </span><br><span class="line">            <span class="keyword">let</span> <span class="variable">_clone_handle</span> = _clone_h.<span class="title function_ invoke__">clone</span>();</span><br><span class="line">            <span class="comment">//...              </span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>Future:<a target="_blank" rel="noopener" href="https://juejin.cn/post/6844903973950849031">https://juejin.cn/post/6844903973950849031</a></p>
</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://qianqians.github.io/2023/05/31/%E9%A3%9E%E8%A1%8C%E6%A3%8B%E5%BC%80%E5%8F%91%E6%89%8B%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="qianqians">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="qianqians'blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/05/31/%E9%A3%9E%E8%A1%8C%E6%A3%8B%E5%BC%80%E5%8F%91%E6%89%8B%E8%AE%B0/" class="post-title-link" itemprop="url">飞行棋开发手记</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2023-05-31 14:12:19 / 修改时间：14:37:41" itemprop="dateCreated datePublished" datetime="2023-05-31T14:12:19+08:00">2023-05-31</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E6%B8%B8%E6%88%8F/" itemprop="url" rel="index"><span itemprop="name">微信小游戏</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <ol>
<li><p>Cosos Creator Asset Bundle <a target="_blank" rel="noopener" href="https://docs.cocos.com/creator/manual/zh/asset/bundle.html">https://docs.cocos.com/creator/manual/zh/asset/bundle.html</a><br>因为前期没用合理的划分管理资源，不同scene之间共用资源较多，按资源打bundle远程加载比较麻烦，所以飞行棋选择了直接按scene打bundle，实际操作效果不错，加载scene的时候远程加载既可</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">assetManager.loadBundle(<span class="string">&#x27;main_scene&#x27;</span>, <span class="keyword">async</span> (err, bundle) =&gt; &#123;</span><br><span class="line">    bundle.loadScene(sceneName, <span class="function"><span class="keyword">function</span> (<span class="params">err, scene</span>) </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;);</span><br><span class="line">    ...</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li>
<li><p>微信小游戏iphone不支持.m4a格式的音频，改为mp3格式运行正常</p>
</li>
<li><p>Cosos Creator ScrollView组件 </p>
<ol>
<li>滚动后会弹回初始位置，将Bounce Duration属性设置为最大值10，可以模拟不弹回的状态</li>
<li>默认状态可以滚动到无限远，需要在程序中响应ScrollView.EventType.SCROLLING事件控制<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">this</span>.view.node.on(ScrollView.EventType.SCROLLING, <span class="built_in">this</span>.scrolling_callback, <span class="built_in">this</span>);</span><br><span class="line"><span class="function"><span class="title">scrolling_callback</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> pos = <span class="built_in">this</span>.view.getScrollOffset().y;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pos &lt; - <span class="number">200</span>) &#123;</span><br><span class="line">        <span class="built_in">this</span>.view.scrollToOffset(<span class="keyword">new</span> Vec2(<span class="number">0</span>, pos), <span class="number">10</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (pos &gt; <span class="built_in">this</span>.bottom + <span class="number">200</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> maxScrollOffset = <span class="built_in">this</span>.view.getMaxScrollOffset();</span><br><span class="line">        <span class="built_in">this</span>.view.scrollToOffset(<span class="keyword">new</span> Vec2(<span class="number">0</span>, maxScrollOffset.y), <span class="number">10</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li><p>切换scene，会导致上一次的scene失效，需要重新加载scene(bundle不会失效)</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">singleton.netSingleton.bundle.loadScene(<span class="string">&#x27;main&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">err, scene</span>) </span>&#123;</span><br><span class="line">    director.runScene(scene);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li>
<li><p>director.addPersistRootNode(this.node)</p>
</li>
<li><p>tilemap坐标转cocos creator场景坐标</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">target_x = pos.x * <span class="number">64</span> + <span class="number">32</span> - game_data.layout_half_width;</span><br><span class="line">target_y=  pos.y * <span class="number">64</span> + <span class="number">32</span> - game_data.layout_half_height;</span><br><span class="line">...</span><br></pre></td></tr></table></figure></li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://qianqians.github.io/2023/05/22/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E6%B8%B8%E6%88%8F%E7%99%BB%E5%BD%95%E6%B5%81%E7%A8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="qianqians">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="qianqians'blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/05/22/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E6%B8%B8%E6%88%8F%E7%99%BB%E5%BD%95%E6%B5%81%E7%A8%8B/" class="post-title-link" itemprop="url">微信小游戏登录流程</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2023-05-22 14:24:07 / 修改时间：14:48:09" itemprop="dateCreated datePublished" datetime="2023-05-22T14:24:07+08:00">2023-05-22</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E6%B8%B8%E6%88%8F/" itemprop="url" rel="index"><span itemprop="name">微信小游戏</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>cocos creator 登录流程</p>
<ol>
<li><p>安装minigame-api-typings </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install minigame-api-typings</span><br></pre></td></tr></table></figure></li>
<li><p>代码中引用import ‘minigame-api-typings’;</p>
</li>
<li><p>调用wx登录接口</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">wx.login(&#123;</span><br><span class="line">    <span class="attr">complete</span>: <span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;login complete:&quot;</span> + <span class="built_in">JSON</span>.stringify(res));</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">fail</span>: <span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">         <span class="built_in">console</span>.log(<span class="string">&quot;login fail:&quot;</span> + <span class="built_in">JSON</span>.stringify(res));</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">success</span>: <span class="function">(<span class="params">login_res</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;login success:&quot;</span> + <span class="built_in">JSON</span>.stringify(login_res));</span><br><span class="line">        wx.getSetting(&#123;</span><br><span class="line">            <span class="attr">complete</span>: <span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">                <span class="built_in">console</span>.log(<span class="string">&quot;authSetting complete:&quot;</span>, <span class="built_in">JSON</span>.stringify(res));</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">fail</span>: <span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">                <span class="built_in">console</span>.log(<span class="string">&quot;authSetting fail:&quot;</span>, <span class="built_in">JSON</span>.stringify(res));</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">success</span>: <span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">                <span class="built_in">console</span>.log(<span class="string">&quot;authSetting:&quot;</span>, <span class="built_in">JSON</span>.stringify(res));</span><br><span class="line">                <span class="keyword">if</span> (res.authSetting[<span class="string">&#x27;scope.userInfo&#x27;</span>]) &#123;</span><br><span class="line">                    <span class="built_in">this</span>.get_user_info_login(login_res.code)</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">let</span> wxSize = wx.getSystemInfoSync();</span><br><span class="line">                    <span class="keyword">let</span> btn = wx.createUserInfoButton(&#123;</span><br><span class="line">                        <span class="attr">type</span>: <span class="string">&#x27;text&#x27;</span>,</span><br><span class="line">                        <span class="attr">text</span>: <span class="string">&#x27;微信登录&#x27;</span>,</span><br><span class="line">                        <span class="attr">style</span>: &#123;</span><br><span class="line">                            <span class="attr">left</span>: wxSize.screenWidth / <span class="number">2</span> - <span class="number">100</span>,</span><br><span class="line">                            <span class="attr">top</span>: wxSize.screenHeight / <span class="number">2</span> - <span class="number">40</span>,</span><br><span class="line">                            <span class="attr">width</span>: <span class="number">200</span>,</span><br><span class="line">                            <span class="attr">height</span>: <span class="number">40</span>,</span><br><span class="line">                            <span class="attr">lineHeight</span>: <span class="number">40</span>,</span><br><span class="line">                            <span class="attr">backgroundColor</span>: <span class="string">&#x27;#ffffff&#x27;</span>,</span><br><span class="line">                            <span class="attr">borderColor</span>: <span class="string">&#x27;#ffffff&#x27;</span>,</span><br><span class="line">                            <span class="attr">borderWidth</span>: <span class="number">1</span>,</span><br><span class="line">                            <span class="attr">color</span>: <span class="string">&#x27;#000000&#x27;</span>,</span><br><span class="line">                            <span class="attr">textAlign</span>: <span class="string">&#x27;center&#x27;</span>,</span><br><span class="line">                            <span class="attr">fontSize</span>: <span class="number">16</span>,</span><br><span class="line">                            <span class="attr">borderRadius</span>: <span class="number">4</span></span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line">                    btn.onTap(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">                        <span class="built_in">console</span>.log(<span class="string">&quot;createUserInfoButton:&quot;</span> + <span class="built_in">JSON</span>.stringify(res));</span><br><span class="line">                        <span class="built_in">this</span>.get_user_info_login(login_res.code)</span><br><span class="line">                         btn.destroy();</span><br><span class="line">                    &#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">get_user_info_login</span>(<span class="params">code:string</span>)</span> &#123;</span><br><span class="line">    wx.getUserInfo(&#123; </span><br><span class="line">        <span class="attr">withCredentials</span>:<span class="literal">false</span>,</span><br><span class="line">        <span class="attr">success</span>: <span class="function">(<span class="params">result</span>) =&gt;</span> &#123;</span><br><span class="line">            login.login_player_no_author(code, result.userInfo.nickName, result.userInfo.avatarUrl);</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">fail</span>: <span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">&quot;fail:&quot;</span> + <span class="built_in">JSON</span>.stringify(res));</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">complete</span>: <span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">&quot;complete:&quot;</span> + <span class="built_in">JSON</span>.stringify(res));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>login_player_no_author接口上传code到服务器端,服务器端收到code之后通过http请求到微信后台验证(AppID,Secret从微信小游戏管理后台获取):</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> url = <span class="string">$&quot;https://api.weixin.qq.com/sns/jscode2session?appid=<span class="subst">&#123;AppID&#125;</span>&amp;secret=<span class="subst">&#123;Secret&#125;</span>&amp;js_code=<span class="subst">&#123;code&#125;</span>&amp;grant_type=authorization_code&quot;</span>;</span><br><span class="line"><span class="keyword">var</span> result = <span class="keyword">await</span> HttpClientWrapper.GetRspAsync(url);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (result != <span class="literal">null</span> &amp;&amp; result.StatusCode == System.Net.HttpStatusCode.OK)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">var</span> ret = <span class="keyword">await</span> result.Content.ReadAsStringAsync();</span><br><span class="line">    <span class="keyword">var</span> ret_obj = Newtonsoft.Json.JsonConvert.DeserializeObject&lt;Hashtable&gt;(ret);</span><br><span class="line">    <span class="keyword">var</span> token = <span class="keyword">await</span> player.client_Mng.token_player_login(ret_obj[<span class="string">&quot;openid&quot;</span>] <span class="keyword">as</span> <span class="built_in">string</span>);</span><br><span class="line">    rsp.rsp(token);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/5/">5</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">qianqians</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>

<script src="/js/bookmark.js"></script>




  















  

  

</body>
</html>
