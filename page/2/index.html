<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">
  <link rel="manifest" href="/images/manifest.json">
  <meta name="msapplication-config" content="/images/browserconfig.xml">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">
<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"qianqians.github.io","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"remove","padding":18,"offset":12,"onmobile":true},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":true,"scrollpercent":true},"bookmark":{"enable":true,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="qianqians&#39;blog">
<meta property="og:url" content="https://qianqians.github.io/page/2/index.html">
<meta property="og:site_name" content="qianqians&#39;blog">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="qianqians">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://qianqians.github.io/page/2/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>qianqians'blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">qianqians'blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档<span class="badge">25</span></a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>分类<span class="badge">4</span></a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-fw fa-user"></i>关于</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <a role="button" class="book-mark-link book-mark-link-fixed"></a>

  <a href="https://github.com/qianqians" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://qianqians.github.io/2021/08/19/Wgpu%20The%20Swapchain/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="qianqians">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="qianqians'blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/08/19/Wgpu%20The%20Swapchain/" class="post-title-link" itemprop="url">Wgpu The Swapchain</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-08-19 16:08:20" itemprop="dateCreated datePublished" datetime="2021-08-19T16:08:20+08:00">2021-08-19</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-08-24 16:28:42" itemprop="dateModified" datetime="2021-08-24T16:28:42+08:00">2021-08-24</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Wgpu/" itemprop="url" rel="index"><span itemprop="name">Wgpu</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="First-some-house-keeping-State"><a href="#First-some-house-keeping-State" class="headerlink" title="First, some house keeping: State"></a>First, some house keeping: State</h1><p>For convenience we’re going to pack all the fields into a struct, and create some methods on that.</p>
<p>为了方便起见，我们将把所有字段打包到一个结构中，并在此基础上创建一些方法。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main.rs</span></span><br><span class="line"><span class="keyword">use</span> winit::window::Window;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">State</span></span> &#123;</span><br><span class="line">    surface: wgpu::Surface,</span><br><span class="line">    device: wgpu::Device,</span><br><span class="line">    queue: wgpu::Queue,</span><br><span class="line">    sc_desc: wgpu::SwapChainDescriptor,</span><br><span class="line">    swap_chain: wgpu::SwapChain,</span><br><span class="line">    size: winit::dpi::PhysicalSize&lt;<span class="built_in">u32</span>&gt;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> State &#123;</span><br><span class="line">    <span class="comment">// Creating some of the wgpu types requires async code</span></span><br><span class="line">    <span class="keyword">async</span> <span class="function"><span class="keyword">fn</span> <span class="title">new</span></span>(window: &amp;Window) -&gt; <span class="keyword">Self</span> &#123;</span><br><span class="line">        todo!()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">resize</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, new_size: winit::dpi::PhysicalSize&lt;<span class="built_in">u32</span>&gt;) &#123;</span><br><span class="line">        todo!()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">input</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, event: &amp;WindowEvent) -&gt; <span class="built_in">bool</span> &#123;</span><br><span class="line">        todo!()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">update</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) &#123;</span><br><span class="line">        todo!()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">render</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) -&gt; <span class="built_in">Result</span>&lt;(), wgpu::SwapChainError&gt; &#123;</span><br><span class="line">        todo!()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>I’m glossing over States fields, but they’ll make more sense as I explain the code behind the methods.</p>
<p>我对States字段进行了润色，但当我解释方法背后的代码时，它们会更有意义。</p>
<h1 id="State-new"><a href="#State-new" class="headerlink" title="State::new()"></a>State::new()</h1><p>The code for this is pretty straight forward, but let’s break this down a bit.</p>
<p>这方面的代码非常简单，但是让我们把它分解一下。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span> State &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">async</span> <span class="function"><span class="keyword">fn</span> <span class="title">new</span></span>(window: &amp;Window) -&gt; <span class="keyword">Self</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> size = window.inner_size();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// The instance is a handle to our GPU</span></span><br><span class="line">        <span class="comment">// BackendBit::PRIMARY =&gt; Vulkan + Metal + DX12 + Browser WebGPU</span></span><br><span class="line">        <span class="keyword">let</span> instance = wgpu::Instance::new(wgpu::BackendBit::PRIMARY);</span><br><span class="line">        <span class="keyword">let</span> surface = <span class="keyword">unsafe</span> &#123; instance.create_surface(window) &#125;;</span><br><span class="line">        <span class="keyword">let</span> adapter = instance.request_adapter(</span><br><span class="line">            &amp;wgpu::RequestAdapterOptions &#123;</span><br><span class="line">                power_preference: wgpu::PowerPreference::default(),</span><br><span class="line">                compatible_surface: <span class="literal">Some</span>(&amp;surface),</span><br><span class="line">            &#125;,</span><br><span class="line">        ).<span class="keyword">await</span>.unwrap();</span><br></pre></td></tr></table></figure>

<p>The surface is used to create the swap_chain. Our window needs to implement raw-window-handle’s HasRawWindowHandle trait to access the native window implementation for wgpu to properly create the graphics backend. Fortunately, winit’s Window fits the bill. We also need it to request our adapter.</p>
<p>surface用于创建swap_chain。我们的窗口需要实现原始raw-window-handle’s HasRawWindowHandle特性，以便wgpu访问本机窗口实现，从而正确创建图形后端。幸运的是，winit的窗口符合要求。我们还需要它来请求适配器。</p>
<blockquote>
<p>The options I’ve passed to request_adapter aren’t guaranteed to work for all devices, but will work for most of them. If you want to get all adapters for a particular backend you can use enumerate_adapters. This will give you an iterator that you can loop over to check if one of the adapters works for your needs.<br>我传递给request_adapter的选项不能保证对所有设备都有效，但对大多数设备都有效。如果要获取特定后端的所有适配器，可以使用enumerate_adapters。这将为您提供一个迭代器，您可以循环检查其中一个适配器是否满足您的需要。</p>
</blockquote>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> adapter = instance</span><br><span class="line">   .enumerate_adapters(wgpu::BackendBit::PRIMARY)</span><br><span class="line">   .filter(|adapter| &#123;</span><br><span class="line">       <span class="comment">// Check if this adapter supports our surface</span></span><br><span class="line">       adapter.get_swap_chain_preferred_format(&amp;surface).is_some()</span><br><span class="line">   &#125;)</span><br><span class="line">   .first()</span><br><span class="line">   .unwrap()</span><br></pre></td></tr></table></figure>

<blockquote>
<p>For more fields you can use to refine you’re search check out the docs.<br>有关可用于优化搜索的更多字段，<a target="_blank" rel="noopener" href="https://docs.rs/wgpu/0.9.0/wgpu/struct.Adapter.html">请查看文档</a></p>
</blockquote>
<p>We need the adapter to create the device and queue.<br>我们需要适配器来创建设备和队列。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> (device, queue) = adapter.request_device(</span><br><span class="line">    &amp;wgpu::DeviceDescriptor &#123;</span><br><span class="line">        features: wgpu::Features::empty(),</span><br><span class="line">        limits: wgpu::Limits::default(),</span><br><span class="line">        label: <span class="literal">None</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="literal">None</span>, <span class="comment">// Trace path</span></span><br><span class="line">).<span class="keyword">await</span>.unwrap();</span><br></pre></td></tr></table></figure>
<p>The features field on DeviceDescriptor, allows us to specify what extra features we want. For this simple example, I’ve decided not to use any extra features.<br>DeviceDescriptor上的features字段允许我们指定所需的额外功能。对于这个简单的例子，我决定不使用任何额外的特性。</p>
<blockquote>
<p>The device you have limits the features you can use. If you want to use certain features you may need to limit what devices you support, or provide work arounds.<br>You can get a list of features supported by your device using adapter.features(), or device.features().<br>You can view a full list of features here.</p>
</blockquote>
<blockquote>
<p>您拥有的设备限制了您可以使用的功能。如果您想使用某些功能，您可能需要限制您支持的设备，或提供解决方案。<br>您可以使用adapter.features（）或device.features（）获取设备支持的功能列表。<br>您可以在此处查看功能的<a target="_blank" rel="noopener" href="https://docs.rs/wgpu/0.9.0/wgpu/struct.Features.html">完整列表</a>。</p>
</blockquote>
<p>The limits field describes the limit of certain types of resource we can create. We’ll use the defaults for this tutorial, so we can support most devices. You can view a list of limits here.</p>
<p>limits字段描述了我们可以创建的特定类型资源的限制。本教程将使用默认设置，因此我们可以支持大多数设备。您可以在此处查看<a target="_blank" rel="noopener" href="https://docs.rs/wgpu/0.9.0/wgpu/struct.Limits.html">limits列表</a>。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> sc_desc = wgpu::SwapChainDescriptor &#123;</span><br><span class="line">    usage: wgpu::TextureUsage::RENDER_ATTACHMENT,</span><br><span class="line">    format: adapter.get_swap_chain_preferred_format(&amp;surface).unwrap(),</span><br><span class="line">    width: size.width,</span><br><span class="line">    height: size.height,</span><br><span class="line">    present_mode: wgpu::PresentMode::Fifo,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> swap_chain = device.create_swap_chain(&amp;surface, &amp;sc_desc);</span><br></pre></td></tr></table></figure>

<p>Here we are defining and creating the swap_chain. The usage field describes how the swap_chain’s underlying textures will be used. RENDER_ATTACHMENT specifies that the textures will be used to write to the screen (we’ll talk about more TextureUsages later).</p>
<p>这里我们定义并创建swap_chain。usage字段描述如何使用swap_chain的基础纹理。RENDER_ATTACHMENT指定纹理将用于写入屏幕（稍后我们将讨论更多纹理图像）。</p>
<p>The format defines how the swap_chains textures will be stored on the gpu. Different displays prefer different formats. We use adapter.get_swap_chain_preferred_format() to figure out the best format to use.</p>
<p>该格式定义如何将swap_chains纹理存储在gpu上。不同的显示器喜欢不同的格式。我们使用adapter.get_swap_chain_preferred_format()来找出最佳的使用格式。</p>
<p>width and height, are the width and height in pixels of the swap chain. This should usually be the width and height of the window.</p>
<p>宽度和高度是swap_chain的宽度和高度(以像素为单位)。这通常应该是窗口的宽度和高度。</p>
<p>The present_mode uses the wgpu::PresentMode enum which determines how to sync the swap chain with the display. You can see all the options in the docs</p>
<p>当前模式使用wgpu::PresentMode枚举，该枚举确定如何将swap_chain与显示同步。您可以在文档中看到<a target="_blank" rel="noopener" href="https://docs.rs/wgpu/0.9.0/wgpu/enum.PresentMode.html">所有选项</a></p>
<p>At the end of the method, we simply return the resulting struct.</p>
<p>在方法的末尾，我们只返回结构体结果。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">        <span class="keyword">Self</span> &#123;</span><br><span class="line">            surface,</span><br><span class="line">            device,</span><br><span class="line">            queue,</span><br><span class="line">            sc_desc,</span><br><span class="line">            swap_chain,</span><br><span class="line">            size,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>We’ll want to call this in our main method before we enter the event loop.</p>
<p>在进入事件循环之前，我们希望在main方法中调用它。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Since main can&#x27;t be async, we&#x27;re going to need to block</span></span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut</span> state = pollster::block_on(State::new(&amp;window));</span><br></pre></td></tr></table></figure>

<blockquote>
<p>You can use heavier libraries like async_std and tokio to make main async, so you can await futures. I’ve elected not to use these crates as this tutorial is not about writing an async application, and the futures created by wgpu do not require special executor support. We just need some way to interact with wgpu’s async functions, and the pollster crate is enough for that.</p>
</blockquote>
<blockquote>
<p>您可以使用较重的库（如async_std和tokio）来实现main函数异步，因此您可以等待futures。我选择不使用这些crates，因为本教程不是关于编写异步应用程序的，而且wgpu创建的crates不需要特殊的执行器支持。我们只需要一些与wgpu的异步函数交互的方法，the pollster crate就足够了。</p>
</blockquote>
<h1 id="resize"><a href="#resize" class="headerlink" title="resize()"></a>resize()</h1><p>If we want to support resizing in our application, we’re going to need to recreate the swap_chain everytime the window’s size changes. That’s the reason we stored the physical size and the sc_desc used to create the swapchain. With all of these, the resize method is very simple.</p>
<p>如果我们想在应用程序中支持调整大小，我们需要在每次窗口大小更改时重新创建swap_chain。这就是我们存储用于创建swap_chain的物理大小和sc_desc的原因。有了所有这些，调整大小的方法非常简单。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// impl State</span></span><br><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">resize</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, new_size: winit::dpi::PhysicalSize&lt;<span class="built_in">u32</span>&gt;) &#123;</span><br><span class="line">    <span class="keyword">if</span> new_size.width &gt; <span class="number">0</span> &amp;&amp; new_size.height &gt; <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.size = new_size;</span><br><span class="line">        <span class="keyword">self</span>.sc_desc.width = new_size.width;</span><br><span class="line">        <span class="keyword">self</span>.sc_desc.height = new_size.height;</span><br><span class="line">        <span class="keyword">self</span>.swap_chain = <span class="keyword">self</span>.device.create_swap_chain(&amp;<span class="keyword">self</span>.surface, &amp;<span class="keyword">self</span>.sc_desc);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>There’s nothing really different here from creating the swap_chain initially, so I won’t get into it.</p>
<p>这里与最初创建swap_chain没有什么不同，所以我就不谈了。</p>
<p>We call this method in main() in the event loop for the following events.</p>
<p>对于以下事件，我们在main函数的事件循环的中调用此方法。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">match</span> event &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">if</span> window_id == window.id() =&gt; <span class="keyword">if</span> !state.input(event) &#123;</span><br><span class="line">        <span class="keyword">match</span> event &#123;</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">            WindowEvent::Resized(physical_size) =&gt; &#123;</span><br><span class="line">                state.resize(*physical_size);</span><br><span class="line">            &#125;</span><br><span class="line">            WindowEvent::ScaleFactorChanged &#123; new_inner_size, .. &#125; =&gt; &#123;</span><br><span class="line">                <span class="comment">// new_inner_size is &amp;&amp;mut so we have to dereference it twice</span></span><br><span class="line">                state.resize(**new_inner_size);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="input"><a href="#input" class="headerlink" title="input()"></a>input()</h1><p>input() returns a bool to indicate whether an event has been fully processed. If the method returns true, the main loop won’t process the event any further.</p>
<p>input函数返回一个bool以指示事件是否已被完全处理。如果该方法返回true，则主循环将不再进一步处理该事件。</p>
<p>We’re just going to return false for now because we don’t have any events we want to capture.</p>
<p>我们现在只返回false，因为我们没有任何要捕获的事件。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// impl State</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">input</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, event: &amp;WindowEvent) -&gt; <span class="built_in">bool</span> &#123;</span><br><span class="line">    <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>We need to do a little more work in the event loop. We want State to have priority over main(). Doing that (and previous changes) should have your loop looking like this.</p>
<p>我们需要在事件循环中做更多的工作。我们希望State优先于main（）。这样做（以及之前的更改）应该使循环看起来像这样。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main()</span></span><br><span class="line">event_loop.run(<span class="keyword">move</span> |event, _, control_flow| &#123;</span><br><span class="line">    <span class="keyword">match</span> event &#123;</span><br><span class="line">        Event::WindowEvent &#123;</span><br><span class="line">            <span class="keyword">ref</span> event,</span><br><span class="line">            window_id,</span><br><span class="line">        &#125; <span class="keyword">if</span> window_id == window.id() =&gt; <span class="keyword">if</span> !state.input(event) &#123; <span class="comment">// UPDATED!</span></span><br><span class="line">            <span class="keyword">match</span> event &#123;</span><br><span class="line">                WindowEvent::CloseRequested</span><br><span class="line">                | WindowEvent::KeyboardInput &#123;</span><br><span class="line">                    input:</span><br><span class="line">                        KeyboardInput &#123;</span><br><span class="line">                            state: ElementState::Pressed,</span><br><span class="line">                            virtual_keycode: <span class="literal">Some</span>(VirtualKeyCode::Escape),</span><br><span class="line">                            ..</span><br><span class="line">                        &#125;,</span><br><span class="line">                    ..</span><br><span class="line">                &#125; =&gt; *control_flow = ControlFlow::Exit,</span><br><span class="line">                WindowEvent::Resized(physical_size) =&gt; &#123;</span><br><span class="line">                    state.resize(*physical_size);</span><br><span class="line">                &#125;</span><br><span class="line">                WindowEvent::ScaleFactorChanged &#123; new_inner_size, .. &#125; =&gt; &#123;</span><br><span class="line">                    state.resize(**new_inner_size);</span><br><span class="line">                &#125;</span><br><span class="line">                _ =&gt; &#123;&#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        _ =&gt; &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h1 id="update"><a href="#update" class="headerlink" title="update()"></a>update()</h1><p>We don’t have anything to update yet, so leave the method empty.</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">update</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) &#123;</span><br><span class="line">    <span class="comment">// remove `todo!()`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="render"><a href="#render" class="headerlink" title="render()"></a>render()</h1><p>Here’s where the magic happens. First we need to get a frame to render to. This will include a wgpu::Texture and wgpu::TextureView that will hold the actual image we’re drawing to (we’ll cover this more when we talk about textures).</p>
<p>这就是魔法发生的地方。首先，我们需要得到一个帧来渲染。这将包括wgpu:：Texture和wgpu:：TextureView，它们将保存我们正在绘制的实际图像（我们将在讨论纹理时详细介绍这一点）。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// impl State</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">render</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) -&gt; <span class="built_in">Result</span>&lt;(), wgpu::SwapChainError&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> frame = <span class="keyword">self</span></span><br><span class="line">        .swap_chain</span><br><span class="line">        .get_current_frame()?</span><br><span class="line">        .output;</span><br></pre></td></tr></table></figure>

<p>We also need to create a CommandEncoder to create the actual commands to send to the gpu. Most modern graphics frameworks expect commands to be stored in a command buffer before being sent to the gpu. The encoder builds a command buffer that we can then send to the gpu.</p>
<p>我们还需要创建CommandEncoder来创建发送到gpu的实际命令。大多数现代图形框架都希望命令在发送到gpu之前存储在命令缓冲区中。编码器构建一个命令缓冲区，然后我们可以将其发送到gpu。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut</span> encoder = <span class="keyword">self</span>.device.create_command_encoder(&amp;wgpu::CommandEncoderDescriptor &#123;</span><br><span class="line">    label: <span class="literal">Some</span>(<span class="string">&quot;Render Encoder&quot;</span>),</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>Now we can actually get to clearing the screen (long time coming). We need to use the encoder to create a RenderPass. The RenderPass has all the methods to do the actual drawing. The code for creating a RenderPass is a bit nested, so I’ll copy it all here, and talk about the pieces.</p>
<p>现在我们可以开始清理屏幕了（很长一段时间就要到了）。我们需要使用编码器来创建一个RenderPass。RenderPass具有进行实际绘制的所有方法。创建RenderPass的代码有点嵌套，所以我将在这里全部复制，并讨论各个部分。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">let</span> _render_pass = encoder.begin_render_pass(&amp;wgpu::RenderPassDescriptor &#123;</span><br><span class="line">            label: <span class="literal">Some</span>(<span class="string">&quot;Render Pass&quot;</span>),</span><br><span class="line">            color_attachments: &amp;[</span><br><span class="line">                wgpu::RenderPassColorAttachment &#123;</span><br><span class="line">                    view: &amp;frame.view,</span><br><span class="line">                    resolve_target: <span class="literal">None</span>,</span><br><span class="line">                    ops: wgpu::Operations &#123;</span><br><span class="line">                        load: wgpu::LoadOp::Clear(wgpu::Color &#123;</span><br><span class="line">                            r: <span class="number">0.1</span>,</span><br><span class="line">                            g: <span class="number">0.2</span>,</span><br><span class="line">                            b: <span class="number">0.3</span>,</span><br><span class="line">                            a: <span class="number">1.0</span>,</span><br><span class="line">                        &#125;),</span><br><span class="line">                        store: <span class="literal">true</span>,</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            ],</span><br><span class="line">            depth_stencil_attachment: <span class="literal">None</span>,</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// submit will accept anything that implements IntoIter</span></span><br><span class="line">    <span class="keyword">self</span>.queue.submit(std::iter::once(encoder.finish()));</span><br><span class="line"></span><br><span class="line">    <span class="literal">Ok</span>(())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>First things first, let’s talk about the {}. encoder.begin_render_pass(…) borrows encoder mutably (aka &amp;mut self). We can’t call encoder.finish() until we release that mutable borrow. The {} around encoder.begin_render_pass(…) tells rust to drop any variables within them when the code leaves that scope thus releasing the mutable borrow on encoder and allowing us to finish() it. If you don’t like the {}, you can also use drop(render_pass) to achieve the same effect.</p>
<p>首先，让我们先谈谈{}包括的代码。 encoder.begin_render_pass(…)使encoder可变(aka &amp;mut self)。在释放该可变借用之前，我们无法调用encoder.finish()。使用{}包括encoder.begin_render_pass(…)告诉rust在代码离开该范围时删除其中的任何变量，从而释放借用的可变编码器，并允许我们完成它。如果不喜欢{}，也可以使用drop(render_pass)来实现相同的效果。</p>
<p>We can get the same results by removing the {}, and the let _render_pass = line, but we need access to the _render_pass in the next tutorial, so we’ll leave it as is.</p>
<p>我们可以通过删除{}和let _render_pass=line来获得相同的结果，但是我们需要在下一个教程中访问_render_pass，所以我们将保持原样。</p>
<p>The last lines of the code tell wgpu to finish the command buffer, and to submit it to the gpu’s render queue.</p>
<p>代码的最后几行告诉wgpu完成命令缓冲区，并将其提交到gpu的渲染队列。</p>
<p>We need to update the event loop again to call this method. We’ll also call update before it too.</p>
<p>我们需要再次更新事件循环以调用此方法。我们也会在更新之前调用update。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main()</span></span><br><span class="line">event_loop.run(<span class="keyword">move</span> |event, _, control_flow| &#123;</span><br><span class="line">    <span class="keyword">match</span> event &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        Event::RedrawRequested(_) =&gt; &#123;</span><br><span class="line">            state.update();</span><br><span class="line">            <span class="keyword">match</span> state.render() &#123;</span><br><span class="line">                <span class="literal">Ok</span>(_) =&gt; &#123;&#125;</span><br><span class="line">                <span class="comment">// Recreate the swap_chain if lost</span></span><br><span class="line">                <span class="literal">Err</span>(wgpu::SwapChainError::Lost) =&gt; state.resize(state.size),</span><br><span class="line">                <span class="comment">// The system is out of memory, we should probably quit</span></span><br><span class="line">                <span class="literal">Err</span>(wgpu::SwapChainError::OutOfMemory) =&gt; *control_flow = ControlFlow::Exit,</span><br><span class="line">                <span class="comment">// All other errors (Outdated, Timeout) should be resolved by the next frame</span></span><br><span class="line">                <span class="literal">Err</span>(e) =&gt; eprintln!(<span class="string">&quot;&#123;:?&#125;&quot;</span>, e),</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        Event::MainEventsCleared =&gt; &#123;</span><br><span class="line">            <span class="comment">// RedrawRequested will only trigger once, unless we manually</span></span><br><span class="line">            <span class="comment">// request it.</span></span><br><span class="line">            window.request_redraw();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h1 id="Wait-what’s-going-on-with-RenderPassDescriptor"><a href="#Wait-what’s-going-on-with-RenderPassDescriptor" class="headerlink" title="Wait, what’s going on with RenderPassDescriptor?"></a>Wait, what’s going on with RenderPassDescriptor?</h1><p>Some of you may be able to tell what’s going on just by looking at it, but I’d be remiss if I didn’t go over it. Let’s take a look at the code again.</p>
<p>你们中的一些人可能仅仅通过看它就能知道发生了什么，但如果我不仔细看一下，那我就是失职了。让我们再看一遍代码。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&amp;wgpu::RenderPassDescriptor &#123;</span><br><span class="line">    label: <span class="literal">Some</span>(<span class="string">&quot;Render Pass&quot;</span>),</span><br><span class="line">    color_attachments: &amp;[</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    ],</span><br><span class="line">    depth_stencil_attachment: <span class="literal">None</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>A RenderPassDescriptor only has three fields: label, color_attachments and depth_stencil_attachment. The color_attachements describe where we are going to draw our color to. We’ll use depth_stencil_attachment later, but we’ll set it to None for now.</p>
<p>RenderPassDescriptor只有三个字段：label、color_attachments和depth_stencil_attachment。color_attachments描述了我们将在何处绘制颜色。稍后我们将使用depth_stencil_attachment，但现在将其设置为None。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">wgpu::RenderPassColorAttachment &#123;</span><br><span class="line">    view: &amp;frame.view,</span><br><span class="line">    resolve_target: <span class="literal">None</span>,</span><br><span class="line">    ops: wgpu::Operations &#123;</span><br><span class="line">        load: wgpu::LoadOp::Clear(wgpu::Color &#123;</span><br><span class="line">            r: <span class="number">0.1</span>,</span><br><span class="line">            g: <span class="number">0.2</span>,</span><br><span class="line">            b: <span class="number">0.3</span>,</span><br><span class="line">            a: <span class="number">1.0</span>,</span><br><span class="line">        &#125;),</span><br><span class="line">        store: <span class="literal">true</span>,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>The RenderPassColorAttachment has the view field which informs wgpu what texture to save the colors to. In this case we specify frame.view that we created using swap_chain.get_current_frame(). This means that any colors we draw to this attachment will get drawn to the screen.</p>
<p>RenderPassColorAttachment有一个视图字段，用于通知wgpu要保存颜色的纹理。在本例中，我们指定使用swap_chain.get_current_frame()创建的frame.view。这意味着我们在此附件中绘制的任何颜色都将被绘制到屏幕上。</p>
<p>The resolve_target is the texture that will receive the resolved output. This will be the same as attachment unless multisampling is enabled. We don’t need to specify this, so we leave it as None.</p>
<p>resolve_target是将接收解析输出的纹理。除非启用了多重采样，否则这将与attachment相同。我们不需要指定它，所以我们将其保留为None。</p>
<p>The ops field takes a wpgu::Operations object. This tells wgpu what to do with the colors on the screen (specified by frame.view). The load field tells wgpu how to handle colors stored from the previous frame. Currently we are clearing the screen with a bluish color.</p>
<p>ops字段接受一个wpgu::Operations对象。这告诉wgpu如何处理屏幕上的颜色(由frame.view指定)。load字段告诉wgpu如何处理从上一帧存储的颜色。目前，我们正在清除带有蓝色的屏幕。</p>
<h1 id="Challenge"><a href="#Challenge" class="headerlink" title="Challenge"></a>Challenge</h1><p>Modify the input() method to capture mouse events, and update the clear color using that. Hint: you’ll probably need to use WindowEvent::CursorMoved.</p>
<p>修改input()方法以捕获鼠标事件，并使用该方法更新清除颜色。提示：您可能需要使用WindowEvent::CursorMoved。</p>
<p><a target="_blank" rel="noopener" href="https://github.com/sotrh/learn-wgpu/tree/master/code/beginner/tutorial2-swapchain/">Check out the code!</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://qianqians.github.io/2021/08/17/WebGPU%203.4.2.%20Memory%20Model/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="qianqians">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="qianqians'blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/08/17/WebGPU%203.4.2.%20Memory%20Model/" class="post-title-link" itemprop="url">WebGPU 3.4.2. Memory Model</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2021-08-17 16:53:49 / 修改时间：17:25:58" itemprop="dateCreated datePublished" datetime="2021-08-17T16:53:49+08:00">2021-08-17</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/WebGPU/" itemprop="url" rel="index"><span itemprop="name">WebGPU</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>Once a GPUDevice has been obtained during an application initialization routine, we can describe the WebGPU platform as consisting of the following layers:</p>
<ol>
<li>User agent implementing the specification.</li>
<li>Operating system with low-level native API drivers for this device.</li>
<li>Actual CPU and GPU hardware.</li>
</ol>
<p>在应用程序初始化例程中获得GPU设备后，我们可以将WebGPU平台描述为由以下层组成:</p>
<ol>
<li>实现规范的用户代理。</li>
<li>此设备具有低级本机API驱动的操作系统。</li>
<li>实际的CPU和GPU硬件。</li>
</ol>
<p>Each layer of the WebGPU platform may have different memory types that the user agent needs to consider when implementing the specification:</p>
<ul>
<li>The script-owned memory, such as an ArrayBuffer created by the script, is generally not accessible by a GPU driver.</li>
<li>A user agent may have different processes responsible for running the content and communication to the GPU driver. In this case, it uses inter-process shared memory to transfer data.</li>
<li>Dedicated GPUs have their own memory with high bandwidth, while integrated GPUs typically share memory with the system.</li>
</ul>
<p>WebGPU平台的每一层可能有不同的内存类型，用户代理在执行规范时需要考虑:</p>
<ul>
<li>脚本拥有的内存（如脚本创建的ArrayBuffer）通常不可由GPU驱动程序访问。</li>
<li>用户代理可以具有负责运行内容和与GPU驱动程序通信的不同进程。在这种情况下，它使用进程间共享内存来传输数据。</li>
<li>专用GPU拥有自己的高带宽内存，而集成GPU通常与系统共享内存。</li>
</ul>
<p>Most physical resources are allocated in the memory of type that is efficient for computation or rendering by the GPU. When the user needs to provide new data to the GPU, the data may first need to cross the process boundary in order to reach the user agent part that communicates with the GPU driver. Then it may need to be made visible to the driver, which sometimes requires a copy into driver-allocated staging memory. Finally, it may need to be transferred to the dedicated GPU memory, potentially changing the internal layout into one that is most efficient for GPUs to operate on.</p>
<p>大多数物理资源都分配在GPU高效计算或渲染的内存中。当用户需要向GPU提供新数据时，数据可能首先需要跨越进程边界以到达与GPU驱动程序通信的用户代理部分。然后可能需要使其对驱动程序可见，这有时需要将副本复制到驱动程序分配的暂存内存中。最后，可能需要将其传输到专用GPU内存，从而可能会将内部布局更改为GPU操作最有效的布局。</p>
<p>All of these transitions are done by the WebGPU implementation of the user agent.</p>
<p>所有这些转换都由用户代理的WebGPU实现完成。</p>
<blockquote>
<p>Note: This example describes the worst case, while in practice the implementation may not need to cross the process boundary, or may be able to expose the driver-managed memory directly to the user behind an ArrayBuffer, thus avoiding any data copies.</p>
</blockquote>
<blockquote>
<p>注: 本例描述了最坏的情况，而实际上实现可能不需要跨越进程边界，或者可能能够将驱动程序管理的内存直接暴露给ArrayBuffer后面的用户，从而避免任何数据拷贝。</p>
</blockquote>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://qianqians.github.io/2021/08/13/WebGPU%203.4.1.%20Timelines/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="qianqians">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="qianqians'blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/08/13/WebGPU%203.4.1.%20Timelines/" class="post-title-link" itemprop="url">WebGPU 3.4.1. Timelines</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-08-13 15:10:14" itemprop="dateCreated datePublished" datetime="2021-08-13T15:10:14+08:00">2021-08-13</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-08-17 16:45:14" itemprop="dateModified" datetime="2021-08-17T16:45:14+08:00">2021-08-17</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/WebGPU/" itemprop="url" rel="index"><span itemprop="name">WebGPU</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>A computer system with a user agent at the front-end and GPU at the back-end has components working on different timelines in parallel:</p>
<p>Content timeline<br>Associated with the execution of the Web script. It includes calling all methods described by this specification.<br>Steps executed on the content timeline look like this.</p>
<p>Device timeline<br>Associated with the GPU device operations that are issued by the user agent. It includes creation of adapters, devices, and GPU resources and state objects, which are typically synchronous operations from the point of view of the user agent part that controls the GPU, but can live in a separate OS process.<br>Steps executed on the device timeline look like this.</p>
<p>Queue timeline<br>Associated with the execution of operations on the compute units of the GPU. It includes actual draw, copy, and compute jobs that run on the GPU.<br>Steps executed on the queue timeline look like this.</p>
<p>一个前端有用户代理，后端有GPU的计算机系统的组件在不同的时间线上并行工作：</p>
<p>内容时间轴<br>与Web脚本的执行关联。它包括调用本规范描述的所有方法。<br>在内容时间轴上执行的步骤如下所示。</p>
<p>设备时间轴<br>与用户代理发出的GPU设备操作关联。它包括创建适配器、设备、GPU资源和状态对象，从控制GPU的用户代理部分的角度来看，这些通常是同步操作，并且可以存在于单独的操作系统进程中。<br>在设备时间轴上执行的步骤如下所示。</p>
<p>队列时间轴<br>与在GPU的计算单元上执行操作有关。它包括在GPU上运行的实际绘制、复制和计算作业。<br>在队列时间轴上执行的步骤如下所示。</p>
<p>In this specification, asynchronous operations are used when the result value depends on work that happens on any timeline other than the Content timeline. They are represented by callbacks and promises in JavaScript.</p>
<p>在本规范中，当结果值取决于除内容时间线以外的任何时间线上发生的工作时，将使用异步操作。它们由JavaScript中的回调和promises表示。</p>
<blockquote>
<p>EXAMPLE 1<br>GPUComputePassEncoder.dispatch():</p>
<blockquote>
<ol>
<li>User encodes a dispatch command by calling a method of the GPUComputePassEncoder which happens on the Content timeline.</li>
<li>User issues GPUQueue.submit() that hands over the GPUCommandBuffer to the user agent, which processes it on the Device timeline by calling the OS driver to do a low-level submission.</li>
<li>The submit gets dispatched by the GPU invocation scheduler onto the actual compute units for execution, which happens on the Queue timeline.</li>
</ol>
</blockquote>
<blockquote>
<ol>
<li>用户通过调用发生在内容时间轴上的GPUComputePassEncoder方法对调度命令进行编码。</li>
<li>用户发出GPUQueue.submit()，将GPUCommandBuffer移交给用户代理，用户代理通过调用操作系统驱动程序进行低级提交，在设备时间轴上对其进行处理。</li>
<li>提交由GPU调用调度器调度到实际的计算单元上执行，这发生在队列时间线上。</li>
</ol>
</blockquote>
</blockquote>
<blockquote>
<p>EXAMPLE 2<br>GPUDevice.createBuffer():</p>
<blockquote>
<ol>
<li>User fills out a GPUBufferDescriptor and creates a GPUBuffer with it, which happens on the Content timeline.</li>
<li>User agent creates a low-level buffer on the Device timeline.</li>
</ol>
</blockquote>
<blockquote>
<ol>
<li>用户填写一个GPUBufferDescriptor并用它创建一个GPUBuffer，这发生在内容时间轴上。</li>
<li>用户代理在设备时间轴上创建低级缓冲区。</li>
</ol>
</blockquote>
</blockquote>
<blockquote>
<p>EXAMPLE 3<br>GPUBuffer.mapAsync():</p>
<blockquote>
<ol>
<li>User requests to map a GPUBuffer on the Content timeline and gets a promise in return.</li>
<li>User agent checks if the buffer is currently used by the GPU and makes a reminder to itself to check back when this usage is over.</li>
<li>After the GPU operating on Queue timeline is done using the buffer, the user agent maps it to memory and resolves the promise.</li>
</ol>
</blockquote>
<blockquote>
<ol>
<li>用户请求将GPUBuffer映射到内容时间轴上，并得到一个promise作为返回值。</li>
<li>用户代理检查缓冲区当前是否由GPU使用，并提醒自己在使用结束时检查。</li>
<li>在GPU使用缓冲区对队列时间轴进行操作之后，用户代理将其映射到内存并resolves the promise。</li>
</ol>
</blockquote>
</blockquote>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://qianqians.github.io/2021/08/13/WebGPU%203.3.%20Coordinate%20Systems/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="qianqians">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="qianqians'blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/08/13/WebGPU%203.3.%20Coordinate%20Systems/" class="post-title-link" itemprop="url">WebGPU 3.3. Coordinate Systems</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2021-08-13 11:52:13 / 修改时间：14:49:34" itemprop="dateCreated datePublished" datetime="2021-08-13T11:52:13+08:00">2021-08-13</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/WebGPU/" itemprop="url" rel="index"><span itemprop="name">WebGPU</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <ul>
<li><p>Y-axis is up in normalized device coordinate (NDC): point(-1.0, -1.0) in NDC is located at the bottom-left corner of NDC. In addition, x and y in NDC should be between -1.0 and 1.0 inclusive, while z in NDC should be between 0.0 and 1.0 inclusive. Vertices out of this range in NDC will not introduce any errors, but they will be clipped.</p>
</li>
<li><p>Y-axis is down in framebuffer coordinate, viewport coordinate and fragment/pixel coordinate: origin(0, 0) is located at the top-left corner in these coordinate systems.</p>
</li>
<li><p>Window/present coordinate matches framebuffer coordinate.</p>
</li>
<li><p>UV of origin(0, 0) in texture coordinate represents the first texel (the lowest byte) in texture memory.</p>
</li>
<li><p>Y轴在归一化设备坐标（NDC）中向上：NDC中的点（-1.0，-1.0）位于NDC的左下角。此外，NDC中的x和y应介于-1.0和1.0之间，而NDC中的z应介于0.0和1.0之间。NDC中超出此范围的顶点不会引入任何错误，但它们将被剪裁。</p>
</li>
<li><p>Y轴在帧缓冲区坐标、视口坐标和片段/像素坐标中向下：原点（0，0）位于这些坐标系的左上角。</p>
</li>
<li><p>窗口/当前坐标与帧缓冲区坐标匹配。</p>
</li>
<li><p>纹理坐标中的UV原点（0,0）表示纹理内存中的第一个texel（最低字节）。</p>
</li>
</ul>
<p>Note: WebGPU’s coordinate systems match DirectX and Metal’s coordinate systems in a graphics pipeline.</p>
<p>注：WebGPU的坐标系在图形管道中与DirectX和Metal的坐标系匹配。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://qianqians.github.io/2021/08/10/WebGPU%203.2.%20Invalid%20Internal%20Objects%20&%20Contagious%20Invalidity/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="qianqians">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="qianqians'blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/08/10/WebGPU%203.2.%20Invalid%20Internal%20Objects%20&%20Contagious%20Invalidity/" class="post-title-link" itemprop="url">WebGPU 3.2. Invalid Internal Objects & Contagious Invalidity</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2021-08-10 14:46:03 / 修改时间：15:29:14" itemprop="dateCreated datePublished" datetime="2021-08-10T14:46:03+08:00">2021-08-10</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/WebGPU/" itemprop="url" rel="index"><span itemprop="name">WebGPU</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>If an object is successfully created, it is valid at that moment. An internal object may be invalid. It may become invalid during its lifetime, but it will never become valid again.</p>
<p>如果成功创建了一个对象，则该对象此时有效。内部对象可能无效。它可能在其生命周期内失效，并且永远不会再次生效。</p>
<p>Invalid objects result from a number of situations, including:<br>&nbsp;If there is an error in the creation of an object, it is immediately invalid. This can happen, for example, if the object descriptor doesn’t describe a valid object, or if there is not enough memory to allocate a resource.<br>&nbsp;If an object is explicitly destroyed (e.g. GPUBuffer.destroy()), it becomes invalid.<br>&nbsp;If the device that owns an object is lost, the object becomes invalid.</p>
<p>无效对象由多种情况造成，包括：<br>&nbsp;如果在创建对象时出错，则该对象立即无效。例如，如果对象描述符没有描述有效的对象，或者没有足够的内存来分配资源，就会发生这种情况。<br>&nbsp;如果对象被显式销毁(例如GPUBuffer.destroy())，则该对象将无效。<br>&nbsp;如果拥有对象的设备丢失，该对象将无效。</p>
<p>To determine if a given GPUObjectBase object is valid to use with a targetObject, run the following steps:<br>&nbsp;1.If any of the following conditions are unsatisfied return false:<br>&nbsp;&nbsp;object is valid<br>&nbsp;&nbsp;object.[[device]] is valid.<br>&nbsp;&nbsp;object.[[device]] is targetObject.[[device]].<br>&nbsp;2.Return true.</p>
<p>要确定给定的GPUObjectBase对象是否可与targetObject一起使用，请运行以下步骤：<br>&nbsp;1.如果以下任一条件不满足，则返回false：<br>&nbsp;&nbsp;对象是有效的<br>&nbsp;&nbsp;object.[[device]]是有效的<br>&nbsp;&nbsp;object.[[device]]是targetObject.[[device]].<br>&nbsp;2.返回true.</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://qianqians.github.io/2021/08/10/WebGPU%203.1.%20Conventions/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="qianqians">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="qianqians'blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/08/10/WebGPU%203.1.%20Conventions/" class="post-title-link" itemprop="url">WebGPU 3.1. Conventions</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2021-08-10 10:24:11 / 修改时间：11:35:30" itemprop="dateCreated datePublished" datetime="2021-08-10T10:24:11+08:00">2021-08-10</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/WebGPU/" itemprop="url" rel="index"><span itemprop="name">WebGPU</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>3.1.1. Dot Syntax</p>
<p>In this specification, the . (“dot”) syntax, common in programming languages, is used. The phrasing “Foo.Bar” means “the Bar member of the value (or interface) Foo.”</p>
<p>在本规范中，使用编程语言中常见的(“点”)语法。短语”Foo.Bar”表示”对象(或接口)Foo的Bar成员”</p>
<p>The ?. (“optional chaining”) syntax, adopted from JavaScript, is also used. The phrasing “Foo?.Bar” means “if Foo is null or undefined, Foo; otherwise, Foo.Bar”.</p>
<p>采纳自JavaScript的”?.”语法同样被使用。”Foo?.Bar”表示”如果Foo为null或undefined，则为undefined；否则，Foo.Bar”。</p>
<p>For example, where buffer is a GPUBuffer, buffer?.[[device]].[[adapter]] means “if buffer is null or undefined, then undefined, otherwise, the [[adapter]] internal slot of the [[device]] internal slot of buffer.</p>
<p>例如，buffer是一个GPUBuffer对象，buffer?.[[device]].[[adapter]]表示”如果buffer为null或undefined，则为undefined，否则buffer的内部插槽[[device]]的内部插槽[[adapter]]”</p>
<p>3.1.2. Internal Objects</p>
<p>An internal object is a conceptual, non-exposed WebGPU object. Internal objects track the state of an API object and hold any underlying implementation. If the state of a particular internal object can change in parallel from multiple agents, those changes are always atomic with respect to all agents.</p>
<p>内部对象是概念性的、未公开的WebGPU对象。内部对象跟踪API对象的状态并保存任何底层实现。如果特定内部对象的状态可以从多个代理并行更改，那么这些更改对于所有代理来说都是原子性的。</p>
<p>Note: An “agent” refers to a JavaScript “thread” (i.e. main thread, or Web Worker).</p>
<p>注：”agent”是指JavaScript”线程”(即主线程或Web工作线程)。</p>
<p>3.1.3. WebGPU Interfaces</p>
<p>A WebGPU interface is an exposed interface which encapsulates an internal object. It provides the interface through which the internal object’s state is changed.</p>
<p>WebGPU接口是封装内部对象的公开接口。它提供用于更改内部对象状态的接口。</p>
<p>As a matter of convention, if a WebGPU interface is referred to as invalid, it means that the internal object it encapsulates is invalid.</p>
<p>按照惯例，如果WebGPU接口被援引为无效，则意味着它封装的内部对象无效。</p>
<p>Any interface which includes GPUObjectBase is a WebGPU interface.</p>
<p>任何包含GPUObjectBase的接口都是WebGPU接口。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">interface mixin GPUObjectBase &#123;</span><br><span class="line">    attribute USVString? label;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>GPUObjectBase has the following attributes:</p>
<p>GPUObjectBase具有以下属性:</p>
<p>label, of type USVString, nullable<br>A label which can be used by development tools (such as error/warning messages, browser developer tools, or platform debugging utilities) to identify the underlying internal object to the developer. It has no specified format, and therefore cannot be reliably machine-parsed.</p>
<p>In any given situation, the user agent may or may not choose to use this label.</p>
<p>label, USVString类型，可为空<br>开发工具（如错误/警告消息、浏览器开发工具或平台调试实用程序）可以使用的标签，用于向开发人员标识底层内部对象。它没有指定的格式，因此无法可靠地进行机器分析。</p>
<p>在任何给定的情况下，用户代理都可能或可能不选择使用此标签。</p>
<p>GPUObjectBase has the following internal slots:</p>
<p>[[device]], of type device, readonly<br>    An internal slot holding the device which owns the internal object.</p>
<p>[[device]], 类型device, 只读<br>    一个内部插槽持有拥有内部对象的设备</p>
<p>3.1.4. Object Descriptors</p>
<p>An object descriptor holds the information needed to create an object, which is typically done via one of the create* methods of GPUDevice.</p>
<p>对象描述符保存创建对象所需的信息，这通常通过GPUDevice的create*方法之一完成。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dictionary GPUObjectDescriptorBase &#123;</span><br><span class="line">    USVString label;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>GPUObjectDescriptorBase has the following members:</p>
<p>label, of type USVString<br>    The initial value of GPUObjectBase.label.</p>
<p>GPUObjectDescriptorBase有如下成员:</p>
<p>label, USVString类型<br>    GPUObjectBase.label的初始值。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://qianqians.github.io/2021/08/09/WebGPU%202.8.%20Privacy/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="qianqians">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="qianqians'blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/08/09/WebGPU%202.8.%20Privacy/" class="post-title-link" itemprop="url">WebGPU 2.8. Privacy</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2021-08-09 14:48:47 / 修改时间：15:12:06" itemprop="dateCreated datePublished" datetime="2021-08-09T14:48:47+08:00">2021-08-09</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/WebGPU/" itemprop="url" rel="index"><span itemprop="name">WebGPU</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>2.8.1. Machine-specific limits</p>
<p>WebGPU can expose a lot of detail on the underlying GPU architecture and the device geometry. This includes available physical adapters, many limits on the GPU and CPU resources that could be used (such as the maximum texture size), and any optional hardware-specific capabilities that are available. </p>
<p>WebGPU可以公开很多关于底层GPU架构和设备几何结构的细节。这包括可用的物理适配器、对可使用的GPU和CPU资源的许多限制（如最大纹理大小）以及任何可选的硬件特定功能。</p>
<p>User agents are not obligated to expose the real hardware limits, they are in full contol of how much the machine specifics are exposed. One strategy to reduce fingeprinting is binning all the target platforms into a few number of bins. In general, the privacy impact of exposing the hardware limits matches the one of WebGL.</p>
<p>用户代理没有义务公开真正的硬件限制，他们完全控制机器细节的公开程度。减少fingeprinting的一个策略是将所有目标平台放入几个箱子中。一般来说，公开硬件限制对隐私的影响与WebGL的影响相匹配。</p>
<p>The default limits are also deliberately high enough to allow most application to work without requesting higher limits. All the usage of the API is validated according to the requested limits, so the actual hardware capabilities are not exposed to the users by accident.</p>
<p>默认限制也有意设置得足够高，以允许大多数应用程序在不请求更高限制的情况下工作。API的所有使用都是根据请求的限制进行验证的，因此实际的硬件功能不会意外地暴露给用户。</p>
<p>2.8.2. Machine-specific artifacts</p>
<p>There are some machine-specific rasterization/precision artifacts and performance differences that can be observed roughly in the same way as in WebGL. This applies to rasterization coverage and patterns, interpolation precision of the varyings between shader stages, compute unit scheduling, and more aspects of execution.</p>
<p>存在一些特定于机器的光栅化/精度瑕疵和性能差异，其观察方式与WebGL大致相同。这适用于光栅化覆盖率和模式、着色器阶段之间变量的插值精度、计算单元调度以及执行的更多方面。</p>
<p>Generally, rasterization and precision fingerprints are identical across most or all of the devices of each vendor. Performance differences are relatively intractable, but also relatively low-signal (as with JS execution performance).</p>
<p>通常，每个供应商的大部分或所有设备上的光栅化和精确指纹都是相同的。性能差异比较棘手，但信号也相对较低（与JS执行性能一样）。</p>
<p>Privacy-critical applications and user agents should utilize software implementations to eliminate such artifacts.</p>
<p>隐私关键型应用程序和用户代理应利用软件实现消除此类组件。</p>
<p>2.8.3. Machine-specific performance</p>
<p>Another factor for differentiating users is measuring the performance of specific operations on the GPU. Even with low precision timing, repeated execution of an operation can show if the user’s machine is fast at specific workloads. This is a fairly common vector (present in both WebGL and Javascript), but it’s also low-signal and relatively intractable to truly normalize.</p>
<p>区分用户的另一个因素是衡量GPU上特定操作的性能。即使使用低精度计时，重复执行操作也可以显示用户的机器在特定工作负载下是否快速。这是一个相当常见的向量（存在于WebGL和Javascript中），但它也是一个低信号，要真正规范化它相对困难。</p>
<p>WebGPU compute pipelines expose access to GPU unobstructed by the fixed-function hardware. This poses an additional risk for unique device fingerprinting. User agents can take steps to dissociate logical GPU invocations with actual compute units to reduce this risk.</p>
<p>WebGPU计算管道公开对GPU的访问，不受固定功能硬件的阻碍。这给独特的设备指纹识别带来了额外的风险。用户代理可以采取步骤将逻辑GPU调用与实际计算单元分离，以降低这种风险。</p>
<p>2.8.4. User Agent State</p>
<p>This specification doesn’t define any additional user-agent state for an origin. However it is expected that user agents will have compilation caches for the result of expensive compilation like GPUShaderModule, GPURenderPipeline and GPUComputePipeline. These caches are important to improve the loading time of WebGPU applications after the first visit.</p>
<p>此规范没有为源定义任何其他用户代理状态。但是，预计用户代理将为昂贵的编译结果（如GPUShaderModule、GPURenderPipeline和GPUComputePipeline）提供编译缓存。这些缓存对于提高首次访问后WebGPU应用程序的加载时间非常重要。</p>
<p>For the specification, these caches are indifferentiable from incredibly fast compilation, but for applications it would be easy to measure how long createComputePipelineAsync() takes to resolve. This can leak information across origins (like “did the user access a site with this specific shader”) so user agents should follow the best practices in storage partitioning.</p>
<p>对于规范来说，这些缓存与异常快速的编译是不可区分的，但是对于应用程序来说，很容易测量createComputePipelineAsync()解析所需的时间。这可能会跨源泄漏信息（如“用户是否使用此特定着色器访问了站点”），因此用户代理应遵循存储分区中的最佳做法。</p>
<p>The system’s GPU driver may also have its own cache of compiled shaders and pipelines. User agents may want to disable these when at all possible, or add per-partition data to shaders in ways that will make the GPU driver consider them different.</p>
<p>系统的GPU驱动程序也可能有自己的编译着色器和管道缓存。用户代理可能想在所有可能的情况下禁用这些，或者将每个分区数据添加到着色器中，这将使GPU驱动程序认为它们是不同的。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://qianqians.github.io/2021/08/09/WebGPU%202.7.%20Workload%20identification/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="qianqians">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="qianqians'blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/08/09/WebGPU%202.7.%20Workload%20identification/" class="post-title-link" itemprop="url">WebGPU 2.7. Workload identification</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2021-08-09 12:13:34 / 修改时间：14:48:05" itemprop="dateCreated datePublished" datetime="2021-08-09T12:13:34+08:00">2021-08-09</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/WebGPU/" itemprop="url" rel="index"><span itemprop="name">WebGPU</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>WebGPU provides access to constrained global resources shared between different programs (and web pages) running on the same machine. An application can try to indirectly probe how constrained these global resources are, in order to reason about workloads performed by other open web pages, based on the patterns of usage of these shared resources. These issues are generally analogous to issues with Javascript, such as system memory and CPU execution throughput. WebGPU does not provide any additional mitigations for this.</p>
<p>WebGPU提供对在同一台计算机上运行的不同程序（和网页）之间共享的受限全局资源的访问。应用程序可以尝试间接探测这些全局资源的约束程度，以便根据这些共享资源的使用模式推断其他开放网页执行的工作负载。这些问题通常类似于Javascript的问题，例如系统内存和CPU执行吞吐量。WebGPU不为此提供任何其他缓解措施。</p>
<p>2.7.1. Memory resources</p>
<p>WebGPU exposes fallible allocations from machine-global memory heaps, such as VRAM. This allows for probing the size of the system’s remaining available memory (for a given heap type) by attempting to allocate and watching for allocation failures.</p>
<p>WebGPU暴露了来自硬件的全局内存堆（如VRAM）的易出错的分配。这允许通过尝试分配和观察分配失败来探测系统剩余可用内存的大小（对于给定堆类型）。</p>
<p>GPUs internally have one or more (typically only two) heaps of memory shared by all running applications. When a heap is depleted, WebGPU would fail to create a resource. This is observable, which may allow a malicious application to guess what heaps are used by other applications, and how much they allocate from them.</p>
<p>GPU内部有一个或多个（通常只有两个）由所有运行的应用程序共享的内存堆。当堆耗尽时，WebGPU将无法创建资源。这是可以观察到的，这可能允许恶意应用程序猜测其他应用程序使用了哪些堆，以及它们从中分配了多少。</p>
<p>2.7.2. Computation resources</p>
<p>If one site uses WebGPU at the same time as another, it may observe the increase in time it takes to process some work. For example, if a site constantly submits compute workloads and tracks completion of work on the queue, it may observe that something else also started using the GPU.</p>
<p>如果一个站点与其他页面同时使用WebGPU，它可能会观察到处理某些工作所需的时间增加。例如，如果站点不断提交计算工作负载并跟踪队列上的工作完成情况，那么它可能会发现其他东西也开始使用GPU。</p>
<p>A GPU has many parts that can be tested independently, such as the arithmetic units, texture sampling units, atomic units, etc. A malicious application may sense when some of these units are stressed, and attempt to guess the workload of another application by analyzing the stress patterns. This is analogous to the realities of CPU execution of Javascript.</p>
<p>GPU有许多可以独立测试的部分，如算术单元、纹理采样单元、原子单元等。恶意应用程序可能会感知其中一些单元何时受到压力，并试图通过分析压力模式来猜测另一个应用程序的工作负载。这类似于Javascript的CPU执行。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://qianqians.github.io/2021/08/09/WebGPU%202.6.%20Denial%20of%20service/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="qianqians">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="qianqians'blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/08/09/WebGPU%202.6.%20Denial%20of%20service/" class="post-title-link" itemprop="url">WebGPU 2.6. Denial of service</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-08-09 12:07:58" itemprop="dateCreated datePublished" datetime="2021-08-09T12:07:58+08:00">2021-08-09</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-09-01 15:36:37" itemprop="dateModified" datetime="2021-09-01T15:36:37+08:00">2021-09-01</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/WebGPU/" itemprop="url" rel="index"><span itemprop="name">WebGPU</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>WebGPU applications have access to GPU memory and compute units. A WebGPU implementation may limit the available GPU memory to an application, in order to keep other applications responsive. For GPU processing time, a WebGPU implementation may set up “watchdog” timer that makes sure an application doesn’t cause GPU unresponsiveness for more than a few seconds. These measures are similar to those used in WebGL.</p>
<p>WebGPU应用程序可以访问显存和GPU计算单元。WebGPU实现可能会将可用GPU内存限制在应用程序上，以保持其他应用程序的响应性。对于GPU处理时间，WebGPU实现可能会设置”看门狗”计时器，以确保应用程序不会导致GPU不响应超过几秒钟。这些措施与WebGL中使用的措施类似。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://qianqians.github.io/2021/08/09/WebGPU%202.5.%20Invalid%20data/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="qianqians">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="qianqians'blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/08/09/WebGPU%202.5.%20Invalid%20data/" class="post-title-link" itemprop="url">WebGPU 2.5. Invalid data</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2021-08-09 10:37:10 / 修改时间：12:07:54" itemprop="dateCreated datePublished" datetime="2021-08-09T10:37:10+08:00">2021-08-09</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/WebGPU/" itemprop="url" rel="index"><span itemprop="name">WebGPU</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>When uploading floating-point data from CPU to GPU, or generating it on the GPU, we may end up with a binary representation that doesn’t correspond to a valid number, such as infinity or NaN (not-a-number). The GPU behavior in this case is subject to the accuracy of the GPU hardware implementation of the IEEE-754 standard. WebGPU guarantees that introducing invalid floating-point numbers would only affect the results of arithmetic computations and will not have other side effects.</p>
<p>当从CPU上传浮点数据到GPU，或在GPU上生成浮点数据时，我们可能会得到一个与有效数字不对应的二进制表示，例如无穷大或NaN（非数字）。这种情况下的GPU行为取决于GPU硬件实现的IEEE-754标准的准确性。WebGPU保证引入无效浮点数只会影响算术计算的结果，不会产生其他副作用。</p>
<p>2.5.1. Driver bugs</p>
<p>GPU drivers are subject to bugs like any other software. If a bug occurs, an attacker could possibly exploit the incorrect behavior of the driver to get access to unprivileged data. In order to reduce the risk, the WebGPU working group will coordinate with GPU vendors to integrate the WebGPU Conformance Test Suite (CTS) as part of their driver testing process, like it was done for WebGL. WebGPU implementations are expected to have workarounds for some of the discovered bugs, and disable WebGPU on drivers with known bugs that can’t be worked around.</p>
<p>GPU驱动程序和其他软件一样容易出现bug。如果出现bug，攻击者可能会利用驱动程序的错误行为来访问未经授权的数据。为了降低风险，WebGPU工作组将与GPU供应商协调，将WebGPU一致性测试套件（CTS）集成为其驱动程序测试过程的一部分，就像为WebGL所做的那样。WebGPU实现有望为一些发现的bug提供解决方案，并在存在无法解决的已知bug的驱动程序上禁用WebGPU。</p>
<p>2.5.2. Timing attacks</p>
<p>WebGPU is designed for multi-threaded use via Web Workers. As such, it is designed not to open the users to modern high-precision timing attacks. Some of the objects, like GPUBuffer or GPUQueue, have shared state which can be simultaneously accessed. This allows race conditions to occur, similar to those of accessing a SharedArrayBuffer from multiple Web Workers, which makes the thread scheduling observable.</p>
<p>WebGPU设计用于通过Web Workers进行多线程使用。因此，它的设计不会让用户受到现代高精度定时攻击。一些对象（如GPUBuffer或GPUQueue）具有可同时访问的共享状态。这允许出现竞争条件，类似于从多个Web Workers访问SharedArrayBuffer的情况，这使得线程调度可以观察到。</p>
<p>WebGPU addresses this by limiting the ability to deserialize (or share) objects only to the agents inside the agent cluster, and only if the cross-origin isolated policies are in place. This restriction matches the mitigations against the malicious SharedArrayBuffer use. Similarly, the user agent may also serialize the agents sharing any handles to prevent any concurrency entirely.</p>
<p>WebGPU通过将对象反序列化（或共享）的能力仅限于代理集群内的代理，并且仅当跨源隔离策略已就位时，解决此问题。此限制与针对恶意SharedArrayBuffer使用的缓解措施相匹配。类似地，用户代理还可以序列化共享任何句柄的代理，以完全防止任何并发。</p>
<p>In the end, the attack surface for races on shared state in WebGPU will be a small subset of the SharedArrayBuffer attacks.</p>
<p>最后，WebGPU中共享状态上的竞争攻击面将是SharedArrayBuffer攻击的一小部分。</p>
<p>WebGPU also specifies the “timestamp-query” feature, which provides high precision timing of GPU operations. The feature is optional, and a WebGPU implementation may limit its exposure only to those scenarios that are trusted. Alternatively, the timing query results could be processed by a compute shader and aligned to a lower precision.</p>
<p>WebGPU还指定”timestamp-query”功能，该功能提供GPU操作的高精度计时。该功能是可选的，WebGPU实现可能仅将其暴露限制在那些受信任的场景中。或者，计时查询结果可以由计算着色器处理，并以较低的精度对齐。</p>
<p>2.5.3. Row hammer attacks</p>
<p>Row hammer is a class of attacks that exploit the leaking of states in DRAM cells. It could be used on GPU. WebGPU does not have any specific mitigations in place, and relies on platform-level solutions, such as reduced memory refresh intervals.</p>
<p>Row-hammer是一类利用DRAM单元中状态泄漏的攻击。它可以在GPU上使用。WebGPU没有任何具体的缓解措施，依赖于平台级解决方案，如缩短内存刷新间隔。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">qianqians</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>

<script src="/js/bookmark.js"></script>




  















  

  

</body>
</html>
