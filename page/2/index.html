<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">
  <link rel="manifest" href="/images/manifest.json">
  <meta name="msapplication-config" content="/images/browserconfig.xml">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">
<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"qianqians.github.io","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"remove","padding":18,"offset":12,"onmobile":true},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":true,"scrollpercent":true},"bookmark":{"enable":true,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="qianqians&#39;blog">
<meta property="og:url" content="https://qianqians.github.io/page/2/index.html">
<meta property="og:site_name" content="qianqians&#39;blog">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="qianqians">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://qianqians.github.io/page/2/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>qianqians'blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">qianqians'blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档<span class="badge">35</span></a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>分类<span class="badge">7</span></a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-fw fa-user"></i>关于</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <a role="button" class="book-mark-link book-mark-link-fixed"></a>

  <a href="https://github.com/qianqians" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://qianqians.github.io/2023/07/06/Rust%E5%BC%80%E5%8F%91%E5%B0%8F%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="qianqians">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="qianqians'blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/07/06/Rust%E5%BC%80%E5%8F%91%E5%B0%8F%E8%AE%B0/" class="post-title-link" itemprop="url">Rust开发小记</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-07-06 20:05:45" itemprop="dateCreated datePublished" datetime="2023-07-06T20:05:45+08:00">2023-07-06</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-11-20 11:23:32" itemprop="dateModified" datetime="2023-11-20T11:23:32+08:00">2023-11-20</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Rust/" itemprop="url" rel="index"><span itemprop="name">Rust</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <ol>
<li><p>多线程共享trait</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">trait</span> <span class="title class_">T</span> &#123;&#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">B</span> &#123;&#125;</span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">T</span> <span class="keyword">for</span> <span class="title class_">B</span> &#123;&#125;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">p</span>: Arc&lt;Mutex&lt;<span class="type">Box</span>&lt;<span class="keyword">dyn</span> T&gt;&gt;&gt; = Arc::<span class="title function_ invoke__">new</span>(Mutex::<span class="title function_ invoke__">new</span>(<span class="type">Box</span>::<span class="title function_ invoke__">new</span>(B&#123;&#125;)))</span><br></pre></td></tr></table></figure>
<p>需要注意struct类型的对象和trait之间不能互转,比如:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">trait</span> <span class="title class_">T</span> &#123;&#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">B</span> &#123;&#125;</span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">T</span> <span class="keyword">for</span> <span class="title class_">B</span> &#123;&#125;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">p</span>: Arc&lt;Mutex&lt;<span class="type">Box</span>&lt;B&gt;&gt;&gt; = Arc::<span class="title function_ invoke__">new</span>(Mutex::<span class="title function_ invoke__">new</span>(<span class="type">Box</span>::<span class="title function_ invoke__">new</span>(B&#123;&#125;)))</span><br><span class="line"><span class="keyword">let</span> <span class="variable">p_trait</span>: Arc&lt;Mutex&lt;<span class="type">Box</span>&lt;<span class="keyword">dyn</span> T&gt;&gt;&gt; = p <span class="comment">//会编译不过</span></span><br></pre></td></tr></table></figure></li>
<li><p>trait中声明async函数</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[async_trait]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">trait</span> <span class="title class_">T</span> &#123;</span><br><span class="line">    <span class="keyword">async</span> <span class="keyword">fn</span> <span class="title function_">send</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, buf: &amp;[<span class="type">u8</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>生命周期标注</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::fs;</span><br><span class="line"><span class="keyword">use</span> std::io;</span><br><span class="line"><span class="keyword">use</span> serde::&#123;Deserialize, Serialize&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">load_data_from_file</span>(cfg_file: <span class="type">String</span>) <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;<span class="type">String</span>, io::Error&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">data</span> = fs::<span class="title function_ invoke__">read_to_string</span>(cfg_file)?;</span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(data)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">load_cfg_from_data</span>&lt;<span class="symbol">&#x27;a</span>, C: Deserialize&lt;<span class="symbol">&#x27;a</span>&gt; + Serialize&gt;(data: &amp;<span class="symbol">&#x27;a</span> <span class="type">String</span>) <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;C, io::Error&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">cfg</span>: C = serde_json::from_str::&lt;C&gt;(&amp;data)?;</span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(cfg)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>data在外部调用load_data_from_file获取,然后调用load_cfg_from_data时传入<br>如在load_cfg_from_data中读取写做:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::fs;</span><br><span class="line"><span class="keyword">use</span> std::io;</span><br><span class="line"><span class="keyword">use</span> serde::&#123;Deserialize, Serialize&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">load_data_from_file</span>(cfg_file: <span class="type">String</span>) <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;<span class="type">String</span>, io::Error&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">data</span> = fs::<span class="title function_ invoke__">read_to_string</span>(cfg_file)?;</span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(data)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">load_cfg_from_data</span>&lt;<span class="symbol">&#x27;a</span>, C: Deserialize&lt;<span class="symbol">&#x27;a</span>&gt; + Serialize&gt;(cfg_file: <span class="type">String</span>) <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;C, io::Error&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">data</span> = <span class="title function_ invoke__">load_data_from_file</span>(cfg_file)?;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">cfg</span>: C = serde_json::from_str::&lt;C&gt;(&amp;data)?;</span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(cfg)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>会编译不过</p>
</li>
<li><p>tokio::spawn拉起线程,传入的变量使用Arc&lt;Mutex<H>&gt;,clone后传入</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">async</span> <span class="keyword">fn</span> <span class="title function_">f</span>(_handle: Arc&lt;Mutex&lt;H&gt;&gt;) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">_clone_h</span> = _handle.<span class="title function_ invoke__">clone</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">_join</span> = tokio::<span class="title function_ invoke__">spawn</span>(<span class="keyword">async</span> <span class="keyword">move</span> &#123;</span><br><span class="line">        <span class="keyword">loop</span> &#123;</span><br><span class="line">            <span class="comment">//...</span></span><br><span class="line">            </span><br><span class="line">            <span class="keyword">let</span> <span class="variable">_clone_handle</span> = _clone_h.<span class="title function_ invoke__">clone</span>();</span><br><span class="line">            <span class="comment">//...              </span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>Future:<a target="_blank" rel="noopener" href="https://juejin.cn/post/6844903973950849031">https://juejin.cn/post/6844903973950849031</a></p>
</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://qianqians.github.io/2023/05/31/%E9%A3%9E%E8%A1%8C%E6%A3%8B%E5%BC%80%E5%8F%91%E6%89%8B%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="qianqians">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="qianqians'blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/05/31/%E9%A3%9E%E8%A1%8C%E6%A3%8B%E5%BC%80%E5%8F%91%E6%89%8B%E8%AE%B0/" class="post-title-link" itemprop="url">飞行棋开发手记</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2023-05-31 14:12:19 / 修改时间：14:37:41" itemprop="dateCreated datePublished" datetime="2023-05-31T14:12:19+08:00">2023-05-31</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E6%B8%B8%E6%88%8F/" itemprop="url" rel="index"><span itemprop="name">微信小游戏</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <ol>
<li><p>Cosos Creator Asset Bundle <a target="_blank" rel="noopener" href="https://docs.cocos.com/creator/manual/zh/asset/bundle.html">https://docs.cocos.com/creator/manual/zh/asset/bundle.html</a><br>因为前期没用合理的划分管理资源，不同scene之间共用资源较多，按资源打bundle远程加载比较麻烦，所以飞行棋选择了直接按scene打bundle，实际操作效果不错，加载scene的时候远程加载既可</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">assetManager.loadBundle(<span class="string">&#x27;main_scene&#x27;</span>, <span class="keyword">async</span> (err, bundle) =&gt; &#123;</span><br><span class="line">    bundle.loadScene(sceneName, <span class="function"><span class="keyword">function</span> (<span class="params">err, scene</span>) </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;);</span><br><span class="line">    ...</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li>
<li><p>微信小游戏iphone不支持.m4a格式的音频，改为mp3格式运行正常</p>
</li>
<li><p>Cosos Creator ScrollView组件 </p>
<ol>
<li>滚动后会弹回初始位置，将Bounce Duration属性设置为最大值10，可以模拟不弹回的状态</li>
<li>默认状态可以滚动到无限远，需要在程序中响应ScrollView.EventType.SCROLLING事件控制<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">this</span>.view.node.on(ScrollView.EventType.SCROLLING, <span class="built_in">this</span>.scrolling_callback, <span class="built_in">this</span>);</span><br><span class="line"><span class="function"><span class="title">scrolling_callback</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> pos = <span class="built_in">this</span>.view.getScrollOffset().y;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pos &lt; - <span class="number">200</span>) &#123;</span><br><span class="line">        <span class="built_in">this</span>.view.scrollToOffset(<span class="keyword">new</span> Vec2(<span class="number">0</span>, pos), <span class="number">10</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (pos &gt; <span class="built_in">this</span>.bottom + <span class="number">200</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> maxScrollOffset = <span class="built_in">this</span>.view.getMaxScrollOffset();</span><br><span class="line">        <span class="built_in">this</span>.view.scrollToOffset(<span class="keyword">new</span> Vec2(<span class="number">0</span>, maxScrollOffset.y), <span class="number">10</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li><p>切换scene，会导致上一次的scene失效，需要重新加载scene(bundle不会失效)</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">singleton.netSingleton.bundle.loadScene(<span class="string">&#x27;main&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">err, scene</span>) </span>&#123;</span><br><span class="line">    director.runScene(scene);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li>
<li><p>director.addPersistRootNode(this.node)</p>
</li>
<li><p>tilemap坐标转cocos creator场景坐标</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">target_x = pos.x * <span class="number">64</span> + <span class="number">32</span> - game_data.layout_half_width;</span><br><span class="line">target_y=  pos.y * <span class="number">64</span> + <span class="number">32</span> - game_data.layout_half_height;</span><br><span class="line">...</span><br></pre></td></tr></table></figure></li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://qianqians.github.io/2023/05/22/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E6%B8%B8%E6%88%8F%E7%99%BB%E5%BD%95%E6%B5%81%E7%A8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="qianqians">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="qianqians'blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/05/22/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E6%B8%B8%E6%88%8F%E7%99%BB%E5%BD%95%E6%B5%81%E7%A8%8B/" class="post-title-link" itemprop="url">微信小游戏登录流程</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2023-05-22 14:24:07 / 修改时间：14:48:09" itemprop="dateCreated datePublished" datetime="2023-05-22T14:24:07+08:00">2023-05-22</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E6%B8%B8%E6%88%8F/" itemprop="url" rel="index"><span itemprop="name">微信小游戏</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>cocos creator 登录流程</p>
<ol>
<li><p>安装minigame-api-typings </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install minigame-api-typings</span><br></pre></td></tr></table></figure></li>
<li><p>代码中引用import ‘minigame-api-typings’;</p>
</li>
<li><p>调用wx登录接口</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">wx.login(&#123;</span><br><span class="line">    <span class="attr">complete</span>: <span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;login complete:&quot;</span> + <span class="built_in">JSON</span>.stringify(res));</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">fail</span>: <span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">         <span class="built_in">console</span>.log(<span class="string">&quot;login fail:&quot;</span> + <span class="built_in">JSON</span>.stringify(res));</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">success</span>: <span class="function">(<span class="params">login_res</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;login success:&quot;</span> + <span class="built_in">JSON</span>.stringify(login_res));</span><br><span class="line">        wx.getSetting(&#123;</span><br><span class="line">            <span class="attr">complete</span>: <span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">                <span class="built_in">console</span>.log(<span class="string">&quot;authSetting complete:&quot;</span>, <span class="built_in">JSON</span>.stringify(res));</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">fail</span>: <span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">                <span class="built_in">console</span>.log(<span class="string">&quot;authSetting fail:&quot;</span>, <span class="built_in">JSON</span>.stringify(res));</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">success</span>: <span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">                <span class="built_in">console</span>.log(<span class="string">&quot;authSetting:&quot;</span>, <span class="built_in">JSON</span>.stringify(res));</span><br><span class="line">                <span class="keyword">if</span> (res.authSetting[<span class="string">&#x27;scope.userInfo&#x27;</span>]) &#123;</span><br><span class="line">                    <span class="built_in">this</span>.get_user_info_login(login_res.code)</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">let</span> wxSize = wx.getSystemInfoSync();</span><br><span class="line">                    <span class="keyword">let</span> btn = wx.createUserInfoButton(&#123;</span><br><span class="line">                        <span class="attr">type</span>: <span class="string">&#x27;text&#x27;</span>,</span><br><span class="line">                        <span class="attr">text</span>: <span class="string">&#x27;微信登录&#x27;</span>,</span><br><span class="line">                        <span class="attr">style</span>: &#123;</span><br><span class="line">                            <span class="attr">left</span>: wxSize.screenWidth / <span class="number">2</span> - <span class="number">100</span>,</span><br><span class="line">                            <span class="attr">top</span>: wxSize.screenHeight / <span class="number">2</span> - <span class="number">40</span>,</span><br><span class="line">                            <span class="attr">width</span>: <span class="number">200</span>,</span><br><span class="line">                            <span class="attr">height</span>: <span class="number">40</span>,</span><br><span class="line">                            <span class="attr">lineHeight</span>: <span class="number">40</span>,</span><br><span class="line">                            <span class="attr">backgroundColor</span>: <span class="string">&#x27;#ffffff&#x27;</span>,</span><br><span class="line">                            <span class="attr">borderColor</span>: <span class="string">&#x27;#ffffff&#x27;</span>,</span><br><span class="line">                            <span class="attr">borderWidth</span>: <span class="number">1</span>,</span><br><span class="line">                            <span class="attr">color</span>: <span class="string">&#x27;#000000&#x27;</span>,</span><br><span class="line">                            <span class="attr">textAlign</span>: <span class="string">&#x27;center&#x27;</span>,</span><br><span class="line">                            <span class="attr">fontSize</span>: <span class="number">16</span>,</span><br><span class="line">                            <span class="attr">borderRadius</span>: <span class="number">4</span></span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line">                    btn.onTap(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">                        <span class="built_in">console</span>.log(<span class="string">&quot;createUserInfoButton:&quot;</span> + <span class="built_in">JSON</span>.stringify(res));</span><br><span class="line">                        <span class="built_in">this</span>.get_user_info_login(login_res.code)</span><br><span class="line">                         btn.destroy();</span><br><span class="line">                    &#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">get_user_info_login</span>(<span class="params">code:string</span>)</span> &#123;</span><br><span class="line">    wx.getUserInfo(&#123; </span><br><span class="line">        <span class="attr">withCredentials</span>:<span class="literal">false</span>,</span><br><span class="line">        <span class="attr">success</span>: <span class="function">(<span class="params">result</span>) =&gt;</span> &#123;</span><br><span class="line">            login.login_player_no_author(code, result.userInfo.nickName, result.userInfo.avatarUrl);</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">fail</span>: <span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">&quot;fail:&quot;</span> + <span class="built_in">JSON</span>.stringify(res));</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">complete</span>: <span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">&quot;complete:&quot;</span> + <span class="built_in">JSON</span>.stringify(res));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>login_player_no_author接口上传code到服务器端,服务器端收到code之后通过http请求到微信后台验证(AppID,Secret从微信小游戏管理后台获取):</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> url = <span class="string">$&quot;https://api.weixin.qq.com/sns/jscode2session?appid=<span class="subst">&#123;AppID&#125;</span>&amp;secret=<span class="subst">&#123;Secret&#125;</span>&amp;js_code=<span class="subst">&#123;code&#125;</span>&amp;grant_type=authorization_code&quot;</span>;</span><br><span class="line"><span class="keyword">var</span> result = <span class="keyword">await</span> HttpClientWrapper.GetRspAsync(url);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (result != <span class="literal">null</span> &amp;&amp; result.StatusCode == System.Net.HttpStatusCode.OK)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">var</span> ret = <span class="keyword">await</span> result.Content.ReadAsStringAsync();</span><br><span class="line">    <span class="keyword">var</span> ret_obj = Newtonsoft.Json.JsonConvert.DeserializeObject&lt;Hashtable&gt;(ret);</span><br><span class="line">    <span class="keyword">var</span> token = <span class="keyword">await</span> player.client_Mng.token_player_login(ret_obj[<span class="string">&quot;openid&quot;</span>] <span class="keyword">as</span> <span class="built_in">string</span>);</span><br><span class="line">    rsp.rsp(token);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://qianqians.github.io/2021/09/15/Wgpu%20Working%20with%20Lights/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="qianqians">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="qianqians'blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/09/15/Wgpu%20Working%20with%20Lights/" class="post-title-link" itemprop="url">Wgpu Working with Lights</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-09-15 15:18:49" itemprop="dateCreated datePublished" datetime="2021-09-15T15:18:49+08:00">2021-09-15</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-09-16 12:00:10" itemprop="dateModified" datetime="2021-09-16T12:00:10+08:00">2021-09-16</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Wgpu/" itemprop="url" rel="index"><span itemprop="name">Wgpu</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>While we can tell that our scene is 3d because of our camera, it still feels very flat. That’s because our model stays the same color regardless of how it’s oriented. If we want to change that we need to add lighting to our scene.</p>
<p>虽然我们可以看出，我们的场景是3d的，因为我们的相机，它仍然感觉非常平坦。这是因为我们的模型保持相同的颜色，无论它是如何定向的。如果我们想改变这一点，我们需要向场景中添加照明。</p>
<p>In the real world, a light source emits photons which bounce around until they enter into our eyes. The color we see is the light’s original color minus whatever energy it lost while it was bouncing around.</p>
<p>在现实世界中，光源发射光子，这些光子在周围反弹，直到它们进入我们的眼睛。我们看到的颜色是光的原始颜色减去它在反弹时损失的能量。</p>
<p>In the computer graphics world, modeling individual photons would be hilariously computationally expensive. A single 100 Watt light bulb emits about 3.27 x 10^20 photons per second. Just imagine that for the sun! To get around this, we’re gonna use math to cheat.</p>
<p>在计算机图形学领域，对单个光子进行建模在计算上会非常昂贵。一个100瓦的灯泡每秒发射大约3.27 x 10^20个光子。想象一下，为了太阳！为了避开这个问题，我们要用数学来作弊。</p>
<p>Let’s discuss a few options.</p>
<p>让我们讨论几个选项。</p>
<h1 id="Ray-Path-Tracing"><a href="#Ray-Path-Tracing" class="headerlink" title="Ray/Path Tracing"></a>Ray/Path Tracing</h1><p>This is an advanced topic, and we won’t be covering it in depth here. It’s the closest model to the way light really works so I felt I had to mention it. Check out the ray tracing tutorial if you want to learn more.</p>
<h1 id="The-Blinn-Phong-Model"><a href="#The-Blinn-Phong-Model" class="headerlink" title="The Blinn-Phong Model"></a>The Blinn-Phong Model</h1><p>Ray/path tracing is often too computationally expensive for most realtime applications (though that is starting to change), so a more efficient, if less accurate method based on the <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Phong_shading">Phong reflection model</a> is often used. It splits up the lighting calculation into three (3) parts: ambient lighting, diffuse lighting, and specular lighting. We’re going to be learning the <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Blinn%E2%80%93Phong_reflection_model">Blinn-Phong model</a>, which cheats a bit at the specular calculation to speed things up.</p>
<p>对于大多数实时应用程序来说，光线/路径跟踪在计算上往往过于昂贵(尽管这一点已经开始改变)，因此通常会使用一种基于<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Phong_shading">Phong reflection model</a>的效率更高但精度更低的方法。它将照明计算分为三部分：环境照明、漫反射照明和镜面反射照明。我们将学习<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Blinn%E2%80%93Phong_reflection_model">Blinn-Phong model</a>，它在镜面反射计算中有点作弊，以加快速度。</p>
<p>Before we can get into that though, we need to add a light to our scene.</p>
<p>在我们开始之前，需要在场景中添加灯光。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main.rs</span></span><br><span class="line"><span class="meta">#[repr(C)]</span></span><br><span class="line"><span class="meta">#[derive(Debug, Copy, Clone, bytemuck::Pod, bytemuck::Zeroable)]</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">LightUniform</span></span> &#123;</span><br><span class="line">    position: [<span class="built_in">f32</span>; <span class="number">3</span>],</span><br><span class="line">    <span class="comment">// Due to uniforms requiring 16 byte (4 float) spacing, we need to use a padding field here</span></span><br><span class="line">    _padding: <span class="built_in">u32</span>,</span><br><span class="line">    color: [<span class="built_in">f32</span>; <span class="number">3</span>],</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Our LightUniform represents a colored point in space. We’re just going to use pure white light, but it’s good to allow different colors of light.</p>
<p>我们的LightUniform代表空间中的一个彩色点。我们将使用纯白光，但允许不同颜色的光是很好的。</p>
<p>We’re going to create another buffer to store our light in.</p>
<p>我们将创建另一个缓冲区来存储光线。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> light_uniform = LightUniform &#123;</span><br><span class="line">    position: [<span class="number">2.0</span>, <span class="number">2.0</span>, <span class="number">2.0</span>],</span><br><span class="line">    _padding: <span class="number">0</span>,</span><br><span class="line">    color: [<span class="number">1.0</span>, <span class="number">1.0</span>, <span class="number">1.0</span>],</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// We&#x27;ll want to update our lights position, so we use COPY_DST</span></span><br><span class="line"><span class="keyword">let</span> light_buffer = device.create_buffer_init(</span><br><span class="line">    &amp;wgpu::util::BufferInitDescriptor &#123;</span><br><span class="line">        label: <span class="literal">Some</span>(<span class="string">&quot;Light VB&quot;</span>),</span><br><span class="line">        contents: bytemuck::cast_slice(&amp;[light_uniform]),</span><br><span class="line">        usage: wgpu::BufferUsage::UNIFORM | wgpu::BufferUsage::COPY_DST,</span><br><span class="line">    &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>Don’t forget to add the light_uniform and light_buffer to State. After that we need to create a bind group layout and bind group for our light.</p>
<p>别忘了将light_uniform和light_buffer添加到State。之后，我们需要为灯光创建bind group layout和bind group。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> light_bind_group_layout =</span><br><span class="line">    device.create_bind_group_layout(&amp;wgpu::BindGroupLayoutDescriptor &#123;</span><br><span class="line">        entries: &amp;[wgpu::BindGroupLayoutEntry &#123;</span><br><span class="line">            binding: <span class="number">0</span>,</span><br><span class="line">            visibility: wgpu::ShaderStage::VERTEX | wgpu::ShaderStage::FRAGMENT,</span><br><span class="line">            ty: wgpu::BindingType::Buffer &#123;</span><br><span class="line">                ty: wgpu::BufferBindingType::Uniform,</span><br><span class="line">                has_dynamic_offset: <span class="literal">false</span>,</span><br><span class="line">                min_binding_size: <span class="literal">None</span>,</span><br><span class="line">            &#125;,</span><br><span class="line">            count: <span class="literal">None</span>,</span><br><span class="line">        &#125;],</span><br><span class="line">        label: <span class="literal">None</span>,</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> light_bind_group = device.create_bind_group(&amp;wgpu::BindGroupDescriptor &#123;</span><br><span class="line">    layout: &amp;light_bind_group_layout,</span><br><span class="line">    entries: &amp;[wgpu::BindGroupEntry &#123;</span><br><span class="line">        binding: <span class="number">0</span>,</span><br><span class="line">        resource: light_buffer.as_entire_binding(),</span><br><span class="line">    &#125;],</span><br><span class="line">    label: <span class="literal">None</span>,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>Add those to State, and also update the render_pipeline_layout.</p>
<p>将这些添加到State，并更新render_pipeline_layout。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> render_pipeline_layout = device.create_pipeline_layout(&amp;wgpu::PipelineLayoutDescriptor &#123;</span><br><span class="line">    bind_group_layouts: &amp;[</span><br><span class="line">        &amp;texture_bind_group_layout, </span><br><span class="line">        &amp;camera_bind_group_layout,</span><br><span class="line">        &amp;light_bind_group_layout,</span><br><span class="line">    ],</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>Let’s also update the lights position in the update() method, so we can see what our objects look like from different angles.</p>
<p>我们还将更新update()方法中的灯光位置，以便从不同角度查看对象的外观。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Update the light</span></span><br><span class="line"><span class="keyword">let</span> old_position: cgmath::Vector3&lt;_&gt; = <span class="keyword">self</span>.light_uniform.position.into();</span><br><span class="line"><span class="keyword">self</span>.light_uniform.position =</span><br><span class="line">    cgmath::Quaternion::from_axis_angle((<span class="number">0.0</span>, <span class="number">1.0</span>, <span class="number">0.0</span>).into(), cgmath::Deg(<span class="number">1.0</span>))</span><br><span class="line">        * old_position;</span><br><span class="line"><span class="keyword">self</span>.queue.write_buffer(&amp;<span class="keyword">self</span>.light_buffer, <span class="number">0</span>, bytemuck::cast_slice(&amp;[<span class="keyword">self</span>.light_uniform]));</span><br></pre></td></tr></table></figure>

<p>This will have the light rotate around the origin one degree every frame.</p>
<p>这将使灯光每帧围绕原点旋转一度。</p>
<h1 id="Seeing-the-light"><a href="#Seeing-the-light" class="headerlink" title="Seeing the light"></a>Seeing the light</h1><p>For debugging purposes, it would be nice if we could see where the light is to make sure that the scene looks correct. We could adapt our existing render pipeline to draw the light, but it will likely get in the way. Instead we are going to extract our render pipeline creation code into a new function called create_render_pipeline().</p>
<p>出于调试目的，如果我们能够看到灯光的位置，以确保场景看起来正确，那就太好了。我们可以调整现有的渲染管道来绘制灯光，但这可能会造成阻碍。相反，我们将把渲染管道创建代码提取到一个名为create_render_pipeline()的新函数中。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">create_render_pipeline</span></span>(</span><br><span class="line">    device: &amp;wgpu::Device,</span><br><span class="line">    layout: &amp;wgpu::PipelineLayout,</span><br><span class="line">    color_format: wgpu::TextureFormat,</span><br><span class="line">    depth_format: <span class="built_in">Option</span>&lt;wgpu::TextureFormat&gt;,</span><br><span class="line">    vertex_layouts: &amp;[wgpu::VertexBufferLayout],</span><br><span class="line">    shader: wgpu::ShaderModuleDescriptor,</span><br><span class="line">) -&gt; wgpu::RenderPipeline &#123;</span><br><span class="line">    <span class="keyword">let</span> shader = device.create_shader_module(&amp;shader);</span><br><span class="line"></span><br><span class="line">    device.create_render_pipeline(&amp;wgpu::RenderPipelineDescriptor &#123;</span><br><span class="line">        label: <span class="literal">Some</span>(<span class="string">&quot;Render Pipeline&quot;</span>),</span><br><span class="line">        layout: <span class="literal">Some</span>(layout),</span><br><span class="line">        vertex: wgpu::VertexState &#123;</span><br><span class="line">            module: &amp;shader,</span><br><span class="line">            entry_point: <span class="string">&quot;main&quot;</span>,</span><br><span class="line">            buffers: vertex_layouts,</span><br><span class="line">        &#125;,</span><br><span class="line">        fragment: <span class="literal">Some</span>(wgpu::FragmentState &#123;</span><br><span class="line">            module: &amp;shader,</span><br><span class="line">            entry_point: <span class="string">&quot;main&quot;</span>,</span><br><span class="line">            targets: &amp;[wgpu::ColorTargetState &#123;</span><br><span class="line">                format: color_format,</span><br><span class="line">                blend: <span class="literal">Some</span>(wgpu::BlendState &#123;</span><br><span class="line">                    alpha: wgpu::BlendComponent::REPLACE,</span><br><span class="line">                    color: wgpu::BlendComponent::REPLACE,</span><br><span class="line">                &#125;),</span><br><span class="line">                write_mask: wgpu::ColorWrite::ALL,</span><br><span class="line">            &#125;],</span><br><span class="line">        &#125;),</span><br><span class="line">        primitive: wgpu::PrimitiveState &#123;</span><br><span class="line">            topology: wgpu::PrimitiveTopology::TriangleList,</span><br><span class="line">            strip_index_format: <span class="literal">None</span>,</span><br><span class="line">            front_face: wgpu::FrontFace::Ccw,</span><br><span class="line">            cull_mode: <span class="literal">Some</span>(wgpu::Face::Back),</span><br><span class="line">            <span class="comment">// Setting this to anything other than Fill requires Features::NON_FILL_POLYGON_MODE</span></span><br><span class="line">            polygon_mode: wgpu::PolygonMode::Fill,</span><br><span class="line">            <span class="comment">// Requires Features::DEPTH_CLAMPING</span></span><br><span class="line">            clamp_depth: <span class="literal">false</span>,</span><br><span class="line">            <span class="comment">// Requires Features::CONSERVATIVE_RASTERIZATION</span></span><br><span class="line">            conservative: <span class="literal">false</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">        depth_stencil: depth_format.map(|format| wgpu::DepthStencilState &#123;</span><br><span class="line">            format,</span><br><span class="line">            depth_write_enabled: <span class="literal">true</span>,</span><br><span class="line">            depth_compare: wgpu::CompareFunction::Less,</span><br><span class="line">            stencil: wgpu::StencilState::default(),</span><br><span class="line">            bias: wgpu::DepthBiasState::default(),</span><br><span class="line">        &#125;),</span><br><span class="line">        multisample: wgpu::MultisampleState &#123;</span><br><span class="line">            count: <span class="number">1</span>,</span><br><span class="line">            mask: !<span class="number">0</span>,</span><br><span class="line">            alpha_to_coverage_enabled: <span class="literal">false</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>We also need to change State::new() to use this function.</p>
<p>我们还需要更改State::new()以使用此函数。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> render_pipeline = &#123;</span><br><span class="line">    <span class="keyword">let</span> shader = wgpu::ShaderModuleDescriptor &#123;</span><br><span class="line">        label: <span class="literal">Some</span>(<span class="string">&quot;Normal Shader&quot;</span>),</span><br><span class="line">        flags: wgpu::ShaderFlags::all(),</span><br><span class="line">        source: wgpu::ShaderSource::Wgsl(<span class="built_in">include_str!</span>(<span class="string">&quot;shader.wgsl&quot;</span>).into()),</span><br><span class="line">    &#125;;</span><br><span class="line">    create_render_pipeline(</span><br><span class="line">        &amp;device,</span><br><span class="line">        &amp;render_pipeline_layout,</span><br><span class="line">        sc_desc.format,</span><br><span class="line">        <span class="literal">Some</span>(texture::Texture::DEPTH_FORMAT),</span><br><span class="line">        &amp;[model::ModelVertex::desc(), InstanceRaw::desc()],</span><br><span class="line">        shader,</span><br><span class="line">    )</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>We’re going to need to modify model::DrawModel to use our light_bind_group.</p>
<p>我们需要修改model::DrawModel以使用我们的light_bind_group。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">trait</span> <span class="title">DrawModel</span></span>&lt;<span class="symbol">&#x27;a</span>&gt; &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">draw_mesh</span></span>(</span><br><span class="line">        &amp;<span class="keyword">mut</span> <span class="keyword">self</span>,</span><br><span class="line">        mesh: &amp;<span class="symbol">&#x27;a</span> Mesh,</span><br><span class="line">        material: &amp;<span class="symbol">&#x27;a</span> Material,</span><br><span class="line">        camera: &amp;<span class="symbol">&#x27;a</span> wgpu::BindGroup,</span><br><span class="line">        light: &amp;<span class="symbol">&#x27;a</span> wgpu::BindGroup,</span><br><span class="line">    );</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">draw_mesh_instanced</span></span>(</span><br><span class="line">        &amp;<span class="keyword">mut</span> <span class="keyword">self</span>,</span><br><span class="line">        mesh: &amp;<span class="symbol">&#x27;a</span> Mesh,</span><br><span class="line">        material: &amp;<span class="symbol">&#x27;a</span> Material,</span><br><span class="line">        instances: Range&lt;<span class="built_in">u32</span>&gt;,</span><br><span class="line">        camera: &amp;<span class="symbol">&#x27;a</span> wgpu::BindGroup,</span><br><span class="line">        light: &amp;<span class="symbol">&#x27;a</span> wgpu::BindGroup,</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">draw_model</span></span>(</span><br><span class="line">        &amp;<span class="keyword">mut</span> <span class="keyword">self</span>,</span><br><span class="line">        model: &amp;<span class="symbol">&#x27;a</span> Model,</span><br><span class="line">        camera: &amp;<span class="symbol">&#x27;a</span> wgpu::BindGroup,</span><br><span class="line">        light: &amp;<span class="symbol">&#x27;a</span> wgpu::BindGroup,</span><br><span class="line">    );</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">draw_model_instanced</span></span>(</span><br><span class="line">        &amp;<span class="keyword">mut</span> <span class="keyword">self</span>,</span><br><span class="line">        model: &amp;<span class="symbol">&#x27;a</span> Model,</span><br><span class="line">        instances: Range&lt;<span class="built_in">u32</span>&gt;,</span><br><span class="line">        camera: &amp;<span class="symbol">&#x27;a</span> wgpu::BindGroup,</span><br><span class="line">        light: &amp;<span class="symbol">&#x27;a</span> wgpu::BindGroup,</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;<span class="symbol">&#x27;a</span>, <span class="symbol">&#x27;b</span>&gt; DrawModel&lt;<span class="symbol">&#x27;b</span>&gt; <span class="keyword">for</span> wgpu::RenderPass&lt;<span class="symbol">&#x27;a</span>&gt;</span><br><span class="line"><span class="keyword">where</span></span><br><span class="line">    <span class="symbol">&#x27;b</span>: <span class="symbol">&#x27;a</span>,</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">draw_mesh</span></span>(</span><br><span class="line">        &amp;<span class="keyword">mut</span> <span class="keyword">self</span>,</span><br><span class="line">        mesh: &amp;<span class="symbol">&#x27;b</span> Mesh,</span><br><span class="line">        material: &amp;<span class="symbol">&#x27;b</span> Material,</span><br><span class="line">        camera: &amp;<span class="symbol">&#x27;b</span> wgpu::BindGroup,</span><br><span class="line">        light: &amp;<span class="symbol">&#x27;b</span> wgpu::BindGroup,</span><br><span class="line">    ) &#123;</span><br><span class="line">        <span class="keyword">self</span>.draw_mesh_instanced(mesh, material, <span class="number">0</span>..<span class="number">1</span>, camera, light);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">draw_mesh_instanced</span></span>(</span><br><span class="line">        &amp;<span class="keyword">mut</span> <span class="keyword">self</span>,</span><br><span class="line">        mesh: &amp;<span class="symbol">&#x27;b</span> Mesh,</span><br><span class="line">        material: &amp;<span class="symbol">&#x27;b</span> Material,</span><br><span class="line">        instances: Range&lt;<span class="built_in">u32</span>&gt;,</span><br><span class="line">        camera: &amp;<span class="symbol">&#x27;b</span> wgpu::BindGroup,</span><br><span class="line">        light: &amp;<span class="symbol">&#x27;b</span> wgpu::BindGroup,</span><br><span class="line">    ) &#123;</span><br><span class="line">        <span class="keyword">self</span>.set_vertex_buffer(<span class="number">0</span>, &amp;mesh.vertex_buffer, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">self</span>.set_index_buffer(&amp;mesh.index_buffer, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">self</span>.set_bind_group(<span class="number">0</span>, &amp;material.bind_group, &amp;[]);</span><br><span class="line">        <span class="keyword">self</span>.set_bind_group(<span class="number">1</span>, camera, &amp;[]);</span><br><span class="line">        <span class="keyword">self</span>.set_bind_group(<span class="number">2</span>, light, &amp;[]);</span><br><span class="line">        <span class="keyword">self</span>.draw_indexed(<span class="number">0</span>..mesh.num_elements, <span class="number">0</span>, instances);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">draw_model</span></span>(</span><br><span class="line">        &amp;<span class="keyword">mut</span> <span class="keyword">self</span>,</span><br><span class="line">        model: &amp;<span class="symbol">&#x27;b</span> Model,</span><br><span class="line">        camera: &amp;<span class="symbol">&#x27;b</span> wgpu::BindGroup,</span><br><span class="line">        light: &amp;<span class="symbol">&#x27;b</span> wgpu::BindGroup,</span><br><span class="line">    ) &#123;</span><br><span class="line">        <span class="keyword">self</span>.draw_model_instanced(model, <span class="number">0</span>..<span class="number">1</span>, camera, light);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">draw_model_instanced</span></span>(</span><br><span class="line">        &amp;<span class="keyword">mut</span> <span class="keyword">self</span>,</span><br><span class="line">        model: &amp;<span class="symbol">&#x27;b</span> Model,</span><br><span class="line">        instances: Range&lt;<span class="built_in">u32</span>&gt;,</span><br><span class="line">        camera: &amp;<span class="symbol">&#x27;b</span> wgpu::BindGroup,</span><br><span class="line">        light: &amp;<span class="symbol">&#x27;b</span> wgpu::BindGroup,</span><br><span class="line">    ) &#123;</span><br><span class="line">        <span class="keyword">for</span> mesh <span class="keyword">in</span> &amp;model.meshes &#123;</span><br><span class="line">            <span class="keyword">let</span> material = &amp;model.materials[mesh.material];</span><br><span class="line">            <span class="keyword">self</span>.draw_mesh_instanced(mesh, material, instances.clone(), camera, light);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>With that done we can create another render pipeline for our light.</p>
<p>完成后，我们可以为灯光创建另一个渲染管道。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> light_render_pipeline = &#123;</span><br><span class="line">    <span class="keyword">let</span> layout = device.create_pipeline_layout(&amp;wgpu::PipelineLayoutDescriptor &#123;</span><br><span class="line">        label: <span class="literal">Some</span>(<span class="string">&quot;Light Pipeline Layout&quot;</span>),</span><br><span class="line">        bind_group_layouts: &amp;[&amp;camera_bind_group_layout, &amp;light_bind_group_layout],</span><br><span class="line">        push_constant_ranges: &amp;[],</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">let</span> shader = wgpu::ShaderModuleDescriptor &#123;</span><br><span class="line">        label: <span class="literal">Some</span>(<span class="string">&quot;Light Shader&quot;</span>),</span><br><span class="line">        flags: wgpu::ShaderFlags::all(),</span><br><span class="line">        source: wgpu::ShaderSource::Wgsl(<span class="built_in">include_str!</span>(<span class="string">&quot;light.wgsl&quot;</span>).into()),</span><br><span class="line">    &#125;;</span><br><span class="line">    create_render_pipeline(</span><br><span class="line">        &amp;device,</span><br><span class="line">        &amp;layout,</span><br><span class="line">        sc_desc.format,</span><br><span class="line">        <span class="literal">Some</span>(texture::Texture::DEPTH_FORMAT),</span><br><span class="line">        &amp;[model::ModelVertex::desc()],</span><br><span class="line">        shader,</span><br><span class="line">    )</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>I chose to create a seperate layout for the light_render_pipeline, as it doesn’t need all the resources that the regular render_pipeline needs (main just the textures).</p>
<p>我选择为light_render_pipeline创建一个单独的layout，因为它不需要常规render_pipeline需要的所有资源(纹理)。</p>
<p>With that in place we need to write the actual shaders.</p>
<p>接着我们需要编写实际的着色器。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Vertex shader</span></span><br><span class="line"></span><br><span class="line">[[block]]</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Camera</span></span> &#123;</span><br><span class="line">    view_proj: mat4x4&lt;<span class="built_in">f32</span>&gt;;</span><br><span class="line">&#125;;</span><br><span class="line">[[group(<span class="number">0</span>), binding(<span class="number">0</span>)]]</span><br><span class="line">var&lt;uniform&gt; camera: Camera;</span><br><span class="line"></span><br><span class="line">[[block]]</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Light</span></span> &#123;</span><br><span class="line">    position: vec3&lt;<span class="built_in">f32</span>&gt;;</span><br><span class="line">    color: vec3&lt;<span class="built_in">f32</span>&gt;;</span><br><span class="line">&#125;;</span><br><span class="line">[[group(<span class="number">1</span>), binding(<span class="number">0</span>)]]</span><br><span class="line">var&lt;uniform&gt; light: Light;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">VertexInput</span></span> &#123;</span><br><span class="line">    [[location(<span class="number">0</span>)]] position: vec3&lt;<span class="built_in">f32</span>&gt;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">VertexOutput</span></span> &#123;</span><br><span class="line">    [[builtin(position)]] clip_position: vec4&lt;<span class="built_in">f32</span>&gt;;</span><br><span class="line">    [[location(<span class="number">0</span>)]] color: vec3&lt;<span class="built_in">f32</span>&gt;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">[[stage(vertex)]]</span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>(</span><br><span class="line">    model: VertexInput,</span><br><span class="line">) -&gt; VertexOutput &#123;</span><br><span class="line">    <span class="keyword">let</span> scale = <span class="number">0.25</span>;</span><br><span class="line">    var out: VertexOutput;</span><br><span class="line">    out.clip_position = camera.view_proj * vec4&lt;<span class="built_in">f32</span>&gt;(model.position * scale + light.position, <span class="number">1.0</span>);</span><br><span class="line">    out.color = light.color;</span><br><span class="line">    <span class="keyword">return</span> out;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Fragment shader</span></span><br><span class="line"></span><br><span class="line">[[stage(fragment)]]</span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>(<span class="keyword">in</span>: VertexOutput) -&gt; [[location(<span class="number">0</span>)]] vec4&lt;<span class="built_in">f32</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> vec4&lt;<span class="built_in">f32</span>&gt;(<span class="keyword">in</span>.color, <span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Now we could manually implement the draw code for the light in render(), but to keep with the pattern we developed, let’s create a new trait called DrawLight.</p>
<p>现在我们可以在render()中手动实现灯光的绘制代码，但是为了保持我们开发的模式，让我们创建一个名为DrawLight的新trait。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">trait</span> <span class="title">DrawLight</span></span>&lt;<span class="symbol">&#x27;a</span>&gt; &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">draw_light_mesh</span></span>(</span><br><span class="line">        &amp;<span class="keyword">mut</span> <span class="keyword">self</span>,</span><br><span class="line">        mesh: &amp;<span class="symbol">&#x27;a</span> Mesh,</span><br><span class="line">        camera: &amp;<span class="symbol">&#x27;a</span> wgpu::BindGroup,</span><br><span class="line">        light: &amp;<span class="symbol">&#x27;a</span> wgpu::BindGroup,</span><br><span class="line">    );</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">draw_light_mesh_instanced</span></span>(</span><br><span class="line">        &amp;<span class="keyword">mut</span> <span class="keyword">self</span>,</span><br><span class="line">        mesh: &amp;<span class="symbol">&#x27;a</span> Mesh,</span><br><span class="line">        instances: Range&lt;<span class="built_in">u32</span>&gt;,</span><br><span class="line">        camera: &amp;<span class="symbol">&#x27;a</span> wgpu::BindGroup,</span><br><span class="line">        light: &amp;<span class="symbol">&#x27;a</span> wgpu::BindGroup,</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">draw_light_model</span></span>(</span><br><span class="line">        &amp;<span class="keyword">mut</span> <span class="keyword">self</span>,</span><br><span class="line">        model: &amp;<span class="symbol">&#x27;a</span> Model,</span><br><span class="line">        camera: &amp;<span class="symbol">&#x27;a</span> wgpu::BindGroup,</span><br><span class="line">        light: &amp;<span class="symbol">&#x27;a</span> wgpu::BindGroup,</span><br><span class="line">    );</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">draw_light_model_instanced</span></span>(</span><br><span class="line">        &amp;<span class="keyword">mut</span> <span class="keyword">self</span>,</span><br><span class="line">        model: &amp;<span class="symbol">&#x27;a</span> Model,</span><br><span class="line">        instances: Range&lt;<span class="built_in">u32</span>&gt;,</span><br><span class="line">        camera: &amp;<span class="symbol">&#x27;a</span> wgpu::BindGroup,</span><br><span class="line">        light: &amp;<span class="symbol">&#x27;a</span> wgpu::BindGroup,</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;<span class="symbol">&#x27;a</span>, <span class="symbol">&#x27;b</span>&gt; DrawLight&lt;<span class="symbol">&#x27;b</span>&gt; <span class="keyword">for</span> wgpu::RenderPass&lt;<span class="symbol">&#x27;a</span>&gt;</span><br><span class="line"><span class="keyword">where</span></span><br><span class="line">    <span class="symbol">&#x27;b</span>: <span class="symbol">&#x27;a</span>,</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">draw_light_mesh</span></span>(</span><br><span class="line">        &amp;<span class="keyword">mut</span> <span class="keyword">self</span>,</span><br><span class="line">        mesh: &amp;<span class="symbol">&#x27;b</span> Mesh,</span><br><span class="line">        camera: &amp;<span class="symbol">&#x27;b</span> wgpu::BindGroup,</span><br><span class="line">        light: &amp;<span class="symbol">&#x27;b</span> wgpu::BindGroup,</span><br><span class="line">    ) &#123;</span><br><span class="line">        <span class="keyword">self</span>.draw_light_mesh_instanced(mesh, <span class="number">0</span>..<span class="number">1</span>, camera, light);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">draw_light_mesh_instanced</span></span>(</span><br><span class="line">        &amp;<span class="keyword">mut</span> <span class="keyword">self</span>,</span><br><span class="line">        mesh: &amp;<span class="symbol">&#x27;b</span> Mesh,</span><br><span class="line">        instances: Range&lt;<span class="built_in">u32</span>&gt;,</span><br><span class="line">        camera: &amp;<span class="symbol">&#x27;b</span> wgpu::BindGroup,</span><br><span class="line">        light: &amp;<span class="symbol">&#x27;b</span> wgpu::BindGroup,</span><br><span class="line">    ) &#123;</span><br><span class="line">        <span class="keyword">self</span>.set_vertex_buffer(<span class="number">0</span>, mesh.vertex_buffer.slice(..));</span><br><span class="line">        <span class="keyword">self</span>.set_index_buffer(mesh.index_buffer.slice(..), wgpu::IndexFormat::Uint32);</span><br><span class="line">        <span class="keyword">self</span>.set_bind_group(<span class="number">0</span>, camera, &amp;[]);</span><br><span class="line">        <span class="keyword">self</span>.set_bind_group(<span class="number">1</span>, light, &amp;[]);</span><br><span class="line">        <span class="keyword">self</span>.draw_indexed(<span class="number">0</span>..mesh.num_elements, <span class="number">0</span>, instances);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">draw_light_model</span></span>(</span><br><span class="line">        &amp;<span class="keyword">mut</span> <span class="keyword">self</span>,</span><br><span class="line">        model: &amp;<span class="symbol">&#x27;b</span> Model,</span><br><span class="line">        camera: &amp;<span class="symbol">&#x27;b</span> wgpu::BindGroup,</span><br><span class="line">        light: &amp;<span class="symbol">&#x27;b</span> wgpu::BindGroup,</span><br><span class="line">    ) &#123;</span><br><span class="line">        <span class="keyword">self</span>.draw_light_model_instanced(model, <span class="number">0</span>..<span class="number">1</span>, camera, light);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">draw_light_model_instanced</span></span>(</span><br><span class="line">        &amp;<span class="keyword">mut</span> <span class="keyword">self</span>,</span><br><span class="line">        model: &amp;<span class="symbol">&#x27;b</span> Model,</span><br><span class="line">        instances: Range&lt;<span class="built_in">u32</span>&gt;,</span><br><span class="line">        camera: &amp;<span class="symbol">&#x27;b</span> wgpu::BindGroup,</span><br><span class="line">        light: &amp;<span class="symbol">&#x27;b</span> wgpu::BindGroup,</span><br><span class="line">    ) &#123;</span><br><span class="line">        <span class="keyword">for</span> mesh <span class="keyword">in</span> &amp;model.meshes &#123;</span><br><span class="line">            <span class="keyword">self</span>.draw_light_mesh_instanced(mesh, instances.clone(), camera, light);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Finally we want to add Light rendering to our render passes.</p>
<p>最后，我们希望将灯光渲染添加到渲染过程中。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span> State &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">   <span class="function"><span class="keyword">fn</span> <span class="title">render</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) -&gt; <span class="built_in">Result</span>&lt;(), wgpu::SwapChainError&gt; &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        render_pass.set_vertex_buffer(<span class="number">1</span>, <span class="keyword">self</span>.instance_buffer.slice(..));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">use</span> crate::model::DrawLight; <span class="comment">// NEW!</span></span><br><span class="line">        render_pass.set_pipeline(&amp;<span class="keyword">self</span>.light_render_pipeline); <span class="comment">// NEW!</span></span><br><span class="line">        render_pass.draw_light_model(</span><br><span class="line">            &amp;<span class="keyword">self</span>.obj_model,</span><br><span class="line">            &amp;<span class="keyword">self</span>.camera_bind_group,</span><br><span class="line">            &amp;<span class="keyword">self</span>.light_bind_group,</span><br><span class="line">        ); <span class="comment">// NEW!</span></span><br><span class="line"></span><br><span class="line">        render_pass.set_pipeline(&amp;<span class="keyword">self</span>.render_pipeline);</span><br><span class="line">        render_pass.draw_model_instanced(</span><br><span class="line">            &amp;<span class="keyword">self</span>.obj_model,</span><br><span class="line">            <span class="number">0</span>..<span class="keyword">self</span>.instances.len() <span class="keyword">as</span> <span class="built_in">u32</span>,</span><br><span class="line">            &amp;<span class="keyword">self</span>.camera_bind_group,</span><br><span class="line">            &amp;<span class="keyword">self</span>.light_bind_group,</span><br><span class="line">        );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>With all that we’ll end up with something like this.</p>
<p>有了这些，我们最终会得到这样的结果。</p>
<p><img src="https://sotrh.github.io/learn-wgpu/assets/img/light-in-scene.7c329d72.png" alt="light-in-scene"></p>
<h1 id="Ambient-Lighting"><a href="#Ambient-Lighting" class="headerlink" title="Ambient Lighting"></a>Ambient Lighting</h1><p>Light has a tendency to bounce around before entering our eyes. That’s why you can see in areas that are in shadow. Actually modeling this interaction is computationally expensive, so we cheat. We define an ambient lighting value that stands in for the light bouncing of other parts of the scene to light our objects.</p>
<p>光线在进入我们的眼睛之前有一种反弹的趋势。这就是为什么你可以在阴影中看到。实际上，对这种交互进行建模在计算上很昂贵，所以我们作弊。我们定义一个环境光照明值，该值代表场景其他部分的光反弹，以照亮我们的对象。</p>
<p>The ambient part is based on the light color as well as the object color. We’ve already added our light_bind_group, so we just need to use it in our shader. In shader.wgsl, add the following below the texture uniforms.</p>
<p>环境光部分基于灯光颜色和对象颜色。我们已经添加了灯光组，所以我们只需要在着色器中使用它。在shader.wgsl中，在纹理下方添加以下内容。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[[block]]</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Light</span></span> &#123;</span><br><span class="line">    position: vec3&lt;<span class="built_in">f32</span>&gt;;</span><br><span class="line">    color: vec3&lt;<span class="built_in">f32</span>&gt;;</span><br><span class="line">&#125;;</span><br><span class="line">[[group(<span class="number">2</span>), binding(<span class="number">0</span>)]]</span><br><span class="line">var&lt;uniform&gt; light: Light;</span><br></pre></td></tr></table></figure>

<p>Then we need to update our main shader code to calculate and use the ambient color value.</p>
<p>然后我们需要更新我们的主着色器代码来计算和使用环境光颜色值。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[[stage(fragment)]]</span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>(<span class="keyword">in</span>: VertexOutput) -&gt; [[location(<span class="number">0</span>)]] vec4&lt;<span class="built_in">f32</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> object_color: vec4&lt;<span class="built_in">f32</span>&gt; = textureSample(t_diffuse, s_diffuse, <span class="keyword">in</span>.tex_coords);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// We don&#x27;t need (or want) much ambient light, so 0.1 is fine</span></span><br><span class="line">    <span class="keyword">let</span> ambient_strength = <span class="number">0.1</span>;</span><br><span class="line">    <span class="keyword">let</span> ambient_color = light.color * ambient_strength;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> result = ambient_color * object_color.xyz;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> vec4&lt;<span class="built_in">f32</span>&gt;(result, object_color.a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>With that we should get something like the this.</p>
<p>这样我们就可以得到类似这样的东西。</p>
<p><img src="https://sotrh.github.io/learn-wgpu/assets/img/ambient_lighting.8bece8d1.png" alt="ambient_lighting"></p>
<h1 id="Diffuse-Lighting"><a href="#Diffuse-Lighting" class="headerlink" title="Diffuse Lighting"></a>Diffuse Lighting</h1><p>Remember the normal vectors that were included with our model? We’re finally going to use them. Normals represent the direction a surface is facing. By comparing the normal of a fragment with a vector pointing to a light source, we get a value of how light/dark that fragment should be. We compare the vector using the dot product to get the cosine of the angle between them.</p>
<p>还记得我们模型中包含的法向量吗？我们终于要使用它们了。法线表示曲面面对的方向。通过将碎片的法线与指向光源的向量进行比较，我们可以得到该碎片的亮/暗程度。我们使用点积比较矢量，得到它们之间的夹角的余弦。</p>
<p><img src="https://sotrh.github.io/learn-wgpu/assets/img/normal_diagram.dfa577f7.png" alt="normal_diagram"></p>
<p>If the dot product of the normal and light vector is 1.0, that means that the current fragment is directly inline with the light source and will receive the lights full intensity. A value of 0.0 or lower means that the surface is perpendicular or facing away from the light, and therefore will be dark.</p>
<p>如果法线和光向量的点积为1.0，则表示当前片段直接与光源对齐，并将接收全强度的光。值为0.0或更低表示曲面垂直或背向灯光，因此将变暗。</p>
<p>We’re going to need to pull in the normal vector into our shader.wgsl.</p>
<p>我们需要将法线向量拉入shader.wgsl。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">VertexInput</span></span> &#123;</span><br><span class="line">    [[location(<span class="number">0</span>)]] position: vec3&lt;<span class="built_in">f32</span>&gt;;</span><br><span class="line">    [[location(<span class="number">1</span>)]] tex_coords: vec2&lt;<span class="built_in">f32</span>&gt;;</span><br><span class="line">    [[location(<span class="number">2</span>)]] normal: vec3&lt;<span class="built_in">f32</span>&gt;; <span class="comment">// NEW!</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>We’re also going to want to pass that value, as well as the vertex’s position to the fragment shader.</p>
<p>我们还要将该值以及顶点的位置传递给片段着色器。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">VertexOutput</span></span> &#123;</span><br><span class="line">    [[builtin(position)]] clip_position: vec4&lt;<span class="built_in">f32</span>&gt;;</span><br><span class="line">    [[location(<span class="number">0</span>)]] tex_coords: vec2&lt;<span class="built_in">f32</span>&gt;;</span><br><span class="line">    [[location(<span class="number">1</span>)]] world_normal: vec3&lt;<span class="built_in">f32</span>&gt;;</span><br><span class="line">    [[location(<span class="number">2</span>)]] world_position: vec3&lt;<span class="built_in">f32</span>&gt;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>For now let’s just pass the normal directly as is. This is wrong, but we’ll fix it later.</p>
<p>现在让我们直接按原样传递法线。这是错误的，但我们稍后会解决它。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">[[stage(vertex)]]</span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>(</span><br><span class="line">    model: VertexInput,</span><br><span class="line">    instance: InstanceInput,</span><br><span class="line">) -&gt; VertexOutput &#123;</span><br><span class="line">    <span class="keyword">let</span> model_matrix = mat4x4&lt;<span class="built_in">f32</span>&gt;(</span><br><span class="line">        instance.model_matrix_0,</span><br><span class="line">        instance.model_matrix_1,</span><br><span class="line">        instance.model_matrix_2,</span><br><span class="line">        instance.model_matrix_3,</span><br><span class="line">    );</span><br><span class="line">    var out: VertexOutput;</span><br><span class="line">    out.tex_coords = model.tex_coords;</span><br><span class="line">    out.world_normal = model.normal;</span><br><span class="line">    var world_position: vec4&lt;<span class="built_in">f32</span>&gt; = model_matrix * vec4&lt;<span class="built_in">f32</span>&gt;(model.position, <span class="number">1.0</span>);</span><br><span class="line">    out.world_position = world_position.xyz;</span><br><span class="line">    out.clip_position = camera.view_proj * world_position;</span><br><span class="line">    <span class="keyword">return</span> out;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>With that we can do the actual calculation. Below the ambient_color calculation, but above result, add the following.</p>
<p>这样我们就可以进行实际计算了。在ambient_color计算下方，但在结果上方，添加以下内容。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> light_dir = normalize(light.position - <span class="keyword">in</span>.world_position);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> diffuse_strength = max(dot(<span class="keyword">in</span>.world_normal, light_dir), <span class="number">0.0</span>);</span><br><span class="line"><span class="keyword">let</span> diffuse_color = light.color * diffuse_strength;</span><br></pre></td></tr></table></figure>

<p>Now we can include the diffuse_color in the result.</p>
<p>现在我们可以在结果中包含漫反射颜色。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> result = (ambient_color + diffuse_color) * object_color.xyz;</span><br></pre></td></tr></table></figure>

<p>With that we get something like this.</p>
<p>这样我们就得到了这样的东西。</p>
<p><img src="https://sotrh.github.io/learn-wgpu/assets/img/ambient_diffuse_wrong.dab00d9a.png" alt="ambient_diffuse_wrong"></p>
<h1 id="The-normal-matrix"><a href="#The-normal-matrix" class="headerlink" title="The normal matrix"></a>The normal matrix</h1><p>Remember when I said passing the vertex normal directly to the fragment shader was wrong? Let’s explore that by removing all the cubes from the scene except one that will be rotated 180 degrees on the y-axis.</p>
<p>还记得我说过将顶点法线直接传递给片段着色器是错误的吗？让我们通过移除场景中的所有立方体来探索这一点，其中一个立方体将在y轴上旋转180度。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> NUM_INSTANCES_PER_ROW: <span class="built_in">u32</span> = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// In the loop we create the instances in</span></span><br><span class="line"><span class="keyword">let</span> rotation = cgmath::Quaternion::from_axis_angle((<span class="number">0.0</span>, <span class="number">1.0</span>, <span class="number">0.0</span>).into(), cgmath::Deg(<span class="number">180.0</span>));</span><br></pre></td></tr></table></figure>

<p>We’ll also remove the ambient_color from our lighting result.</p>
<p>我们还将从照明结果中删除环境光颜色。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> result = (diffuse_color) * object_color.xyz;</span><br></pre></td></tr></table></figure>

<p>That should give us something that looks like this.</p>
<p>这应该给我们一些如下图所示的东西。</p>
<p><img src="https://sotrh.github.io/learn-wgpu/assets/img/diffuse_wrong.ce856a2c.png" alt="diffuse_wrong"></p>
<p>This is clearly wrong as the light is illuminating the wrong side of the cube. This is because we aren’t rotating our normals with our object, so no matter what direction the object faces, the normals will always face the same way.</p>
<p>这显然是错误的，因为光线照亮了立方体的错误一侧。这是因为我们没有随对象旋转法线，所以无论对象朝向哪个方向，法线都将始终朝向相同的方向。</p>
<p><img src="data:image/png;base64,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AAACBABAgAAACBAAAAECACBAAAAgQAAABAgAgAABABAgAAACBAAAAgQAQIAAAAgQAAABAgAgQAAAIEAAAAQIAIAAAQAQIAAAAgQAAAIEAECAAAAIEAAAAQIAIEAAACBAAAAECACAAAEAECAAABAgAAACBABAgAAACBAAAAECAAABAgAgQAAABAgAgAABABAgAAAQIAAAAgQAQIAAAAgQAAABAgAAAQIAIEAAAAQIAIAAAQAQIAAAECAAAAIEAECAAAAIEAAAAQIAAAECACBAAAAECACAAAEAECAAABAgAAACBABAgAAACBAAAAHCFAAACBAAAAECACBAAAAECAAABAgAgAABABAgAAACBABAgAAAQIAAAAgQAAABAgAgQAAABAgAAAQIAIAAAQAQIAAAAgQAQIAAAECAAAAIEAAAAQIAIEAAAAQIAAAECACAAAEAECAAAAIEAECAAABAgAAACBAAAAECACBAAAAECAAABAgAgAABABAgAAACBAAAAgQAQIAAAAgQAAABAgAgQAAAIEAAAAQIAIAAAQAQIAAAAgQAAAIEAECAAAAIEAAAAQIAIEAAACBAAAAECACAAAEAECAAAAIEAAACBABAgAAACBAAAAECACBAAAAgQAAABAgAgAABABAgAAACBAAAAgQAQIAAAAgQAAABAgAgQAAAIEAAAAQIAIAAAQAQIAAAECAAAAIEAECAAAAIEAAAAQIAAAECACBAAACe8f8Iph1tvtY2iAAAAABJRU5ErkJggg==" alt="image"></p>
<p>We need to use the model matrix to transform the normals to be in the right direction. We only want the rotation data though. A normal represents a direction, and should be a unit vector throughout the calculation. We can get our normals into the right direction using what is called a normal matrix.</p>
<p>我们需要使用模型矩阵将法线变换为正确的方向。我们只需要旋转数据。法线表示方向，在整个计算过程中应为单位向量。我们可以使用所谓的法线矩阵使法线指向正确的方向。</p>
<p>We could compute the normal matrix in the vertex shader, but that would involve inverting the model_matrix, and WGSL doesn’t actually have an inverse function. We would have to code our own. On top of that computing the inverse of a matrix is actually really expensive, especially doing that compututation for every vertex.</p>
<p>我们可以在顶点着色器中计算法线矩阵，但这需要反转模型_矩阵，WGSL实际上没有反函数。我们必须自己编写代码。除此之外，计算矩阵的逆实际上非常昂贵，尤其是对每个顶点进行计算。</p>
<p>Instead we’re going to create add a normal matrix field to InstanceRaw. Instead of inverting the model matrix, we’ll just using the the instances rotation to create a Matrix3.</p>
<p>相反，我们将创建一个法线矩阵字段，并将其添加到InstanceRaw。我们将使用实例旋转来创建Matrix3，而不是反转模型矩阵。</p>
<div class="note">

<p>We using Matrix3 instead of Matrix4 as we only really need the rotation component of the matrix.</p>
<p>我们使用Matrix3代替Matrix4，因为我们只需要矩阵的旋转分量。</p>
</div>

<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[repr(C)]</span></span><br><span class="line"><span class="meta">#[derive(Debug, Copy, Clone, bytemuck::Pod, bytemuck::Zeroable)]</span></span><br><span class="line"><span class="meta">#[allow(dead_code)]</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">InstanceRaw</span></span> &#123;</span><br><span class="line">    model: [[<span class="built_in">f32</span>; <span class="number">4</span>]; <span class="number">4</span>],</span><br><span class="line">    normal: [[<span class="built_in">f32</span>; <span class="number">3</span>]; <span class="number">3</span>],</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> model::Vertex <span class="keyword">for</span> InstanceRaw &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">desc</span></span>&lt;<span class="symbol">&#x27;a</span>&gt;() -&gt; wgpu::VertexBufferLayout&lt;<span class="symbol">&#x27;a</span>&gt; &#123;</span><br><span class="line">        <span class="keyword">use</span> std::mem;</span><br><span class="line">        wgpu::VertexBufferLayout &#123;</span><br><span class="line">            array_stride: mem::size_of::&lt;InstanceRaw&gt;() <span class="keyword">as</span> wgpu::BufferAddress,</span><br><span class="line">            <span class="comment">// We need to switch from using a step mode of Vertex to Instance</span></span><br><span class="line">            <span class="comment">// This means that our shaders will only change to use the next</span></span><br><span class="line">            <span class="comment">// instance when the shader starts processing a new instance</span></span><br><span class="line">            step_mode: wgpu::VertexStepMode::Instance,</span><br><span class="line">            attributes: &amp;[</span><br><span class="line">                wgpu::VertexAttribute &#123;</span><br><span class="line">                    offset: <span class="number">0</span>,</span><br><span class="line">                    <span class="comment">// While our vertex shader only uses locations 0, and 1 now, in later tutorials we&#x27;ll</span></span><br><span class="line">                    <span class="comment">// be using 2, 3, and 4, for Vertex. We&#x27;ll start at slot 5 not conflict with them later</span></span><br><span class="line">                    shader_location: <span class="number">5</span>,</span><br><span class="line">                    format: wgpu::VertexFormat::Float32x4,</span><br><span class="line">                &#125;,</span><br><span class="line">                <span class="comment">// A mat4 takes up 4 vertex slots as it is technically 4 vec4s. We need to define a slot</span></span><br><span class="line">                <span class="comment">// for each vec4. We don&#x27;t have to do this in code though.</span></span><br><span class="line">                wgpu::VertexAttribute &#123;</span><br><span class="line">                    offset: mem::size_of::&lt;[<span class="built_in">f32</span>; <span class="number">4</span>]&gt;() <span class="keyword">as</span> wgpu::BufferAddress,</span><br><span class="line">                    shader_location: <span class="number">6</span>,</span><br><span class="line">                    format: wgpu::VertexFormat::Float32x4,</span><br><span class="line">                &#125;,</span><br><span class="line">                wgpu::VertexAttribute &#123;</span><br><span class="line">                    offset: mem::size_of::&lt;[<span class="built_in">f32</span>; <span class="number">8</span>]&gt;() <span class="keyword">as</span> wgpu::BufferAddress,</span><br><span class="line">                    shader_location: <span class="number">7</span>,</span><br><span class="line">                    format: wgpu::VertexFormat::Float32x4,</span><br><span class="line">                &#125;,</span><br><span class="line">                wgpu::VertexAttribute &#123;</span><br><span class="line">                    offset: mem::size_of::&lt;[<span class="built_in">f32</span>; <span class="number">12</span>]&gt;() <span class="keyword">as</span> wgpu::BufferAddress,</span><br><span class="line">                    shader_location: <span class="number">8</span>,</span><br><span class="line">                    format: wgpu::VertexFormat::Float32x4,</span><br><span class="line">                &#125;,</span><br><span class="line">                <span class="comment">// NEW!</span></span><br><span class="line">                wgpu::VertexAttribute &#123;</span><br><span class="line">                    offset: mem::size_of::&lt;[<span class="built_in">f32</span>; <span class="number">16</span>]&gt;() <span class="keyword">as</span> wgpu::BufferAddress,</span><br><span class="line">                    shader_location: <span class="number">9</span>,</span><br><span class="line">                    format: wgpu::VertexFormat::Float32x3,</span><br><span class="line">                &#125;,</span><br><span class="line">                wgpu::VertexAttribute &#123;</span><br><span class="line">                    offset: mem::size_of::&lt;[<span class="built_in">f32</span>; <span class="number">19</span>]&gt;() <span class="keyword">as</span> wgpu::BufferAddress,</span><br><span class="line">                    shader_location: <span class="number">10</span>,</span><br><span class="line">                    format: wgpu::VertexFormat::Float32x3,</span><br><span class="line">                &#125;,</span><br><span class="line">                wgpu::VertexAttribute &#123;</span><br><span class="line">                    offset: mem::size_of::&lt;[<span class="built_in">f32</span>; <span class="number">22</span>]&gt;() <span class="keyword">as</span> wgpu::BufferAddress,</span><br><span class="line">                    shader_location: <span class="number">11</span>,</span><br><span class="line">                    format: wgpu::VertexFormat::Float32x3,</span><br><span class="line">                &#125;,</span><br><span class="line">            ],</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>We need to modify Instance to create the normal matrix.</p>
<p>我们需要修改实例来创建法线矩阵。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Instance</span></span> &#123;</span><br><span class="line">    position: cgmath::Vector3&lt;<span class="built_in">f32</span>&gt;,</span><br><span class="line">    rotation: cgmath::Quaternion&lt;<span class="built_in">f32</span>&gt;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> Instance &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">to_raw</span></span>(&amp;<span class="keyword">self</span>) -&gt; InstanceRaw &#123;</span><br><span class="line">        <span class="keyword">let</span> model =</span><br><span class="line">            cgmath::Matrix4::from_translation(<span class="keyword">self</span>.position) * cgmath::Matrix4::from(<span class="keyword">self</span>.rotation);</span><br><span class="line">        InstanceRaw &#123;</span><br><span class="line">            model: model.into(),</span><br><span class="line">            <span class="comment">// NEW!</span></span><br><span class="line">            normal: cgmath::Matrix3::from(<span class="keyword">self</span>.rotation).into(),</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Now we need to reconstruct the normal matrix in the vertex shader.</p>
<p>现在我们需要在顶点着色器中重建法线矩阵。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">InstanceInput</span></span> &#123;</span><br><span class="line">    [[location(<span class="number">5</span>)]] model_matrix_0: vec4&lt;<span class="built_in">f32</span>&gt;;</span><br><span class="line">    [[location(<span class="number">6</span>)]] model_matrix_1: vec4&lt;<span class="built_in">f32</span>&gt;;</span><br><span class="line">    [[location(<span class="number">7</span>)]] model_matrix_2: vec4&lt;<span class="built_in">f32</span>&gt;;</span><br><span class="line">    [[location(<span class="number">8</span>)]] model_matrix_3: vec4&lt;<span class="built_in">f32</span>&gt;;</span><br><span class="line">    <span class="comment">// NEW!</span></span><br><span class="line">    [[location(<span class="number">9</span>)]] normal_matrix_0: vec3&lt;<span class="built_in">f32</span>&gt;;</span><br><span class="line">    [[location(<span class="number">10</span>)]] normal_matrix_1: vec3&lt;<span class="built_in">f32</span>&gt;;</span><br><span class="line">    [[location(<span class="number">11</span>)]] normal_matrix_2: vec3&lt;<span class="built_in">f32</span>&gt;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">VertexOutput</span></span> &#123;</span><br><span class="line">    [[builtin(position)]] clip_position: vec4&lt;<span class="built_in">f32</span>&gt;;</span><br><span class="line">    [[location(<span class="number">0</span>)]] tex_coords: vec2&lt;<span class="built_in">f32</span>&gt;;</span><br><span class="line">    [[location(<span class="number">1</span>)]] world_normal: vec3&lt;<span class="built_in">f32</span>&gt;;</span><br><span class="line">    [[location(<span class="number">2</span>)]] world_position: vec3&lt;<span class="built_in">f32</span>&gt;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">[[stage(vertex)]]</span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>(</span><br><span class="line">    model: VertexInput,</span><br><span class="line">    instance: InstanceInput,</span><br><span class="line">) -&gt; VertexOutput &#123;</span><br><span class="line">    <span class="keyword">let</span> model_matrix = mat4x4&lt;<span class="built_in">f32</span>&gt;(</span><br><span class="line">        instance.model_matrix_0,</span><br><span class="line">        instance.model_matrix_1,</span><br><span class="line">        instance.model_matrix_2,</span><br><span class="line">        instance.model_matrix_3,</span><br><span class="line">    );</span><br><span class="line">    <span class="comment">// NEW!</span></span><br><span class="line">    <span class="keyword">let</span> normal_matrix = mat3x3&lt;<span class="built_in">f32</span>&gt;(</span><br><span class="line">        instance.normal_matrix_0,</span><br><span class="line">        instance.normal_matrix_1,</span><br><span class="line">        instance.normal_matrix_2,</span><br><span class="line">    );</span><br><span class="line">    var out: VertexOutput;</span><br><span class="line">    out.tex_coords = model.tex_coords;</span><br><span class="line">    out.world_normal = normal_matrix * model.normal;</span><br><span class="line">    var world_position: vec4&lt;<span class="built_in">f32</span>&gt; = model_matrix * vec4&lt;<span class="built_in">f32</span>&gt;(model.position, <span class="number">1.0</span>);</span><br><span class="line">    out.world_position = world_position.xyz;</span><br><span class="line">    out.clip_position = camera.view_proj * world_position;</span><br><span class="line">    <span class="keyword">return</span> out;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<div class="note">

<p>I’m currently doing things in world space. Doing things in view-space also known as eye-space, is more standard as objects can have lighting issues when they are further away from the origin. If we wanted to use view-space, we would have include the rotation due to the view matrix as well. We’d also have to transform our light’s position using something like view_matrix * model_matrix * light_position to keep the calculation from getting messed up when the camera moves.</p>
<p>我现在在世界空间里做事。在视图空间(也称为eye-space)中进行操作更为标准，因为当对象离原点较远时，可能会出现照明问题。如果我们想使用视图空间，我们还应该包括由于视图矩阵而产生的旋转。我们还必须使用视图矩阵<em>模型矩阵</em>灯光位置之类的东西来变换灯光的位置，以防止相机移动时计算出错。</p>
<p>There are advantages to using view space. The main one is when you have massive worlds doing lighting and other calculations in model spacing can cause issues as floating point precision degrades when numbers get really large. View space keeps the camera at the origin meaning all calculations will be using smaller numbers. The actual lighting math ends up the same, but it does require a bit more setup.</p>
<p>使用视图空间有很多优点。最主要的一个问题是，当有大量的世界在进行照明和其他模型间距计算时，可能会导致问题，因为当数字变得非常大时，浮点精度会下降。视图空间将相机保持在原点，这意味着所有计算都将使用较小的数字。实际的照明数学结果是一样的，但它确实需要更多的设置。</p>
</div>

<p>With that change our lighting now looks correct.</p>
<p>通过这一更改，我们的照明现在看起来是正确的。</p>
<p><img src="https://sotrh.github.io/learn-wgpu/assets/img/diffuse_right.e3a6b793.png" alt="diffuse_right"></p>
<p>Bringing back our other objects, and adding the ambient lighting gives us this.</p>
<p>带回其他对象，并添加环境照明，我们就可以做到这一点。</p>
<p><img src="https://sotrh.github.io/learn-wgpu/assets/img/ambient_diffuse_lighting.98735034.png" alt="ambient_diffuse_lighting"></p>
<h1 id="Specular-Lighting"><a href="#Specular-Lighting" class="headerlink" title="Specular Lighting"></a>Specular Lighting</h1><p>Specular lighting describes the highlights that appear on objects when viewed from certain angles. If you’ve ever looked at a car, it’s the super bright parts. Basically, some of the light can reflect of the surface like a mirror. The location of the hightlight shifts depending on what angle you view it at.</p>
<p>镜面反射照明描述从特定角度查看时在对象上显示的高光。如果你看过一辆车，那就是超亮的部分。基本上，一些光可以像镜子一样反射表面。强光的位置会根据您的观察角度发生变化。</p>
<p><img src="data:image/png;base64,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" alt="image"></p>
<p>Because this is relative to the view angle, we are going to need to pass in the camera’s position both into the fragment shader and into the vertex shader.</p>
<p>因为这是相对于视图角度的，所以我们需要将摄影机的位置传递到片段着色器和顶点着色器中。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[[block]]</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Camera</span></span> &#123;</span><br><span class="line">    view_pos: vec4&lt;<span class="built_in">f32</span>&gt;;</span><br><span class="line">    view_proj: mat4x4&lt;<span class="built_in">f32</span>&gt;;</span><br><span class="line">&#125;;</span><br><span class="line">[[group(<span class="number">1</span>), binding(<span class="number">0</span>)]]</span><br><span class="line">var&lt;uniform&gt; camera: Camera;</span><br></pre></td></tr></table></figure>

<div class="note">

<p>Don’t forget to update the Camera struct in light.wgsl as well, as if it doesn’t match the CameraUniform struct in rust, the light will render wrong.</p>
<p>不要忘记更新light.wgsl中的Camera结构，因为如果它与rust中的CameraUniform结构不匹配，灯光将渲染错误。</p>
</div>

<p>We’re going to need to update the CameraUniform struct as well.</p>
<p>们还需要更新CameraUniform结构。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main.rs</span></span><br><span class="line"><span class="meta">#[repr(C)]</span></span><br><span class="line"><span class="meta">#[derive(Copy, Clone, bytemuck::Pod, bytemuck::Zeroable)]</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">CameraUniform</span></span> &#123;</span><br><span class="line">    view_position: [<span class="built_in">f32</span>; <span class="number">4</span>],</span><br><span class="line">    view_proj: [[<span class="built_in">f32</span>; <span class="number">4</span>]; <span class="number">4</span>],</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> CameraUniform &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">new</span></span>() -&gt; <span class="keyword">Self</span> &#123;</span><br><span class="line">        <span class="keyword">Self</span> &#123;</span><br><span class="line">            view_position: [<span class="number">0.0</span>; <span class="number">4</span>],</span><br><span class="line">            view_proj: cgmath::Matrix4::identity().into(),</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">update_view_proj</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, camera: &amp;Camera) &#123;</span><br><span class="line">        <span class="comment">// We&#x27;re using Vector4 because of the uniforms 16 byte spacing requirement</span></span><br><span class="line">        <span class="keyword">self</span>.view_position = camera.eye.to_homogeneous();</span><br><span class="line">        <span class="keyword">self</span>.view_proj = OPENGL_TO_WGPU_MATRIX * camera.build_view_projection_matrix();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Since we want to use our uniforms in the fragment shader now, we need to change it’s visibility.</p>
<p>因为我们现在想在片段着色器中使用制服，所以需要更改其可见性。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main.rs</span></span><br><span class="line"><span class="keyword">let</span> camera_bind_group_layout = device.create_bind_group_layout(&amp;wgpu::BindGroupLayoutDescriptor &#123;</span><br><span class="line">    entries: &amp;[</span><br><span class="line">        wgpu::BindGroupLayoutBinding &#123;</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">            visibility: wgpu::ShaderStages::VERTEX | wgpu::ShaderStages::FRAGMENT, <span class="comment">// Updated!</span></span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    ],</span><br><span class="line">    label: <span class="literal">None</span>,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>We’re going to get the direction from the fragment’s position to the camera, and use that with the normal to calculate the reflect_dir.</p>
<p>我们将得到从碎片的位置到摄像机的方向，并将其与法线一起计算反射方向。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// In the fragment shader...</span></span><br><span class="line"><span class="keyword">let</span> view_dir = normalize(camera.view_pos.xyz - <span class="keyword">in</span>.world_position);</span><br><span class="line"><span class="keyword">let</span> reflect_dir = reflect(-light_dir, <span class="keyword">in</span>.world_normal);</span><br></pre></td></tr></table></figure>

<p>Then we use the dot product to calculate the specular_strength and use that to compute the specular_color.</p>
<p>然后我们使用点积来计算镜面反射强度，并使用它来计算镜面反射颜色。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> specular_strength = pow(max(dot(view_dir, reflect_dir), <span class="number">0.0</span>), <span class="number">32.0</span>);</span><br><span class="line"><span class="keyword">let</span> specular_color = specular_strength * light.color;</span><br></pre></td></tr></table></figure>

<p>Finally we add that to the result.</p>
<p>最后，我们将其添加到结果中。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> result = (ambient_color + diffuse_color + specular_color) * object_color.xyz;</span><br></pre></td></tr></table></figure>

<p>With that you should have something like this.</p>
<p>这样你就应该有这样的东西。</p>
<p><img src="https://sotrh.github.io/learn-wgpu/assets/img/ambient_diffuse_specular_lighting.76386148.png" alt="ambient_diffuse_specular_lighting"></p>
<p>如果我们只看镜面反射的颜色会如下所示。</p>
<p><img src="https://sotrh.github.io/learn-wgpu/assets/img/specular_lighting.b3869eb1.png" alt="specular_lighting"></p>
<h1 id="The-half-direction"><a href="#The-half-direction" class="headerlink" title="The half direction"></a>The half direction</h1><p>Up to this point we’ve actually only implemented the Phong part of Blinn-Phong. The Phong reflection model works well, but it can break down under <a target="_blank" rel="noopener" href="https://learnopengl.com/Advanced-Lighting/Advanced-Lighting">certain circumstances</a>. The Blinn part of Blinn-Phong comes from the realization that if you add the view_dir, and light_dir together, normalize the result and use the dot product of that and the normal, you get roughly the same results without the issues that using reflect_dir had.</p>
<p>到目前为止，我们实际上只实现了Blinn Phong的Phong部分。Phong反射模型运行良好，但在<a target="_blank" rel="noopener" href="https://learnopengl.com/Advanced-Lighting/Advanced-Lighting">某些情况</a>下可能会崩溃。Blinn Phong的Blinn部分源于这样一种认识，即如果将view_dir和light_dir添加在一起，对结果进行规格化，并使用其与法线的点积，则得到的结果与使用reflect_dir得到的结果大致相同，而不存在使用reflect_dir的问题。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> view_dir = normalize(camera.view_pos.xyz - <span class="keyword">in</span>.world_position);</span><br><span class="line"><span class="keyword">let</span> half_dir = normalize(view_dir + light_dir);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> specular_strength = pow(max(dot(<span class="keyword">in</span>.world_normal, half_dir), <span class="number">0.0</span>), <span class="number">32.0</span>);</span><br></pre></td></tr></table></figure>

<p>It’s hard to tell the difference, but here’s the results.</p>
<p>很难区分两者之间的区别，但结果如下。</p>
<p><img src="https://sotrh.github.io/learn-wgpu/assets/img/half_dir.bbcc23b8.png" alt="half_dir"></p>
<p><a target="_blank" rel="noopener" href="https://github.com/sotrh/learn-wgpu/tree/master/code/intermediate/tutorial10-lighting/">Check out the code!</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://qianqians.github.io/2021/09/03/Wgpu%20The%20Depth%20Buffer/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="qianqians">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="qianqians'blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/09/03/Wgpu%20The%20Depth%20Buffer/" class="post-title-link" itemprop="url">Wgpu The Depth Buffer</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2021-09-03 14:42:13 / 修改时间：15:49:03" itemprop="dateCreated datePublished" datetime="2021-09-03T14:42:13+08:00">2021-09-03</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Wgpu/" itemprop="url" rel="index"><span itemprop="name">Wgpu</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>Let’s take a closer look at the last example.</p>
<p>让我们仔细看看最后一个例子。</p>
<p><img src="https://sotrh.github.io/learn-wgpu/assets/img/forest_with_zoom.a43286ea.png" alt="forest_with_zoom"></p>
<p>Models that should be in the back are getting rendered ahead of ones that should be in the front. This is caused by the draw order. By default, pixel data from a new object will replace old pixel data.</p>
<p>应该在后面的模型将在应该在前面的模型之前进行渲染。这是由提取顺序引起的。默认情况下，来自新对象的像素数据将替换旧像素数据。</p>
<p>There are two ways to solve this: sort the data from back to front, use what’s known as a depth buffer.</p>
<p>有两种方法可以解决这个问题：从后到前对数据进行排序，使用深度缓冲区。</p>
<h1 id="Sorting-from-back-to-front"><a href="#Sorting-from-back-to-front" class="headerlink" title="Sorting from back to front"></a>Sorting from back to front</h1><p>This is the go to method for 2d rendering as it’s pretty easier to know what’s supposed to go in front of what. You can just use the z order. In 3d rendering it gets a little more tricky because the order of the objects changes based on the camera angle.</p>
<p>这是2d渲染的方法，因为它很容易知道在什么之前应该做什么。你可以使用z顺序。在3d渲染中，由于对象的顺序会根据摄影机角度发生变化，因此会变得有点棘手。</p>
<p>A simple way of doing this is to sort all the objects by their distance to the cameras position. There are flaws with this method though as when a large object is behind a small object, parts of the large object that should be in front of the small object will be rendered behind. We’ll also run into issues with objects that overlap themselves.</p>
<p>执行此操作的一种简单方法是根据对象到摄影机位置的距离对所有对象进行排序。这种方法存在缺陷，尽管当一个大对象在一个小对象后面时，应该在小对象前面的大对象部分将在后面渲染。我们还将遇到对象重叠的问题。</p>
<p>If want to do this properly we need to have pixel level precision. That’s where a depth buffer comes in.</p>
<p>如果要正确地做到这一点，我们需要有像素级的精度。这就是深度缓冲区的作用。</p>
<h1 id="A-pixels-depth"><a href="#A-pixels-depth" class="headerlink" title="A pixels depth"></a>A pixels depth</h1><p>A depth buffer is a black and white texture that stores the z-coordinate of rendered pixels. Wgpu can use this when drawing new pixels to determine whether to replace the data or keep it. This technique is called depth testing. This will fix our draw order problem without needing us to sort our objects!</p>
<p>深度缓冲区是存储渲染像素z坐标的黑白纹理。Wgpu可以在绘制新像素时使用此选项来确定是替换数据还是保留数据。这种技术称为深度测试。这将解决我们的绘图顺序问题，而不需要我们对对象进行排序！</p>
<p>Let’s make a function to create the depth texture in texture.rs.</p>
<p>让我们制作一个函数，在texture.rs中创建深度纹理。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span> Texture &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">const</span> DEPTH_FORMAT: wgpu::TextureFormat = wgpu::TextureFormat::Depth32Float; <span class="comment">// 1.</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">create_depth_texture</span></span>(device: &amp;wgpu::Device, sc_desc: &amp;wgpu::SwapChainDescriptor, label: &amp;<span class="built_in">str</span>) -&gt; <span class="keyword">Self</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> size = wgpu::Extent3d &#123; <span class="comment">// 2.</span></span><br><span class="line">            width: sc_desc.width,</span><br><span class="line">            height: sc_desc.height,</span><br><span class="line">            depth_or_array_layers: <span class="number">1</span>,</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">let</span> desc = wgpu::TextureDescriptor &#123;</span><br><span class="line">            label: <span class="literal">Some</span>(label),</span><br><span class="line">            size,</span><br><span class="line">            mip_level_count: <span class="number">1</span>,</span><br><span class="line">            sample_count: <span class="number">1</span>,</span><br><span class="line">            dimension: wgpu::TextureDimension::D2,</span><br><span class="line">            format: Self::DEPTH_FORMAT,</span><br><span class="line">            usage: wgpu::TextureUsage::RENDER_ATTACHMENT <span class="comment">// 3.</span></span><br><span class="line">                | wgpu::TextureUsage::SAMPLED,</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">let</span> texture = device.create_texture(&amp;desc);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> view = texture.create_view(&amp;wgpu::TextureViewDescriptor::default());</span><br><span class="line">        <span class="keyword">let</span> sampler = device.create_sampler(</span><br><span class="line">            &amp;wgpu::SamplerDescriptor &#123; <span class="comment">// 4.</span></span><br><span class="line">                address_mode_u: wgpu::AddressMode::ClampToEdge,</span><br><span class="line">                address_mode_v: wgpu::AddressMode::ClampToEdge,</span><br><span class="line">                address_mode_w: wgpu::AddressMode::ClampToEdge,</span><br><span class="line">                mag_filter: wgpu::FilterMode::Linear,</span><br><span class="line">                min_filter: wgpu::FilterMode::Linear,</span><br><span class="line">                mipmap_filter: wgpu::FilterMode::Nearest,</span><br><span class="line">                compare: <span class="literal">Some</span>(wgpu::CompareFunction::LessEqual), <span class="comment">// 5.</span></span><br><span class="line">                lod_min_clamp: -<span class="number">100.0</span>,</span><br><span class="line">                lod_max_clamp: <span class="number">100.0</span>,</span><br><span class="line">                ..<span class="built_in">Default</span>::default()</span><br><span class="line">            &#125;</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        <span class="keyword">Self</span> &#123; texture, view, sampler &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>We need the DEPTH_FORMAT for when we create the depth stage of the render_pipeline and creating the depth texture itself.</li>
<li>Our depth texture needs to be the same size as our screen if we want things to render correctly. We can use our sc_desc to make sure that our depth texture is the same size as our swap chain images.</li>
<li>Since we are rendering to this texture, we need to add the RENDER_ATTACHMENT flag to it.</li>
<li>We technically don’t need a sampler for a depth texture, but our Texture struct requires it, and we need one if we ever want to sample it.</li>
<li>If we do decide to render our depth texture, we need to use CompareFunction::LessEqual. This is due to how the samplerShadow and sampler2DShadow() interacts with the texture() function in GLSL.</li>
</ol>
<div></div>

<ol>
<li>当我们创建render_pipeline的depth stage和创建depth texture本身时，我们需要DEPTH_FORMAT。</li>
<li>如果我们想正确渲染，我们的深度纹理需要与屏幕大小相同。我们可以使用sc_desc确保深度纹理与swap chain图像的大小相同。</li>
<li>由于我们正在渲染此纹理，因此需要向其添加RENDER_ATTACHMENT标志。</li>
<li>从技术上讲，我们不需要深度纹理的采样器，但我们的纹理结构需要它，如果我们想对它进行采样，我们需要一个采样器。</li>
<li>如果我们决定渲染深度纹理，我们需要使用CompareFunction::LessEqual。这将决定samplerShadow和sampler2DShadow()如何与GLSL中的texture()函数交互。</li>
</ol>
<p>We create our depth_texture in State::new().</p>
<p>我们在State::new()中创建深度纹理。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> depth_texture = texture::Texture::create_depth_texture(&amp;device, &amp;sc_desc, <span class="string">&quot;depth_texture&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>We need to modify our render_pipeline to allow depth testing.</p>
<p>我们需要修改渲染管线以允许深度测试。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> render_pipeline = device.create_render_pipeline(&amp;wgpu::RenderPipelineDescriptor &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    depth_stencil: <span class="literal">Some</span>(wgpu::DepthStencilState &#123;</span><br><span class="line">        format: texture::Texture::DEPTH_FORMAT,</span><br><span class="line">        depth_write_enabled: <span class="literal">true</span>,</span><br><span class="line">        depth_compare: wgpu::CompareFunction::Less, <span class="comment">// 1.</span></span><br><span class="line">        stencil: wgpu::StencilState::default(), <span class="comment">// 2.</span></span><br><span class="line">        bias: wgpu::DepthBiasState::default(),</span><br><span class="line">    &#125;),</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<ol>
<li><p>The depth_compare function tells us when to discard a new pixel. Using LESS means pixels will be drawn front to back. Here are all the values you can use.</p>
<p>深度比较功能告诉我们何时丢弃新像素。使用LESS的方法将前后绘制像素。以下是您可以使用的所有值。</p>
</li>
</ol>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[repr(C)]</span></span><br><span class="line"><span class="meta">#[derive(Copy, Clone, Debug, Hash, Eq, PartialEq)]</span></span><br><span class="line"><span class="meta">#[cfg_attr(feature = <span class="meta-string">&quot;serde&quot;</span>, derive(Serialize, Deserialize))]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">enum</span> <span class="title">CompareFunction</span></span> &#123;</span><br><span class="line">    Undefined = <span class="number">0</span>,</span><br><span class="line">    Never = <span class="number">1</span>,</span><br><span class="line">    Less = <span class="number">2</span>,</span><br><span class="line">    Equal = <span class="number">3</span>,</span><br><span class="line">    LessEqual = <span class="number">4</span>,</span><br><span class="line">    Greater = <span class="number">5</span>,</span><br><span class="line">    NotEqual = <span class="number">6</span>,</span><br><span class="line">    GreaterEqual = <span class="number">7</span>,</span><br><span class="line">    Always = <span class="number">8</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><p>There’s another type of buffer called a stencil buffer. It’s common practice to store the stencil buffer and depth buffer in the same texture. This fields control values for stencil testing. Since we aren’t using a stencil buffer, we’ll use default values. We’ll cover stencil buffers later.</p>
<p>还有另一种类型的缓冲区称为stencil缓冲区。通常的做法是将stencil缓冲区和深度缓冲区存储在同一纹理中。此字段控制stencil测试的值。因为我们不使用stencil缓冲区，所以我们将使用默认值。稍后我们将讨论stencil缓冲区。</p>
</li>
</ol>
<p>Don’t forget to store the depth_texture in State.</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Self</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    depth_texture,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>We need to remember to change the resize() method to create a new depth_texture and depth_texture_view.</p>
<p>我们需要记住更改resize()方法以创建新的depth_texture和depth_texture_view。</p>
<p>Make sure you update the depth_texture after you update sc_desc. If you don’t, your program will crash as the depth_texture will be a different size than the swap_chain texture.</p>
<p>请确保在更新sc_desc后更新depth_texture。如果不更新，程序将崩溃，因为depth_texture的大小将不同于swap_chain texture。</p>
<p>The last change we need to make is in the render() function. We’ve created the depth_texture, but we’re not currently using it. We use it by attaching it to the depth_stencil_attachment of a render pass.</p>
<p>我们需要做的最后一个更改是在render()函数中。我们已经创建了depth_texture，但目前没有使用它。我们通过将其附加到渲染过程的depth_stencil_attachment来使用它。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut</span> render_pass = encoder.begin_render_pass(&amp;wgpu::RenderPassDescriptor &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    depth_stencil_attachment: <span class="literal">Some</span>(wgpu::RenderPassDepthStencilAttachment &#123;</span><br><span class="line">        view: &amp;<span class="keyword">self</span>.depth_texture.view,</span><br><span class="line">        depth_ops: <span class="literal">Some</span>(wgpu::Operations &#123;</span><br><span class="line">            load: wgpu::LoadOp::Clear(<span class="number">1.0</span>),</span><br><span class="line">            store: <span class="literal">true</span>,</span><br><span class="line">        &#125;),</span><br><span class="line">        stencil_ops: <span class="literal">None</span>,</span><br><span class="line">    &#125;),</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>And that’s all we have to do! No shader code needed! If you run the application, the depth issues will be fixed.</p>
<p>这就是我们要做的！不需要着色器代码！如果运行应用程序，深度问题将得到修复。</p>
<p><img src="https://sotrh.github.io/learn-wgpu/assets/img/forest_fixed.a77f70f6.png" alt="forest_fixed"></p>
<h1 id="Challenge"><a href="#Challenge" class="headerlink" title="Challenge"></a>Challenge</h1><p>Since the depth buffer is a texture, we can sample it in the shader. Because it’s a depth texture, we’ll have to use the samplerShadow uniform type and the sampler2DShadow function instead of sampler, and sampler2D respectively. Create a bind group for the depth texture (or reuse an existing one), and render it to the screen.</p>
<p>由于深度缓冲区是一个纹理，我们可以在着色器中对其进行采样。因为它是一个深度纹理，所以我们必须分别使用samplerShadow uniform类型和sampler2DShadow函数，而不是sampler和sampler2D。为深度纹理创建bind group(或重用现有组)，并将其渲染到屏幕上。</p>
<p><a target="_blank" rel="noopener" href="https://github.com/sotrh/learn-wgpu/tree/master/code/beginner/tutorial8-depth/">Check out the code!</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://qianqians.github.io/2021/09/02/Wgpu%20Instancing/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="qianqians">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="qianqians'blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/09/02/Wgpu%20Instancing/" class="post-title-link" itemprop="url">Wgpu Instancing</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2021-09-02 14:49:22 / 修改时间：15:33:51" itemprop="dateCreated datePublished" datetime="2021-09-02T14:49:22+08:00">2021-09-02</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Wgpu/" itemprop="url" rel="index"><span itemprop="name">Wgpu</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>Our scene right now is very simple: we have one object centered at (0,0,0). What if we wanted more objects? This is were instancing comes in.</p>
<p>我们现在的场景非常简单：我们有一个以（0,0,0）为中心的对象。如果我们想要更多的东西呢？这是实例的目标。</p>
<p>Instancing allows us to draw the same object multiple times with different properties (position, orientation, size, color, etc.). There are multiple ways of doing instancing. One way would be to modify the uniform buffer to include these properties and then update it before we draw each instance of our object.</p>
<p>实例化允许我们使用不同的属性（位置、方向、大小、颜色等）多次绘制同一对象。有多种方法可以进行实例化。一种方法是修改uniform缓冲区以包含这些属性，然后在绘制对象的每个实例之前更新它。</p>
<p>We don’t want to use this method for performance reasons. Updating the uniform buffer for each instance would require multiple buffer copies each frame. On top of that, our method to update the uniform buffer currently requires use to create a new buffer to store the updated data. That’s a lot of time wasted between draw calls.</p>
<p>出于性能原因，我们不希望使用此方法。更新每个实例的uniform缓冲区将需要每个帧有多个缓冲区副本。除此之外，我们更新uniform缓冲区的方法目前需要创建一个新的缓冲区来存储更新后的数据。在两次draw calls之间浪费了很多时间。</p>
<p>If we look at the parameters for the draw_indexed function in the wgpu docs, we can see a solution to our problem.</p>
<p>如果我们查看wgpu文档中draw_indexed函数的参数，我们可以看到问题的解决方案。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">draw_indexed</span></span>(</span><br><span class="line">    &amp;<span class="keyword">mut</span> <span class="keyword">self</span>,</span><br><span class="line">    indices: Range&lt;<span class="built_in">u32</span>&gt;,</span><br><span class="line">    base_vertex: <span class="built_in">i32</span>,</span><br><span class="line">    instances: Range&lt;<span class="built_in">u32</span>&gt; <span class="comment">// &lt;-- This right here</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>The instances parameter takes a Range<u32>. This parameter tells the GPU how many copies, or instances, of our model we want to draw. Currently we are specifying 0..1, which instructs the GPU to draw our model once, and then stop. If we used 0..5, our code would draw 5 instances.</p>
<p>instances的参数为Range<u32>。此参数告诉GPU我们要绘制模型的多少副本或实例。目前我们正在指定0..1，它指示GPU绘制一次我们的模型，然后停止。如果我们使用0..5，我们的代码将绘制5个实例。</p>
<p>The fact that instances is a Range<u32> may seem weird as using 1..2 for instances would still draw 1 instance of our object. Seems like it would be simpler to just use a u32 right? The reason it’s a range is because sometimes we don’t want to draw all of our objects. Sometimes we want to draw a selection of them, because others are not in frame, or we are debugging and want to look at a particular set of instances.</p>
<p>instances是一个Range<u32>的事实可能看起来很奇怪，因为使用1..2 for instances仍然会绘制对象的一个实例。看起来使用u32会更简单，对吗？它是一个Range的原因是因为有时我们不想绘制所有的对象。有时，我们希望选择它们，因为其他的不在视野中，或者我们正在调试并希望查看一组特定的实例。</p>
<p>Ok, now we know how to draw multiple instances of an object, how do we tell wgpu what particular instance to draw? We are going to use something known as an instance buffer.</p>
<p>好的，现在我们知道了如何绘制一个对象的多个实例，我们如何告诉wgpu要绘制的特定实例？我们将使用实例缓冲区。</p>
<h1 id="The-Instance-Buffer"><a href="#The-Instance-Buffer" class="headerlink" title="The Instance Buffer"></a>The Instance Buffer</h1><p>We’ll create an instance buffer in a similar way to how we create a uniform buffer. First we’ll create a struct called Instance.</p>
<p>我们将以类似于创建uniform缓冲区的方式创建instance缓冲区。首先，我们将创建一个名为Instance的结构。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main.rs</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// NEW!</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Instance</span></span> &#123;</span><br><span class="line">    position: cgmath::Vector3&lt;<span class="built_in">f32</span>&gt;,</span><br><span class="line">    rotation: cgmath::Quaternion&lt;<span class="built_in">f32</span>&gt;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<div class="note">

<p>A Quaternion is a mathematical structure often used to represent rotation. The math behind them is beyond me (it involves imaginary numbers and 4D space) so I won’t be covering them here. If you really want to dive into them <a target="_blank" rel="noopener" href="https://mathworld.wolfram.com/Quaternion.html">here’s a Wolfram Alpha article</a>.</p>
<p>四元数是一种常用于表示旋转的数学结构。它们背后的数学是我无法理解的(它涉及虚数和4D空间)，所以我不会在这里讨论它们。如果你真的想深入了解它们，<a target="_blank" rel="noopener" href="https://mathworld.wolfram.com/Quaternion.html">这里有一篇Wolfram Alpha文章</a>。</p>
</div>

<p>Using these values directly in the shader would be a pain as quaternions don’t have a WGSL analog. I don’t feel like writing the math in the shader, so we’ll convert the Instance data into a matrix and store it into a struct called InstanceRaw.</p>
<p>直接在着色器中使用这些值会很痛苦，因为WGSL没有四元数模拟。我不想在着色器中编写数学，所以我们将实例数据转换为矩阵，并将其存储到名为InstanceRaw的结构中。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// NEW!</span></span><br><span class="line"><span class="meta">#[repr(C)]</span></span><br><span class="line"><span class="meta">#[derive(Copy, Clone, bytemuck::Pod, bytemuck::Zeroable)]</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">InstanceRaw</span></span> &#123;</span><br><span class="line">    model: [[<span class="built_in">f32</span>; <span class="number">4</span>]; <span class="number">4</span>],</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>This is the data that will go into the wgpu::Buffer. We keep these separate so that we can update the Instance as much as we want without needing to mess with matrices. We only need to update the raw data before we draw.</p>
<p>这是将进入wgpu::Buffer的数据。我们将它们分开，这样我们就可以随心所欲地更新实例，而无需弄乱矩阵。我们只需要在绘制之前更新原始数据。</p>
<p>Let’s create a method on Instance to convert to InstanceRaw.</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// NEW!</span></span><br><span class="line"><span class="keyword">impl</span> Instance &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">to_raw</span></span>(&amp;<span class="keyword">self</span>) -&gt; InstanceRaw &#123;</span><br><span class="line">        InstanceRaw &#123;</span><br><span class="line">            model: (cgmath::Matrix4::from_translation(<span class="keyword">self</span>.position) * cgmath::Matrix4::from(<span class="keyword">self</span>.rotation)).into(),</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Now we need to add 2 fields to State: instances, and instance_buffer.</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">State</span></span> &#123;</span><br><span class="line">    instances: <span class="built_in">Vec</span>&lt;Instance&gt;,</span><br><span class="line">    instance_buffer: wgpu::Buffer,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>We’ll create the instances in new(). We’ll use some constants to simplify things. We’ll display our instances in 10 rows of 10, and they’ll be spaced evenly apart.</p>
<p>我们将在new()中创建实例。我们将使用一些常量来简化事情。我们将以10行10列的形式显示我们的实例，并且它们将均匀地间隔开。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> NUM_INSTANCES_PER_ROW: <span class="built_in">u32</span> = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> NUM_INSTANCES: <span class="built_in">u32</span> = NUM_INSTANCES_PER_ROW * NUM_INSTANCES_PER_ROW;</span><br><span class="line"><span class="keyword">const</span> INSTANCE_DISPLACEMENT: cgmath::Vector3&lt;<span class="built_in">f32</span>&gt; = cgmath::Vector3::new(NUM_INSTANCES_PER_ROW <span class="keyword">as</span> <span class="built_in">f32</span> * <span class="number">0.5</span>, <span class="number">0.0</span>, NUM_INSTANCES_PER_ROW <span class="keyword">as</span> <span class="built_in">f32</span> * <span class="number">0.5</span>);</span><br></pre></td></tr></table></figure>

<p>Now we can create the actual instances.</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span> State &#123;</span><br><span class="line">    <span class="keyword">async</span> <span class="function"><span class="keyword">fn</span> <span class="title">new</span></span>(window: &amp;Window) -&gt; <span class="keyword">Self</span> &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="keyword">let</span> instances = (<span class="number">0</span>..NUM_INSTANCES_PER_ROW).flat_map(|z| &#123;</span><br><span class="line">            (<span class="number">0</span>..NUM_INSTANCES_PER_ROW).map(<span class="keyword">move</span> |x| &#123;</span><br><span class="line">                <span class="keyword">let</span> position = cgmath::Vector3 &#123; x: x <span class="keyword">as</span> <span class="built_in">f32</span>, y: <span class="number">0.0</span>, z: z <span class="keyword">as</span> <span class="built_in">f32</span> &#125; - INSTANCE_DISPLACEMENT;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">let</span> rotation = <span class="keyword">if</span> position.is_zero() &#123;</span><br><span class="line">                    <span class="comment">// this is needed so an object at (0, 0, 0) won&#x27;t get scaled to zero</span></span><br><span class="line">                    <span class="comment">// as Quaternions can effect scale if they&#x27;re not created correctly</span></span><br><span class="line">                    cgmath::Quaternion::from_axis_angle(cgmath::Vector3::unit_z(), cgmath::Deg(<span class="number">0.0</span>))</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    cgmath::Quaternion::from_axis_angle(position.normalize(), cgmath::Deg(<span class="number">45.0</span>))</span><br><span class="line">                &#125;;</span><br><span class="line"></span><br><span class="line">                Instance &#123;</span><br><span class="line">                    position, rotation,</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;).collect::&lt;<span class="built_in">Vec</span>&lt;_&gt;&gt;();</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Now that we have our data, we can create the actual instance_buffer.</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> instance_data = instances.iter().map(Instance::to_raw).collect::&lt;<span class="built_in">Vec</span>&lt;_&gt;&gt;();</span><br><span class="line"><span class="keyword">let</span> instance_buffer = device.create_buffer_init(</span><br><span class="line">    &amp;wgpu::util::BufferInitDescriptor &#123;</span><br><span class="line">        label: <span class="literal">Some</span>(<span class="string">&quot;Instance Buffer&quot;</span>),</span><br><span class="line">        contents: bytemuck::cast_slice(&amp;instance_data),</span><br><span class="line">        usage: wgpu::BufferUsage::VERTEX,</span><br><span class="line">    &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>We’re going to need to create a new VertexBufferLayout for InstanceRaw.</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span> InstanceRaw &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">desc</span></span>&lt;<span class="symbol">&#x27;a</span>&gt;() -&gt; wgpu::VertexBufferLayout&lt;<span class="symbol">&#x27;a</span>&gt; &#123;</span><br><span class="line">        <span class="keyword">use</span> std::mem;</span><br><span class="line">        wgpu::VertexBufferLayout &#123;</span><br><span class="line">            array_stride: mem::size_of::&lt;InstanceRaw&gt;() <span class="keyword">as</span> wgpu::BufferAddress,</span><br><span class="line">            <span class="comment">// We need to switch from using a step mode of Vertex to Instance</span></span><br><span class="line">            <span class="comment">// This means that our shaders will only change to use the next</span></span><br><span class="line">            <span class="comment">// instance when the shader starts processing a new instance</span></span><br><span class="line">            step_mode: wgpu::InputStepMode::Instance,</span><br><span class="line">            attributes: &amp;[</span><br><span class="line">                wgpu::VertexAttribute &#123;</span><br><span class="line">                    offset: <span class="number">0</span>,</span><br><span class="line">                    <span class="comment">// While our vertex shader only uses locations 0, and 1 now, in later tutorials we&#x27;ll</span></span><br><span class="line">                    <span class="comment">// be using 2, 3, and 4, for Vertex. We&#x27;ll start at slot 5 not conflict with them later</span></span><br><span class="line">                    shader_location: <span class="number">5</span>,</span><br><span class="line">                    format: wgpu::VertexFormat::Float32x4,</span><br><span class="line">                &#125;,</span><br><span class="line">                <span class="comment">// A mat4 takes up 4 vertex slots as it is technically 4 vec4s. We need to define a slot</span></span><br><span class="line">                <span class="comment">// for each vec4. We&#x27;ll have to reassemble the mat4 in</span></span><br><span class="line">                <span class="comment">// the shader.</span></span><br><span class="line">                wgpu::VertexAttribute &#123;</span><br><span class="line">                    offset: mem::size_of::&lt;[<span class="built_in">f32</span>; <span class="number">4</span>]&gt;() <span class="keyword">as</span> wgpu::BufferAddress,</span><br><span class="line">                    shader_location: <span class="number">6</span>,</span><br><span class="line">                    format: wgpu::VertexFormat::Float32x4,</span><br><span class="line">                &#125;,</span><br><span class="line">                wgpu::VertexAttribute &#123;</span><br><span class="line">                    offset: mem::size_of::&lt;[<span class="built_in">f32</span>; <span class="number">8</span>]&gt;() <span class="keyword">as</span> wgpu::BufferAddress,</span><br><span class="line">                    shader_location: <span class="number">7</span>,</span><br><span class="line">                    format: wgpu::VertexFormat::Float32x4,</span><br><span class="line">                &#125;,</span><br><span class="line">                wgpu::VertexAttribute &#123;</span><br><span class="line">                    offset: mem::size_of::&lt;[<span class="built_in">f32</span>; <span class="number">12</span>]&gt;() <span class="keyword">as</span> wgpu::BufferAddress,</span><br><span class="line">                    shader_location: <span class="number">8</span>,</span><br><span class="line">                    format: wgpu::VertexFormat::Float32x4,</span><br><span class="line">                &#125;,</span><br><span class="line">            ],</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>We need to add this descriptor to the render pipeline so that we can use it when we render.</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> render_pipeline = device.create_render_pipeline(&amp;wgpu::RenderPipelineDescriptor &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    vertex: wgpu::VertexState &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="comment">// UPDATED!</span></span><br><span class="line">        buffers: &amp;[Vertex::desc(), InstanceRaw::desc()],</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>Don’t forget to return our new variables!</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Self</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">// NEW!</span></span><br><span class="line">    instances,</span><br><span class="line">    instance_buffer,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>The last change we need to make is in the render() method. We need to bind our instance_buffer and we need to change the range we’re using in draw_indexed() to include the number of instances.</p>
<p>我们需要做的最后一个更改是render()方法。我们需要绑定实例缓冲区，并且需要更改在draw_indexed()中使用的范围，以包括实例数。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">render_pass.set_pipeline(&amp;<span class="keyword">self</span>.render_pipeline);</span><br><span class="line">render_pass.set_bind_group(<span class="number">0</span>, &amp;<span class="keyword">self</span>.diffuse_bind_group, &amp;[]);</span><br><span class="line">render_pass.set_bind_group(<span class="number">1</span>, &amp;<span class="keyword">self</span>.camera_bind_group, &amp;[]);</span><br><span class="line">render_pass.set_vertex_buffer(<span class="number">0</span>, <span class="keyword">self</span>.vertex_buffer.slice(..));</span><br><span class="line"><span class="comment">// NEW!</span></span><br><span class="line">render_pass.set_vertex_buffer(<span class="number">1</span>, <span class="keyword">self</span>.instance_buffer.slice(..));</span><br><span class="line">render_pass.set_index_buffer(<span class="keyword">self</span>.index_buffer.slice(..), wgpu::IndexFormat::Uint16);</span><br><span class="line"></span><br><span class="line"><span class="comment">// UPDATED!</span></span><br><span class="line">render_pass.draw_indexed(<span class="number">0</span>..<span class="keyword">self</span>.num_indices, <span class="number">0</span>, <span class="number">0</span>..<span class="keyword">self</span>.instances.len() <span class="keyword">as</span> _);</span><br></pre></td></tr></table></figure>

<div class="note">

<p>Make sure if you add new instances to the Vec, that you recreate the instance_buffer and as well as camera_bind_group, otherwise your new instances won’t show up correctly.</p>
<p>如果向Vec添加新实例，请确保重新创建instance_buffer和camera_bind_group，否则新实例将无法正确显示。</p>
</div>

<p>We need to reference the parts of our new matrix in shader.wgsl so that we can use it for our instances. Add the following to the top of shader.wgsl.</p>
<p>我们需要在shader.wgsl中引用新矩阵的部分，以便将其用于实例。将以下内容添加到shader.wgsl的顶部。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">InstanceInput</span></span> &#123;</span><br><span class="line">    [[location(<span class="number">5</span>)]] model_matrix_0: vec4&lt;<span class="built_in">f32</span>&gt;;</span><br><span class="line">    [[location(<span class="number">6</span>)]] model_matrix_1: vec4&lt;<span class="built_in">f32</span>&gt;;</span><br><span class="line">    [[location(<span class="number">7</span>)]] model_matrix_2: vec4&lt;<span class="built_in">f32</span>&gt;;</span><br><span class="line">    [[location(<span class="number">8</span>)]] model_matrix_3: vec4&lt;<span class="built_in">f32</span>&gt;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>We need to reassemble the matrix before we can use it.</p>
<p>我们需要重新组装矩阵才能使用它。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[[stage(vertex)]]</span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>(</span><br><span class="line">    model: VertexInput,</span><br><span class="line">    instance: InstanceInput,</span><br><span class="line">) -&gt; VertexOutput &#123;</span><br><span class="line">    <span class="keyword">let</span> model_matrix = mat4x4&lt;<span class="built_in">f32</span>&gt;(</span><br><span class="line">        instance.model_matrix_0,</span><br><span class="line">        instance.model_matrix_1,</span><br><span class="line">        instance.model_matrix_2,</span><br><span class="line">        instance.model_matrix_3,</span><br><span class="line">    );</span><br><span class="line">    <span class="comment">// Continued...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>We’ll apply the model_matrix before we apply camera_uniform.view_proj. We do this because the camera_uniform.view_proj changes the coordinate system from world space to camera space. Our model_matrix is a world space transformation, so we don’t want to be in camera space when using it.</p>
<p>在应用camera_uniform.view_proj项目之前，我们将应用model_matrix。我们这样做是因为camera_uniform.view_proj将坐标系从世界空间更改为camera空间。我们的model_matrix是一个世界空间变换，所以我们不希望在使用它时处于摄影机空间。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[[stage(vertex)]]</span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>(</span><br><span class="line">    model: VertexInput,</span><br><span class="line">    instance: InstanceInput,</span><br><span class="line">) -&gt; VertexOutput &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    var out: VertexOutput;</span><br><span class="line">    out.tex_coords = model.tex_coords;</span><br><span class="line">    out.clip_position = camera.view_proj * model_matrix * vec4&lt;<span class="built_in">f32</span>&gt;(model.position, <span class="number">1.0</span>);</span><br><span class="line">    <span class="keyword">return</span> out;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>With all that done, we should have a forest of trees!</p>
<p><img src="https://sotrh.github.io/learn-wgpu/assets/img/forest.5c5cf3ad.png" alt="trees"></p>
<h1 id="Challenge"><a href="#Challenge" class="headerlink" title="Challenge"></a>Challenge</h1><p>Modify the position and/or rotation of the instances every frame.</p>
<p><a target="_blank" rel="noopener" href="https://github.com/sotrh/learn-wgpu/tree/master/code/beginner/tutorial7-instancing/">Check out the code!</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://qianqians.github.io/2021/09/01/Wgpu%20Uniform%20buffers%20and%20a%203d%20camera/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="qianqians">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="qianqians'blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/09/01/Wgpu%20Uniform%20buffers%20and%20a%203d%20camera/" class="post-title-link" itemprop="url">Wgpu Uniform buffers and a 3d camera</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2021-09-01 15:16:02 / 修改时间：16:39:13" itemprop="dateCreated datePublished" datetime="2021-09-01T15:16:02+08:00">2021-09-01</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Wgpu/" itemprop="url" rel="index"><span itemprop="name">Wgpu</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>While all of our previous work has seemed to be in 2d, we’ve actually been working in 3d the entire time! That’s part of the reason why our Vertex structure has position be an array of 3 floats instead of just 2. We can’t really see the 3d-ness of our scene, because we’re viewing things head on. We’re going to change our point of view by creating a Camera.</p>
<p>虽然我们之前的所有工作似乎都是二维的，但实际上我们一直都在三维中工作！这就是为什么我们的顶点结构的位置是一个由3个浮点数组成的数组而不是2个浮点数的部分原因。我们无法真正看到场景的3d效果，因为我们是正面观看的。我们将通过创建一个摄影机来改变我们的视角。</p>
<h1 id="A-perspective-camera"><a href="#A-perspective-camera" class="headerlink" title="A perspective camera"></a>A perspective camera</h1><p>This tutorial is more about learning to use wgpu and less about linear algebra, so I’m going to gloss over a lot of the math involved. There’s plenty of reading material online if you’re interested in what’s going on under the hood. The first thing to know is that we need cgmath = “0.18” in our Cargo.toml.</p>
<p>本教程更多的是关于学习使用wgpu，而不是关于线性代数，所以我将对涉及的许多数学进行简单讲解。如果你对幕后发生的事情感兴趣，网上有很多阅读材料。首先要知道的是，我们需要在Cargo.toml中使用cgmath=”0.18”。</p>
<p>Now that we have a math library, let’s put it to use! Create a Camera struct above the State struct.</p>
<p>现在我们有了一个数学库，让我们使用它吧！在struct State上方创建struct Camera。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Camera</span></span> &#123;</span><br><span class="line">    eye: cgmath::Point3&lt;<span class="built_in">f32</span>&gt;,</span><br><span class="line">    target: cgmath::Point3&lt;<span class="built_in">f32</span>&gt;,</span><br><span class="line">    up: cgmath::Vector3&lt;<span class="built_in">f32</span>&gt;,</span><br><span class="line">    aspect: <span class="built_in">f32</span>,</span><br><span class="line">    fovy: <span class="built_in">f32</span>,</span><br><span class="line">    znear: <span class="built_in">f32</span>,</span><br><span class="line">    zfar: <span class="built_in">f32</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> Camera &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">build_view_projection_matrix</span></span>(&amp;<span class="keyword">self</span>) -&gt; cgmath::Matrix4&lt;<span class="built_in">f32</span>&gt; &#123;</span><br><span class="line">        <span class="comment">// 1.</span></span><br><span class="line">        <span class="keyword">let</span> view = cgmath::Matrix4::look_at_rh(<span class="keyword">self</span>.eye, <span class="keyword">self</span>.target, <span class="keyword">self</span>.up);</span><br><span class="line">        <span class="comment">// 2.</span></span><br><span class="line">        <span class="keyword">let</span> proj = cgmath::perspective(cgmath::Deg(<span class="keyword">self</span>.fovy), <span class="keyword">self</span>.aspect, <span class="keyword">self</span>.znear, <span class="keyword">self</span>.zfar);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3.</span></span><br><span class="line">        <span class="keyword">return</span> OPENGL_TO_WGPU_MATRIX * proj * view;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>The build_view_projection_matrix is where the magic happens.</p>
<p>build_view_projection_matrix就是魔法发生的地方。</p>
<ol>
<li>The view matrix moves the world to be at the position and rotation of the camera. It’s essentialy an inverse of whatever the transform matrix of the camera would be.</li>
<li>The proj matrix wraps the scene to give the effect of depth. Without this, objects up close would be the same size as objects far away.</li>
<li>The coordinate system in Wgpu is based on DirectX, and Metal’s coordinate systems. That means that in normalized device coordinates the x axis and y axis are in the range of -1.0 to +1.0, and the z axis is 0.0 to +1.0. The cgmath crate (as well as most game math crates) are built for OpenGL’s coordinate system. This matrix will scale and translate our scene from OpenGL’s coordinate sytem to WGPU’s. We’ll define it as follows.</li>
</ol>
<div></div>

<ol>
<li>视图矩阵将世界移动到摄影机的位置并旋转。它本质上是摄像机变换矩阵的逆矩阵。</li>
<li>proj矩阵包裹场景以提供深度效果。如果不这样做，近处的对象将与远处的对象大小相同。</li>
<li>Wgpu中的坐标系基于DirectX和Metal的坐标系。这意味着在标准化设备坐标中，x轴和y轴在-1.0到+1.0的范围内，z轴在0.0到+1.0的范围内。cgmath crate(以及大多数游戏数学库)是为OpenGL的坐标系构建的。该矩阵将缩放并将场景从OpenGL坐标系统转换为WGPU坐标系统。我们将对其进行如下定义。</li>
</ol>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[rustfmt::skip]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">const</span> OPENGL_TO_WGPU_MATRIX: cgmath::Matrix4&lt;<span class="built_in">f32</span>&gt; = cgmath::Matrix4::new(</span><br><span class="line">    <span class="number">1.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>,</span><br><span class="line">    <span class="number">0.0</span>, <span class="number">1.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>,</span><br><span class="line">    <span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">0.5</span>, <span class="number">0.0</span>,</span><br><span class="line">    <span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">0.5</span>, <span class="number">1.0</span>,</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<ul>
<li>Note: We don’t explicitly need the OPENGL_TO_WGPU_MATRIX, but models centered on (0, 0, 0) will be halfway inside the clipping area. This is only an issue if you aren’t using a camera matrix.</li>
</ul>
<div></div>

<ul>
<li>注: 我们并不明确需要OPENGL_TO_WGPU_MATRIX，但是以(0,0,0)为中心的模型将位于剪裁区域的一半。这只是一个问题，如果你不使用相机矩阵。</li>
</ul>
<p>Now let’s add a camera field to State.</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">State</span></span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    camera: Camera,</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">fn</span> <span class="title">new</span></span>(window: &amp;Window) -&gt; <span class="keyword">Self</span> &#123;</span><br><span class="line">    <span class="comment">// let diffuse_bind_group ...</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> camera = Camera &#123;</span><br><span class="line">        <span class="comment">// position the camera one unit up and 2 units back</span></span><br><span class="line">        <span class="comment">// +z is out of the screen</span></span><br><span class="line">        eye: (<span class="number">0.0</span>, <span class="number">1.0</span>, <span class="number">2.0</span>).into(),</span><br><span class="line">        <span class="comment">// have it look at the origin</span></span><br><span class="line">        target: (<span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>).into(),</span><br><span class="line">        <span class="comment">// which way is &quot;up&quot;</span></span><br><span class="line">        up: cgmath::Vector3::unit_y(),</span><br><span class="line">        aspect: sc_desc.width <span class="keyword">as</span> <span class="built_in">f32</span> / sc_desc.height <span class="keyword">as</span> <span class="built_in">f32</span>,</span><br><span class="line">        fovy: <span class="number">45.0</span>,</span><br><span class="line">        znear: <span class="number">0.1</span>,</span><br><span class="line">        zfar: <span class="number">100.0</span>,</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">Self</span> &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        camera,</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Now that we have our camera, and it can make us a view projection matrix, we need somewhere to put it. We also need some way of getting it into our shaders.</p>
<p>现在我们有了相机，它可以使我们成为一个视图投影矩阵，我们需要把它放在某个地方。我们还需要某种方法将其放入着色器中。</p>
<h1 id="The-uniform-buffer"><a href="#The-uniform-buffer" class="headerlink" title="The uniform buffer"></a>The uniform buffer</h1><p>Up to this point we’ve used Buffers to store our vertex and index data, and even to load our textures. We are going to use them again to create what’s known as a uniform buffer. A uniform is a blob of data that is available to every invocation of a set of shaders. We’ve technically already used uniforms for our texture and sampler. We’re going to use them again to store our view projection matrix. To start let’s create a struct to hold our uniform.</p>
<p>到目前为止，我们已经使用缓冲区来存储顶点和索引数据，甚至加载纹理。我们将再次使用它们来创建所谓的uniform缓冲区。uniform是一组着色器的每次调用都可用的数据块。从技术上讲，我们已经为我们的纹理和取样器使用了uniforms。我们将再次使用它们来存储视图投影矩阵。首先，让我们创建一个用于保存uniforms的struct。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// We need this for Rust to store our data correctly for the shaders</span></span><br><span class="line"><span class="meta">#[repr(C)]</span></span><br><span class="line"><span class="comment">// This is so we can store this in a buffer</span></span><br><span class="line"><span class="meta">#[derive(Debug, Copy, Clone, bytemuck::Pod, bytemuck::Zeroable)]</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">CameraUniform</span></span> &#123;</span><br><span class="line">    <span class="comment">// We can&#x27;t use cgmath with bytemuck directly so we&#x27;ll have</span></span><br><span class="line">    <span class="comment">// to convert the Matrix4 into a 4x4 f32 array</span></span><br><span class="line">    view_proj: [[<span class="built_in">f32</span>; <span class="number">4</span>]; <span class="number">4</span>],</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> CameraUniform &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">new</span></span>() -&gt; <span class="keyword">Self</span> &#123;</span><br><span class="line">        <span class="keyword">use</span> cgmath::SquareMatrix;</span><br><span class="line">        <span class="keyword">Self</span> &#123;</span><br><span class="line">            view_proj: cgmath::Matrix4::identity().into(),</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">update_view_proj</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, camera: &amp;Camera) &#123;</span><br><span class="line">        <span class="keyword">self</span>.view_proj = camera.build_view_projection_matrix().into();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Now that we have our data structured, let’s make our camera_buffer.</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// in new() after creating `camera`</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut</span> camera_uniform = CameraUniform::new();</span><br><span class="line">camera_uniform.update_view_proj(&amp;camera);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> camera_buffer = device.create_buffer_init(</span><br><span class="line">    &amp;wgpu::util::BufferInitDescriptor &#123;</span><br><span class="line">        label: <span class="literal">Some</span>(<span class="string">&quot;Camera Buffer&quot;</span>),</span><br><span class="line">        contents: bytemuck::cast_slice(&amp;[camera_uniform]),</span><br><span class="line">        usage: wgpu::BufferUsage::UNIFORM | wgpu::BufferUsage::COPY_DST,</span><br><span class="line">    &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<h1 id="Uniform-buffers-and-bind-groups"><a href="#Uniform-buffers-and-bind-groups" class="headerlink" title="Uniform buffers and bind groups"></a>Uniform buffers and bind groups</h1><p>Cool, now that we have a uniform buffer, what do we do with it? The answer is we create a bind group for it. First we have to create the bind group layout.</p>
<p>既然我们有了一个uniform的缓冲区，我们该怎么处理它呢？答案是我们为它创建一个bind group。首先，我们必须创建bind group layout。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> camera_bind_group_layout = device.create_bind_group_layout(&amp;wgpu::BindGroupLayoutDescriptor &#123;</span><br><span class="line">    entries: &amp;[</span><br><span class="line">        wgpu::BindGroupLayoutEntry &#123;</span><br><span class="line">            binding: <span class="number">0</span>,</span><br><span class="line">            visibility: wgpu::ShaderStage::VERTEX,</span><br><span class="line">            ty: wgpu::BindingType::Buffer &#123;</span><br><span class="line">                ty: wgpu::BufferBindingType::Uniform,</span><br><span class="line">                has_dynamic_offset: <span class="literal">false</span>,</span><br><span class="line">                min_binding_size: <span class="literal">None</span>,</span><br><span class="line">            &#125;,</span><br><span class="line">            count: <span class="literal">None</span>,</span><br><span class="line">        &#125;</span><br><span class="line">    ],</span><br><span class="line">    label: <span class="literal">Some</span>(<span class="string">&quot;camera_bind_group_layout&quot;</span>),</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<ol>
<li>We only really need camera information in the vertex shader, as that’s what we’ll use to manipulate our vertices.</li>
<li>The dynamic field indicates whether this buffer will change size or not. This is useful if we want to store an array of things in our uniforms.</li>
</ol>
<div></div>

<ol>
<li>我们只在顶点着色器中需要摄影机信息，因为我们将使用这些信息来操纵顶点。</li>
<li>dynamic字段指示此缓冲区是否将更改大小。如果我们想在制服中存储一系列的东西，这是很有用的。</li>
</ol>
<p>Now we can create the actual bind group.</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> camera_bind_group = device.create_bind_group(&amp;wgpu::BindGroupDescriptor &#123;</span><br><span class="line">    layout: &amp;camera_bind_group_layout,</span><br><span class="line">    entries: &amp;[</span><br><span class="line">        wgpu::BindGroupEntry &#123;</span><br><span class="line">            binding: <span class="number">0</span>,</span><br><span class="line">            resource: camera_buffer.as_entire_binding(),</span><br><span class="line">        &#125;</span><br><span class="line">    ],</span><br><span class="line">    label: <span class="literal">Some</span>(<span class="string">&quot;camera_bind_group&quot;</span>),</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>Like with our texture, we need to register our camera_bind_group_layout with the render pipeline.</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> render_pipeline_layout = device.create_pipeline_layout(</span><br><span class="line">    &amp;wgpu::PipelineLayoutDescriptor &#123;</span><br><span class="line">        label: <span class="literal">Some</span>(<span class="string">&quot;Render Pipeline Layout&quot;</span>),</span><br><span class="line">        bind_group_layouts: &amp;[</span><br><span class="line">            &amp;texture_bind_group_layout,</span><br><span class="line">            &amp;camera_bind_group_layout,</span><br><span class="line">        ],</span><br><span class="line">        push_constant_ranges: &amp;[],</span><br><span class="line">    &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>Now we need to add camera_buffer and camera_bind_group to State</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">State</span></span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    camera: Camera,</span><br><span class="line">    camera_uniform: CameraUniform,</span><br><span class="line">    camera_buffer: wgpu::Buffer,</span><br><span class="line">    camera_bind_group: wgpu::BindGroup,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">fn</span> <span class="title">new</span></span>(window: &amp;Window) -&gt; <span class="keyword">Self</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">Self</span> &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        camera,</span><br><span class="line">        camera_uniform,</span><br><span class="line">        camera_buffer,</span><br><span class="line">        camera_bind_group,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>The final thing we need to do before we get into shaders is use the bind group in render().</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">render_pass.set_pipeline(&amp;<span class="keyword">self</span>.render_pipeline);</span><br><span class="line">render_pass.set_bind_group(<span class="number">0</span>, &amp;<span class="keyword">self</span>.diffuse_bind_group, &amp;[]);</span><br><span class="line"><span class="comment">// NEW!</span></span><br><span class="line">render_pass.set_bind_group(<span class="number">1</span>, &amp;<span class="keyword">self</span>.camera_bind_group, &amp;[]);</span><br><span class="line">render_pass.set_vertex_buffer(<span class="number">0</span>, <span class="keyword">self</span>.vertex_buffer.slice(..));</span><br><span class="line">render_pass.set_index_buffer(<span class="keyword">self</span>.index_buffer.slice(..), wgpu::IndexFormat::Uint16);</span><br><span class="line"></span><br><span class="line">render_pass.draw_indexed(<span class="number">0</span>..<span class="keyword">self</span>.num_indices, <span class="number">0</span>, <span class="number">0</span>..<span class="number">1</span>);</span><br></pre></td></tr></table></figure>

<h1 id="Using-the-uniform-in-the-vertex-shader"><a href="#Using-the-uniform-in-the-vertex-shader" class="headerlink" title="Using the uniform in the vertex shader"></a>Using the uniform in the vertex shader</h1><p>Modify the vertex shader to include the following.</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Vertex shader</span></span><br><span class="line"></span><br><span class="line">[[block]] <span class="comment">// 1.</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">CameraUniform</span></span> &#123;</span><br><span class="line">    view_proj: mat4x4&lt;<span class="built_in">f32</span>&gt;;</span><br><span class="line">&#125;;</span><br><span class="line">[[group(<span class="number">1</span>), binding(<span class="number">0</span>)]] <span class="comment">// 2.</span></span><br><span class="line">var&lt;uniform&gt; camera: Camera;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">VertexInput</span></span> &#123;</span><br><span class="line">    [[location(<span class="number">0</span>)]] position: vec3&lt;<span class="built_in">f32</span>&gt;;</span><br><span class="line">    [[location(<span class="number">1</span>)]] tex_coords: vec2&lt;<span class="built_in">f32</span>&gt;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">VertexOutput</span></span> &#123;</span><br><span class="line">    [[builtin(position)]] clip_position: vec4&lt;<span class="built_in">f32</span>&gt;;</span><br><span class="line">    [[location(<span class="number">0</span>)]] tex_coords: vec2&lt;<span class="built_in">f32</span>&gt;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">[[stage(vertex)]]</span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>(</span><br><span class="line">    model: VertexInput,</span><br><span class="line">) -&gt; VertexOutput &#123;</span><br><span class="line">    var out: VertexOutput;</span><br><span class="line">    out.tex_coords = model.tex_coords;</span><br><span class="line">    out.clip_position = camera.view_proj * vec4&lt;<span class="built_in">f32</span>&gt;(model.position, <span class="number">1.0</span>); <span class="comment">// 3.</span></span><br><span class="line">    <span class="keyword">return</span> out;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>According to the <a target="_blank" rel="noopener" href="https://gpuweb.github.io/gpuweb/wgsl/">WGSL Spec</a>, The block decorator indicates this structure type represents the contents of a buffer resource occupying a single binding slot in the shader’s resource interface. Any structure used as a uniform must be annotated with [[block]]</li>
<li>Because we’ve created a new bind group, we need to specify which one we’re using in the shader. The number is determined by our render_pipeline_layout. The texture_bind_group_layout is listed first, thus it’s group(0), and camera_bind_group is second, so it’s group(1).</li>
<li>Multiplication order is important when it comes to matrices. The vector goes on the right, and the matrices gone on the left in order of importance.</li>
</ol>
<div></div>

<ol>
<li>根据<a target="_blank" rel="noopener" href="https://gpuweb.github.io/gpuweb/wgsl/">WGSL规范</a>，block decorator指示此结构类型表示占用着色器资源接口中单个绑定槽的缓冲区资源的内容。任何用作uniform的结构都必须用[[block]]注释</li>
<li>因为我们已经创建了一个新的bind group，所以需要指定在着色器中使用的bind group。编号由渲染管道布局决定。纹理绑定组布局列在第一位，因此它是group(0)，摄影机绑定组列在第二位，因此它是group(1)。</li>
<li>当涉及到矩阵时，乘法顺序很重要。向量在右边，矩阵按顺序在左边。</li>
</ol>
<h1 id="A-controller-for-our-camera"><a href="#A-controller-for-our-camera" class="headerlink" title="A controller for our camera"></a>A controller for our camera</h1><p>If you run the code right now, you should get something that looks like this.</p>
<p><img src="https://sotrh.github.io/learn-wgpu/assets/img/static-tree.e1f31949.png" alt="static-tree"></p>
<p>The shape’s less stretched now, but it’s still pretty static. You can experiment with moving the camera position around, but most cameras in games move around. Since this tutorial is about using wgpu and not how to process user input, I’m just going to post the CameraController code below.</p>
<p>该形状现在拉伸程度有所降低，但仍然相当静态。你可以尝试移动摄像机的位置，但游戏中的大多数摄像机都会移动。因为本教程是关于使用wgpu而不是如何处理用户输入的，所以我将在下面直接发布CameraController代码。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">CameraController</span></span> &#123;</span><br><span class="line">    speed: <span class="built_in">f32</span>,</span><br><span class="line">    is_up_pressed: <span class="built_in">bool</span>,</span><br><span class="line">    is_down_pressed: <span class="built_in">bool</span>,</span><br><span class="line">    is_forward_pressed: <span class="built_in">bool</span>,</span><br><span class="line">    is_backward_pressed: <span class="built_in">bool</span>,</span><br><span class="line">    is_left_pressed: <span class="built_in">bool</span>,</span><br><span class="line">    is_right_pressed: <span class="built_in">bool</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> CameraController &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">new</span></span>(speed: <span class="built_in">f32</span>) -&gt; <span class="keyword">Self</span> &#123;</span><br><span class="line">        <span class="keyword">Self</span> &#123;</span><br><span class="line">            speed,</span><br><span class="line">            is_up_pressed: <span class="literal">false</span>,</span><br><span class="line">            is_down_pressed: <span class="literal">false</span>,</span><br><span class="line">            is_forward_pressed: <span class="literal">false</span>,</span><br><span class="line">            is_backward_pressed: <span class="literal">false</span>,</span><br><span class="line">            is_left_pressed: <span class="literal">false</span>,</span><br><span class="line">            is_right_pressed: <span class="literal">false</span>,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">process_events</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, event: &amp;WindowEvent) -&gt; <span class="built_in">bool</span> &#123;</span><br><span class="line">        <span class="keyword">match</span> event &#123;</span><br><span class="line">            WindowEvent::KeyboardInput &#123;</span><br><span class="line">                input: KeyboardInput &#123;</span><br><span class="line">                    state,</span><br><span class="line">                    virtual_keycode: <span class="literal">Some</span>(keycode),</span><br><span class="line">                    ..</span><br><span class="line">                &#125;,</span><br><span class="line">                ..</span><br><span class="line">            &#125; =&gt; &#123;</span><br><span class="line">                <span class="keyword">let</span> is_pressed = *state == ElementState::Pressed;</span><br><span class="line">                <span class="keyword">match</span> keycode &#123;</span><br><span class="line">                    VirtualKeyCode::Space =&gt; &#123;</span><br><span class="line">                        <span class="keyword">self</span>.is_up_pressed = is_pressed;</span><br><span class="line">                        <span class="literal">true</span></span><br><span class="line">                    &#125;</span><br><span class="line">                    VirtualKeyCode::LShift =&gt; &#123;</span><br><span class="line">                        <span class="keyword">self</span>.is_down_pressed = is_pressed;</span><br><span class="line">                        <span class="literal">true</span></span><br><span class="line">                    &#125;</span><br><span class="line">                    VirtualKeyCode::W | VirtualKeyCode::Up =&gt; &#123;</span><br><span class="line">                        <span class="keyword">self</span>.is_forward_pressed = is_pressed;</span><br><span class="line">                        <span class="literal">true</span></span><br><span class="line">                    &#125;</span><br><span class="line">                    VirtualKeyCode::A | VirtualKeyCode::Left =&gt; &#123;</span><br><span class="line">                        <span class="keyword">self</span>.is_left_pressed = is_pressed;</span><br><span class="line">                        <span class="literal">true</span></span><br><span class="line">                    &#125;</span><br><span class="line">                    VirtualKeyCode::S | VirtualKeyCode::Down =&gt; &#123;</span><br><span class="line">                        <span class="keyword">self</span>.is_backward_pressed = is_pressed;</span><br><span class="line">                        <span class="literal">true</span></span><br><span class="line">                    &#125;</span><br><span class="line">                    VirtualKeyCode::D | VirtualKeyCode::Right =&gt; &#123;</span><br><span class="line">                        <span class="keyword">self</span>.is_right_pressed = is_pressed;</span><br><span class="line">                        <span class="literal">true</span></span><br><span class="line">                    &#125;</span><br><span class="line">                    _ =&gt; <span class="literal">false</span>,</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            _ =&gt; <span class="literal">false</span>,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">update_camera</span></span>(&amp;<span class="keyword">self</span>, camera: &amp;<span class="keyword">mut</span> Camera) &#123;</span><br><span class="line">        <span class="keyword">use</span> cgmath::InnerSpace;</span><br><span class="line">        <span class="keyword">let</span> forward = camera.target - camera.eye;</span><br><span class="line">        <span class="keyword">let</span> forward_norm = forward.normalize();</span><br><span class="line">        <span class="keyword">let</span> forward_mag = forward.magnitude();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Prevents glitching when camera gets too close to the</span></span><br><span class="line">        <span class="comment">// center of the scene.</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">self</span>.is_forward_pressed &amp;&amp; forward_mag &gt; <span class="keyword">self</span>.speed &#123;</span><br><span class="line">            camera.eye += forward_norm * <span class="keyword">self</span>.speed;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">self</span>.is_backward_pressed &#123;</span><br><span class="line">            camera.eye -= forward_norm * <span class="keyword">self</span>.speed;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> right = forward_norm.cross(camera.up);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Redo radius calc in case the up/ down is pressed.</span></span><br><span class="line">        <span class="keyword">let</span> forward = camera.target - camera.eye;</span><br><span class="line">        <span class="keyword">let</span> forward_mag = forward.magnitude();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">self</span>.is_right_pressed &#123;</span><br><span class="line">            <span class="comment">// Rescale the distance between the target and eye so </span></span><br><span class="line">            <span class="comment">// that it doesn&#x27;t change. The eye therefore still </span></span><br><span class="line">            <span class="comment">// lies on the circle made by the target and eye.</span></span><br><span class="line">            camera.eye = camera.target - (forward + right * <span class="keyword">self</span>.speed).normalize() * forward_mag;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">self</span>.is_left_pressed &#123;</span><br><span class="line">            camera.eye = camera.target - (forward - right * <span class="keyword">self</span>.speed).normalize() * forward_mag;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>This code is not perfect. The camera slowly moves back when you rotate it. It works for our purposes though. Feel free to improve it!</p>
<p>这个代码并不完美。旋转相机时，相机会慢慢向后移动。不过，它对我们的目的是有效的。请随意改进它！</p>
<p>We still need to plug this into our existing code to make it do anything. Add the controller to State and create it in new().</p>
<p>我们仍然需要将其插入到现有代码中，使其能够执行任何操作。将控制器添加到State并在new()中创建它。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">State</span></span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    camera: Camera,</span><br><span class="line">    <span class="comment">// NEW!</span></span><br><span class="line">    camera_controller: CameraController,</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">impl</span> State &#123;</span><br><span class="line">    <span class="keyword">async</span> <span class="function"><span class="keyword">fn</span> <span class="title">new</span></span>(window: &amp;Window) -&gt; <span class="keyword">Self</span> &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="keyword">let</span> camera_controller = CameraController::new(<span class="number">0.2</span>);</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">Self</span> &#123;</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">            camera_controller,</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>We’re finally going to add some code to input() (assuming you haven’t already)!</p>
<p>最后，我们将向input()添加一些代码(假设您还没有这样做)！</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">input</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, event: &amp;WindowEvent) -&gt; <span class="built_in">bool</span> &#123;</span><br><span class="line">    <span class="keyword">self</span>.camera_controller.process_events(event)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Up to this point, the camera controller isn’t actually doing anything. The values in our uniform buffer need to be updated. There are a few main methods to do that.</p>
<p>到目前为止，相机控制器实际上什么都没有做。我们的uniform缓冲区中的值需要更新。有几种主要的方法可以做到这一点。</p>
<ol>
<li>We can create a separate buffer and copy it’s contents to our camera_buffer. The new buffer is known as a staging buffer. This method is usually how it’s done as it allows the contents of the main buffer (in this case camera_buffer) to only be accessible by the gpu. The gpu can do some speed optimizations which it couldn’t if we could access the buffer via the cpu.</li>
<li>We can call on of the mapping method’s map_read_async, and map_write_async on the buffer itself. These allow us to access a buffer’s contents directly, but requires us to deal with the async aspect of these methods this also requires our buffer to use the BufferUsage::MAP_READ and/or BufferUsage::MAP_WRITE. We won’t talk about it here, but you check out Wgpu without a window tutorial if you want to know more.</li>
<li>We can use write_buffer on queue.</li>
</ol>
<div></div>

<ol>
<li>我们可以创建一个单独的缓冲区，并将其内容复制到我们的相机缓冲区。新缓冲区称为暂存缓冲区。这种方法通常是这样做的，因为它只允许gpu访问主缓冲区（在本例中为camera_缓冲区）的内容。gpu可以做一些速度优化，如果我们可以通过cpu访问缓冲区，它就无法做到。</li>
<li>我们可以在缓冲区本身上调用映射方法的map_read_async和map_write_async。这些允许我们直接访问缓冲区的内容，但要求我们处理这些方法的异步问题。这还要求我们的缓冲区使用BufferUsage::MAP_READ读取和BufferUsage::MAP_WRITE。我们这里不讨论它，但是如果您想了解更多，可以在没有窗口教程的情况下查看Wgpu。</li>
<li>我们可以在队列上使用write_buffer。</li>
</ol>
<p>We’re going to use option number 3.</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">update</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) &#123;</span><br><span class="line">    <span class="keyword">self</span>.camera_controller.update_camera(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>.camera);</span><br><span class="line">    <span class="keyword">self</span>.camera_uniform.update_view_proj(&amp;<span class="keyword">self</span>.camera);</span><br><span class="line">    <span class="keyword">self</span>.queue.write_buffer(&amp;<span class="keyword">self</span>.camera_buffer, <span class="number">0</span>, bytemuck::cast_slice(&amp;[<span class="keyword">self</span>.camera_uniform]));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>That’s all we need to do. If you run the code now you should see a pentagon with our tree texture that you can rotate around and zoom into with the wasd/arrow keys.</p>
<p>这就是我们需要做的。如果你现在运行代码，你会看到一个五边形和我们的树纹理，你可以通过wasd/箭头键旋转和放大。</p>
<h1 id="Challenge"><a href="#Challenge" class="headerlink" title="Challenge"></a>Challenge</h1><p>让我们的模型独立于相机旋转。提示：您需要另一个矩阵。</p>
<p><a target="_blank" rel="noopener" href="https://github.com/sotrh/learn-wgpu/tree/master/code/beginner/tutorial6-uniforms/">Check out the code!</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://qianqians.github.io/2021/08/25/Wgpu%20Textures%20and%20bind%20groups/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="qianqians">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="qianqians'blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/08/25/Wgpu%20Textures%20and%20bind%20groups/" class="post-title-link" itemprop="url">Wgpu Textures and bind groups</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-08-25 14:55:56" itemprop="dateCreated datePublished" datetime="2021-08-25T14:55:56+08:00">2021-08-25</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-08-26 15:50:42" itemprop="dateModified" datetime="2021-08-26T15:50:42+08:00">2021-08-26</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Wgpu/" itemprop="url" rel="index"><span itemprop="name">Wgpu</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>Up to this point we have been drawing super simple shapes. While we can make a game with just triangles, trying to draw highly detailed objects would massively limit what devices could even run our game. However, we can get around this problem with textures.</p>
<p>到目前为止，我们一直在画超级简单的形状。虽然我们可以制作一个只有三角形的游戏，但尝试绘制高度详细的对象将极大地限制哪些设备甚至可以运行我们的游戏。然而，我们可以通过纹理来解决这个问题。</p>
<p>Textures are images overlayed on a triangle mesh to make it seem more detailed. There are multiple types of textures such as normal maps, bump maps, specular maps and diffuse maps. We’re going to talk about diffuse maps, or more simply, the color texture.</p>
<p>纹理是叠加在三角形网格上的图像，使其看起来更详细。有多种类型的纹理，例如法线贴图、凹凸贴图、镜面反射贴图和漫反射贴图。我们将讨论漫反射贴图，或者更简单地说，颜色纹理。</p>
<h1 id="Loading-an-image-from-a-file"><a href="#Loading-an-image-from-a-file" class="headerlink" title="Loading an image from a file"></a>Loading an image from a file</h1><p>If we want to map an image to our mesh, we first need an image. Let’s use this happy little tree:</p>
<p>如果要将图像映射到网格，首先需要一个图像。让我们用这棵快乐的小树：</p>
<p><img src="https://sotrh.github.io/learn-wgpu/assets/img/happy-tree.bdff8a19.png" alt="小树"></p>
<p>We’ll use the image crate to load our tree. We already added to our dependencies in the first section, so all we have to do is use it.</p>
<p>我们将使用image crate来装载我们的树。我们已经在第一节中添加了依赖项，所以我们所要做的就是使用它。</p>
<p>In State’s new() method add the following just after creating the swap_chain:</p>
<p>在State的new()方法中，在创建swap_chain之后添加以下内容：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> swap_chain = device.create_swap_chain(&amp;surface, &amp;sc_desc);</span><br><span class="line"><span class="comment">// NEW!</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> diffuse_bytes = include_bytes!(<span class="string">&quot;happy-tree.png&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> diffuse_image = image::load_from_memory(diffuse_bytes).unwrap();</span><br><span class="line"><span class="keyword">let</span> diffuse_rgba = diffuse_image.as_rgba8().unwrap();</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> image::GenericImageView;</span><br><span class="line"><span class="keyword">let</span> dimensions = diffuse_image.dimensions();</span><br></pre></td></tr></table></figure>

<p>Here we grab the bytes from our image file and load them into an image which is then converted into a Vec of rgba bytes. We also save the image’s dimensions for when we create the actual Texture.</p>
<p>在这里，我们从图像文件中获取bytes，并将它们加载到图像中，然后将图像转换为rgba字节的Vec。我们还保存图像的尺寸，以便在创建实际纹理时使用。</p>
<p>Now, let’s create the Texture:</p>
<p>现在，让我们创建纹理：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> texture_size = wgpu::Extent3d &#123;</span><br><span class="line">    width: dimensions.<span class="number">0</span>,</span><br><span class="line">    height: dimensions.<span class="number">1</span>,</span><br><span class="line">    depth_or_array_layers: <span class="number">1</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> diffuse_texture = device.create_texture(</span><br><span class="line">    &amp;wgpu::TextureDescriptor &#123;</span><br><span class="line">        <span class="comment">// All textures are stored as 3D, we represent our 2D texture</span></span><br><span class="line">        <span class="comment">// by setting depth to 1.</span></span><br><span class="line">        size: texture_size,</span><br><span class="line">        mip_level_count: <span class="number">1</span>, <span class="comment">// We&#x27;ll talk about this a little later</span></span><br><span class="line">        sample_count: <span class="number">1</span>,</span><br><span class="line">        dimension: wgpu::TextureDimension::D2,</span><br><span class="line">        <span class="comment">// Most images are stored using sRGB so we need to reflect that here.</span></span><br><span class="line">        format: wgpu::TextureFormat::Rgba8UnormSrgb,</span><br><span class="line">        <span class="comment">// SAMPLED tells wgpu that we want to use this texture in shaders</span></span><br><span class="line">        <span class="comment">// COPY_DST means that we want to copy data to this texture</span></span><br><span class="line">        usage: wgpu::TextureUsage::SAMPLED | wgpu::TextureUsage::COPY_DST,</span><br><span class="line">        label: <span class="literal">Some</span>(<span class="string">&quot;diffuse_texture&quot;</span>),</span><br><span class="line">    &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<h1 id="Getting-data-into-a-Texture"><a href="#Getting-data-into-a-Texture" class="headerlink" title="Getting data into a Texture"></a>Getting data into a Texture</h1><p>The Texture struct has no methods to interact with the data directly. However, we can use a method on the queue we created earlier called write_texture to load the texture in. Let’s take a look at how we do that:</p>
<p>纹理结构没有直接与数据交互的方法。但是，我们可以在前面创建的队列上使用一个名为write_texture的方法来加载纹理。让我们来看看我们是如何做到这一点的：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">queue.write_texture(</span><br><span class="line">    <span class="comment">// Tells wgpu where to copy the pixel data</span></span><br><span class="line">    wgpu::ImageCopyTexture &#123;</span><br><span class="line">        texture: &amp;diffuse_texture,</span><br><span class="line">        mip_level: <span class="number">0</span>,</span><br><span class="line">        origin: wgpu::Origin3d::ZERO,</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// The actual pixel data</span></span><br><span class="line">    diffuse_rgba,</span><br><span class="line">    <span class="comment">// The layout of the texture</span></span><br><span class="line">    wgpu::ImageDataLayout &#123;</span><br><span class="line">        offset: <span class="number">0</span>,</span><br><span class="line">        bytes_per_row: std::num::NonZeroU32::new(<span class="number">4</span> * dimensions.<span class="number">0</span>),</span><br><span class="line">        rows_per_image: std::num::NonZeroU32::new(dimensions.<span class="number">1</span>),</span><br><span class="line">    &#125;,</span><br><span class="line">    texture_size,</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<dic class="note">

<p>The old way of writing data to a texture was to copy the pixel data to a buffer and then copy it to the texture. Using write_texture is a bit more efficient as it uses one less buffer - I’ll leave it here though in case you need it.</p>
<p>将数据写入纹理的旧方法是将像素数据复制到缓冲区，然后将其复制到纹理。使用write_texture更有效，因为它使用的缓冲区少了一个，不过我会把它放在这里，以备您需要。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> buffer = device.create_buffer_init(</span><br><span class="line">    &amp;wgpu::util::BufferInitDescriptor &#123;</span><br><span class="line">        label: <span class="literal">Some</span>(<span class="string">&quot;Temp Buffer&quot;</span>),</span><br><span class="line">        contents: &amp;diffuse_rgba,</span><br><span class="line">        usage: wgpu::BufferUsage::COPY_SRC,</span><br><span class="line">    &#125;</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut</span> encoder = device.create_command_encoder(&amp;wgpu::CommandEncoderDescriptor &#123;</span><br><span class="line">    label: <span class="literal">Some</span>(<span class="string">&quot;texture_buffer_copy_encoder&quot;</span>),</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">encoder.copy_buffer_to_texture(</span><br><span class="line">    wgpu::ImageCopyBuffer &#123;</span><br><span class="line">        buffer: &amp;buffer,</span><br><span class="line">        offset: <span class="number">0</span>,</span><br><span class="line">        bytes_per_row: <span class="number">4</span> * dimensions.<span class="number">0</span>,</span><br><span class="line">        rows_per_image: dimensions.<span class="number">1</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    wgpu::ImageCopyTexture &#123;</span><br><span class="line">        texture: &amp;diffuse_texture,</span><br><span class="line">        mip_level: <span class="number">0</span>,</span><br><span class="line">        array_layer: <span class="number">0</span>,</span><br><span class="line">        origin: wgpu::Origin3d::ZERO,</span><br><span class="line">    &#125;,</span><br><span class="line">    size,</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">queue.submit(std::iter::once(encoder.finish()));</span><br></pre></td></tr></table></figure>

<p>The bytes_per_row field needs some consideration. This value needs to be a multiple of 256. Check out the gif tutorial for more details.</p>
<p>每行字节数字段需要考虑。此值必须是256的倍数。有关详细信息，请查看gif教程。</p>
</div>

<h1 id="TextureViews-and-Samplers"><a href="#TextureViews-and-Samplers" class="headerlink" title="TextureViews and Samplers"></a>TextureViews and Samplers</h1><p>Now that our texture has data in it, we need a way to use it. This is where a TextureView and a Sampler come in. A TextureView offers us a view into our texture. A Sampler controls how the Texture is sampled. Sampling works similar to the eyedropper tool in GIMP/Photoshop. Our program supplies a coordinate on the texture (known as a texture coordinate), and the sampler then returns the corresponding color based on the texture and some internal parameters.</p>
<p>既然我们的纹理中有数据，我们需要一种使用它的方法。这就是TextureView和采样器的作用。纹理视图为我们提供了纹理视图。采样器控制纹理的采样方式。采样的工作原理类似于GIMP/Photoshop中的滴管工具。我们的程序在纹理上提供一个坐标(称为纹理坐标)，然后采样器根据纹理和一些内部参数返回相应的颜色。</p>
<p>Let’s define our diffuse_texture_view and diffuse_sampler now:</p>
<p>现在让我们定义diffuse_texture_view和diffuse_sampler：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// We don&#x27;t need to configure the texture view much, so let&#x27;s</span></span><br><span class="line"><span class="comment">// let wgpu define it.</span></span><br><span class="line"><span class="keyword">let</span> diffuse_texture_view = diffuse_texture.create_view(&amp;wgpu::TextureViewDescriptor::default());</span><br><span class="line"><span class="keyword">let</span> diffuse_sampler = device.create_sampler(&amp;wgpu::SamplerDescriptor &#123;</span><br><span class="line">    address_mode_u: wgpu::AddressMode::ClampToEdge,</span><br><span class="line">    address_mode_v: wgpu::AddressMode::ClampToEdge,</span><br><span class="line">    address_mode_w: wgpu::AddressMode::ClampToEdge,</span><br><span class="line">    mag_filter: wgpu::FilterMode::Linear,</span><br><span class="line">    min_filter: wgpu::FilterMode::Nearest,</span><br><span class="line">    mipmap_filter: wgpu::FilterMode::Nearest,</span><br><span class="line">    ..<span class="built_in">Default</span>::default()</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>The address_mode_* parameters determine what to do if the sampler gets a texture coordinate that’s outside of the texture itself. We have a few options to choose from:</p>
<p>address_mode_*参数决定了如果采样器获得的纹理坐标位于纹理本身之外，该怎么办。我们有几个选项可供选择：</p>
<ul>
<li>ClampToEdge: Any texture coordinates outside the texture will return the color of the nearest pixel on the edges of the texture.</li>
<li>Repeat: The texture will repeat as texture coordinates exceed the textures dimensions.</li>
<li>MirrorRepeat: Similar to Repeat, but the image will flip when going over boundaries.</li>
</ul>
<div></div>

<ul>
<li>ClampToEdge：纹理外部的任何纹理坐标都将返回纹理边缘上最近像素的颜色。</li>
<li>Repeat：纹理坐标超过纹理尺寸时，纹理将重复。</li>
<li>MirrorRepeat: 与“重复”类似，但图像在越过边界时将翻转。</li>
</ul>
<p><img src="https://sotrh.github.io/learn-wgpu/assets/img/address_mode.66a7cd1a.png" alt="sampler"></p>
<p>The mag_filter and min_filter options describe what to do when a fragment covers multiple pixels, or there are multiple fragments for a single pixel. This often comes into play when viewing a surface from up close, or from far away.</p>
<p>mag_filter和min_filter选项描述了当一个片段覆盖多个像素，或者一个像素有多个片段时该怎么做。这通常在从近距离或远处查看曲面时起作用。</p>
<p>There are 2 options:</p>
<p>有两种选择：</p>
<ul>
<li>Linear: Attempt to blend the in-between fragments so that they seem to flow together.</li>
<li>Nearest: In-between fragments will use the color of the nearest pixel. This creates an image that’s crisper from far away, but pixelated up close. This can be desirable, however, if your textures are designed to be pixelated, like in pixel art games, or voxel games like Minecraft.</li>
</ul>
<div></div>

<ul>
<li>Linear: 尝试将片段混合在一起，使它们看起来是一起流动的。</li>
<li>Nearest: 在片段之间，将使用最近像素的颜色。这将创建一个从远处看更清晰的图像，但在近距离内像素化。然而，如果你的纹理被设计成像素化，比如像素艺术游戏，或者像Minecraft这样的体素游戏，这可能是可取的。</li>
</ul>
<p>Mipmaps are a complex topic, and will require their own section in the future. For now, we can say that mipmap_filter functions similar to (mag/min)_filter as it tells the sampler how to blend between mipmaps.</p>
<p>mipmap是一个复杂的主题，将来需要的部分讨论。现在，我们可以说mipmap_filter的功能类似于(mag/min)_filter，因为它告诉采样器如何在mipmap之间混合。</p>
<p>I’m using some defaults for the other fields. If you want to see what they are, check <a target="_blank" rel="noopener" href="https://docs.rs/wgpu/0.7.0/wgpu/struct.SamplerDescriptor.html">the wgpu docs</a>.</p>
<p>我对其他字段使用了一些默认值。如果您想查看它们是什么，请查看<a target="_blank" rel="noopener" href="https://docs.rs/wgpu/0.7.0/wgpu/struct.SamplerDescriptor.html">wgpu文档</a>。</p>
<p>All these different resources are nice and all, but they don’t do us much good if we can’t plug them in anywhere. This is where BindGroups and PipelineLayouts come in.</p>
<p>所有这些不同的资源都很好，但是如果我们不能在任何地方插入它们，它们对我们没有多大好处。这就是BindGroups和PipelineLayouts的用武之地。</p>
<h1 id="The-BindGroup"><a href="#The-BindGroup" class="headerlink" title="The BindGroup"></a>The BindGroup</h1><p>A BindGroup describes a set of resources and how they can be accessed by a shader. We create a BindGroup using a BindGroupLayout. Let’s make one of those first.</p>
<p>BindGroup描述一组资源以及着色器如何访问这些资源。我们使用BindGroupLayout创建一个BindGroup。让我们先做一个。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> texture_bind_group_layout = device.create_bind_group_layout(</span><br><span class="line">    &amp;wgpu::BindGroupLayoutDescriptor &#123;</span><br><span class="line">        entries: &amp;[</span><br><span class="line">            wgpu::BindGroupLayoutEntry &#123;</span><br><span class="line">                binding: <span class="number">0</span>,</span><br><span class="line">                visibility: wgpu::ShaderStage::FRAGMENT,</span><br><span class="line">                ty: wgpu::BindingType::Texture &#123;</span><br><span class="line">                    multisampled: <span class="literal">false</span>,</span><br><span class="line">                    view_dimension: wgpu::TextureViewDimension::D2,</span><br><span class="line">                    sample_type: wgpu::TextureSampleType::Float &#123; filterable: <span class="literal">true</span> &#125;,</span><br><span class="line">                &#125;,</span><br><span class="line">                count: <span class="literal">None</span>,</span><br><span class="line">            &#125;,</span><br><span class="line">            wgpu::BindGroupLayoutEntry &#123;</span><br><span class="line">                binding: <span class="number">1</span>,</span><br><span class="line">                visibility: wgpu::ShaderStage::FRAGMENT,</span><br><span class="line">                ty: wgpu::BindingType::Sampler &#123;</span><br><span class="line">                    <span class="comment">// This is only for TextureSampleType::Depth</span></span><br><span class="line">                    comparison: <span class="literal">false</span>,</span><br><span class="line">                    <span class="comment">// This should be true if the sample_type of the texture is:</span></span><br><span class="line">                    <span class="comment">//     TextureSampleType::Float &#123; filterable: true &#125;</span></span><br><span class="line">                    <span class="comment">// Otherwise you&#x27;ll get an error.</span></span><br><span class="line">                    filtering: <span class="literal">true</span>,</span><br><span class="line">                &#125;,</span><br><span class="line">                count: <span class="literal">None</span>,</span><br><span class="line">            &#125;,</span><br><span class="line">        ],</span><br><span class="line">        label: <span class="literal">Some</span>(<span class="string">&quot;texture_bind_group_layout&quot;</span>),</span><br><span class="line">    &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>Our texture_bind_group_layout has two entries: one for a sampled texture at binding 0, and one for a sampler at binding 1. Both of these bindings are visible only to the fragment shader as specified by FRAGMENT. The possible values for this field are any bitwise combination of NONE, VERTEX, FRAGMENT, or COMPUTE. Most of the time we’ll only use FRAGMENT for textures and samplers, but it’s good to know what else is available.</p>
<p>我们的texture_bind_group_layout有两个条目：一个用于绑定0处的sampled texture，另一个用于绑定1处的sampler。这两个绑定仅对片段指定的片段着色器可见。visibility字段的可能值是NONE、VERTEX、FRAGMENT或COMPUTE的任意位组合。大多数情况下，我们只会对片段使用纹理和采样器，但最好知道还有什么可用的。</p>
<p>With texture_bind_group_layout, we can now create our BindGroup:</p>
<p>使用texture_bind_group_layout，我们现在可以创建BindGroup：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> diffuse_bind_group = device.create_bind_group(</span><br><span class="line">    &amp;wgpu::BindGroupDescriptor &#123;</span><br><span class="line">        layout: &amp;texture_bind_group_layout,</span><br><span class="line">        entries: &amp;[</span><br><span class="line">            wgpu::BindGroupEntry &#123;</span><br><span class="line">                binding: <span class="number">0</span>,</span><br><span class="line">                resource: wgpu::BindingResource::TextureView(&amp;diffuse_texture_view),</span><br><span class="line">            &#125;,</span><br><span class="line">            wgpu::BindGroupEntry &#123;</span><br><span class="line">                binding: <span class="number">1</span>,</span><br><span class="line">                resource: wgpu::BindingResource::Sampler(&amp;diffuse_sampler),</span><br><span class="line">            &#125;</span><br><span class="line">        ],</span><br><span class="line">        label: <span class="literal">Some</span>(<span class="string">&quot;diffuse_bind_group&quot;</span>),</span><br><span class="line">    &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>Looking at this you might get a bit of déjà vu! That’s because a BindGroup is a more specific declaration of the BindGroupLayout. The reason why they’re separate is it allows us to swap out BindGroups on the fly, so long as they all share the same BindGroupLayout. Each texture and sampler we create will need to be added to a BindGroup. For our purposes, we’ll create a new bind group for each texture.</p>
<p>看看这个，你可能会有点似曾相识！这是因为BindGroup是BindGroupLayout的更具体的声明。它们分开的原因是它允许我们动态地交换BindGroups，只要它们都共享相同的BindGroupLayout。我们创建的每个纹理和采样器都需要添加到BindGroup中。出于我们的目的，我们将为每个纹理创建一个新的绑定组。</p>
<p>Now that we have our diffuse_bind_group, let’s add it to our State struct:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">State</span></span> &#123;</span><br><span class="line">    surface: wgpu::Surface,</span><br><span class="line">    device: wgpu::Device,</span><br><span class="line">    queue: wgpu::Queue,</span><br><span class="line">    sc_desc: wgpu::SwapChainDescriptor,</span><br><span class="line">    swap_chain: wgpu::SwapChain,</span><br><span class="line">    size: winit::dpi::PhysicalSize&lt;<span class="built_in">u32</span>&gt;,</span><br><span class="line">    render_pipeline: wgpu::RenderPipeline,</span><br><span class="line">    vertex_buffer: wgpu::Buffer,</span><br><span class="line">    index_buffer: wgpu::Buffer,</span><br><span class="line">    num_indicies: <span class="built_in">u32</span>,</span><br><span class="line">    diffuse_bind_group: wgpu::BindGroup, <span class="comment">// NEW!</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>And make sure we return these fields in the new method:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span> State &#123;</span><br><span class="line">    <span class="keyword">async</span> <span class="function"><span class="keyword">fn</span> <span class="title">new</span></span>() -&gt; <span class="keyword">Self</span> &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="keyword">Self</span> &#123;</span><br><span class="line">            surface,</span><br><span class="line">            device,</span><br><span class="line">            queue,</span><br><span class="line">            sc_desc,</span><br><span class="line">            swap_chain,</span><br><span class="line">            size,</span><br><span class="line">            render_pipeline,</span><br><span class="line">            vertex_buffer,</span><br><span class="line">            index_buffer,</span><br><span class="line">            num_indices,</span><br><span class="line">            <span class="comment">// NEW!</span></span><br><span class="line">            diffuse_bind_group,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Now that we’ve got our BindGroup, we can use it in our render() function.</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// render()</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">render_pass.set_pipeline(&amp;<span class="keyword">self</span>.render_pipeline);</span><br><span class="line">render_pass.set_bind_group(<span class="number">0</span>, &amp;<span class="keyword">self</span>.diffuse_bind_group, &amp;[]); <span class="comment">// NEW!</span></span><br><span class="line">render_pass.set_vertex_buffer(<span class="number">0</span>, <span class="keyword">self</span>.vertex_buffer.slice(..));</span><br><span class="line">render_pass.set_index_buffer(<span class="keyword">self</span>.index_buffer.slice(..), wgpu::IndexFormat::Uint16);</span><br><span class="line"></span><br><span class="line">render_pass.draw_indexed(<span class="number">0</span>..<span class="keyword">self</span>.num_indices, <span class="number">0</span>, <span class="number">0</span>..<span class="number">1</span>);</span><br></pre></td></tr></table></figure>

<h1 id="PipelineLayout"><a href="#PipelineLayout" class="headerlink" title="PipelineLayout"></a>PipelineLayout</h1><p>Remember the PipelineLayout we created back in the pipeline section? Now we finally get to use it! The PipelineLayout contains a list of BindGroupLayouts that the pipeline can use. Modify render_pipeline_layout to use our texture_bind_group_layout.</p>
<p>还记得我们在管道部分创建的PipelineLayout吗？现在我们终于可以使用它了！PipelineLayout包含pipeline可以使用的BindGroupLayouts列表。修改render_pipeline_layout以使用texture_bind_group_layout。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">fn</span> <span class="title">new</span></span>(...) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">let</span> render_pipeline_layout = device.create_pipeline_layout(</span><br><span class="line">        &amp;wgpu::PipelineLayoutDescriptor &#123;</span><br><span class="line">            label: <span class="literal">Some</span>(<span class="string">&quot;Render Pipeline Layout&quot;</span>), <span class="comment">// NEW!</span></span><br><span class="line">            bind_group_layouts: &amp;[&amp;texture_bind_group_layout], <span class="comment">// NEW!</span></span><br><span class="line">            push_constant_ranges: &amp;[],</span><br><span class="line">        &#125;</span><br><span class="line">    );</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="A-change-to-the-VERTICES"><a href="#A-change-to-the-VERTICES" class="headerlink" title="A change to the VERTICES"></a>A change to the VERTICES</h1><p>There’s a few things we need to change about our Vertex definition. Up to now we’ve been using a color attribute to set the color of our mesh. Now that we’re using a texture, we want to replace our color with tex_coords. These coordinates will then be passed to the Sampler to retrieve the appropriate color.</p>
<p>关于顶点定义，我们需要更改一些内容。到目前为止，我们一直在使用颜色属性来设置网格的颜色。现在我们正在使用纹理，我们想用tex_coords替换我们的颜色。然后，这些坐标将传递给采样器以检索适当的颜色。</p>
<p>Since our tex_coords are two dimensional, we’ll change the field to take two floats instead of three.</p>
<p>由于tex_coords是二维的，因此我们将字段更改为采用两个浮点数，而不是三个浮点数。</p>
<p>First, we’ll change the Vertex struct:</p>
<p>首先，我们将更改顶点结构：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[repr(C)]</span></span><br><span class="line"><span class="meta">#[derive(Copy, Clone, Debug, bytemuck::Pod, bytemuck::Zeroable)]</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Vertex</span></span> &#123;</span><br><span class="line">    position: [<span class="built_in">f32</span>; <span class="number">3</span>],</span><br><span class="line">    tex_coords: [<span class="built_in">f32</span>; <span class="number">2</span>], <span class="comment">// NEW!</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>And then reflect these changes in the VertexBufferLayout:</p>
<p>然后在VertexBufferLayout中反映这些更改：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span> Vertex &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">desc</span></span>&lt;<span class="symbol">&#x27;a</span>&gt;() -&gt; wgpu::VertexBufferLayout&lt;<span class="symbol">&#x27;a</span>&gt; &#123;</span><br><span class="line">        <span class="keyword">use</span> std::mem;</span><br><span class="line">        wgpu::VertexBufferLayout &#123;</span><br><span class="line">            array_stride: mem::size_of::&lt;Vertex&gt;() <span class="keyword">as</span> wgpu::BufferAddress,</span><br><span class="line">            step_mode: wgpu::InputStepMode::Vertex,</span><br><span class="line">            attributes: &amp;[</span><br><span class="line">                wgpu::VertexAttribute &#123;</span><br><span class="line">                    offset: <span class="number">0</span>,</span><br><span class="line">                    shader_location: <span class="number">0</span>,</span><br><span class="line">                    format: wgpu::VertexFormat::Float32x3,</span><br><span class="line">                &#125;,</span><br><span class="line">                wgpu::VertexAttribute &#123;</span><br><span class="line">                    offset: mem::size_of::&lt;[<span class="built_in">f32</span>; <span class="number">3</span>]&gt;() <span class="keyword">as</span> wgpu::BufferAddress,</span><br><span class="line">                    shader_location: <span class="number">1</span>,</span><br><span class="line">                    format: wgpu::VertexFormat::Float32x2, <span class="comment">// NEW!</span></span><br><span class="line">                &#125;,</span><br><span class="line">            ]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Lastly we need to change VERTICES itself. Replace the existing definition with the following:</p>
<p>最后，我们需要改变顶点本身。将现有定义替换为以下内容：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Changed</span></span><br><span class="line"><span class="keyword">const</span> VERTICES: &amp;[Vertex] = &amp;[</span><br><span class="line">    Vertex &#123; position: [-<span class="number">0.0868241</span>, <span class="number">0.49240386</span>, <span class="number">0.0</span>], tex_coords: [<span class="number">0.4131759</span>, <span class="number">0.99240386</span>], &#125;, <span class="comment">// A</span></span><br><span class="line">    Vertex &#123; position: [-<span class="number">0.49513406</span>, <span class="number">0.06958647</span>, <span class="number">0.0</span>], tex_coords: [<span class="number">0.0048659444</span>, <span class="number">0.56958646</span>], &#125;, <span class="comment">// B</span></span><br><span class="line">    Vertex &#123; position: [-<span class="number">0.21918549</span>, -<span class="number">0.44939706</span>, <span class="number">0.0</span>], tex_coords: [<span class="number">0.28081453</span>, <span class="number">0.050602943</span>], &#125;, <span class="comment">// C</span></span><br><span class="line">    Vertex &#123; position: [<span class="number">0.35966998</span>, -<span class="number">0.3473291</span>, <span class="number">0.0</span>], tex_coords: [<span class="number">0.85967</span>, <span class="number">0.15267089</span>], &#125;, <span class="comment">// D</span></span><br><span class="line">    Vertex &#123; position: [<span class="number">0.44147372</span>, <span class="number">0.2347359</span>, <span class="number">0.0</span>], tex_coords: [<span class="number">0.9414737</span>, <span class="number">0.7347359</span>], &#125;, <span class="comment">// E</span></span><br><span class="line">];</span><br></pre></td></tr></table></figure>

<h1 id="Shader-time"><a href="#Shader-time" class="headerlink" title="Shader time"></a>Shader time</h1><p>With our new Vertex structure in place it’s time to update our shaders. We’ll first need to pass our tex_coords into the vertex shader and then use them over to our fragment shader to get the final color from the Sampler. Let’s start with the vertex shader:</p>
<p>随着新顶点结构的就位，是时候更新着色器了。我们首先需要将tex_coords传递到顶点着色器，然后将它们传递到片段着色器，以从采样器获得最终颜色。让我们从顶点着色器开始：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Vertex shader</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">VertexInput</span></span> &#123;</span><br><span class="line">    [[location(<span class="number">0</span>)]] position: vec3&lt;<span class="built_in">f32</span>&gt;;</span><br><span class="line">    [[location(<span class="number">1</span>)]] tex_coords: vec2&lt;<span class="built_in">f32</span>&gt;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">VertexOutput</span></span> &#123;</span><br><span class="line">    [[builtin(position)]] clip_position: vec4&lt;<span class="built_in">f32</span>&gt;;</span><br><span class="line">    [[location(<span class="number">0</span>)]] tex_coords: vec2&lt;<span class="built_in">f32</span>&gt;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">[[stage(vertex)]]</span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>(</span><br><span class="line">    model: VertexInput,</span><br><span class="line">) -&gt; VertexOutput &#123;</span><br><span class="line">    var out: VertexOutput;</span><br><span class="line">    out.tex_coords = model.tex_coords;</span><br><span class="line">    out.clip_position = vec4&lt;<span class="built_in">f32</span>&gt;(model.position, <span class="number">1.0</span>);</span><br><span class="line">    <span class="keyword">return</span> out;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Now that we have our vertex shader outputting our tex_coords, we need to change the fragment shader to take them in. With these coordinates, we’ll finally be able to use our sampler to get a color from our texture.</p>
<p>现在我们已经有了顶点着色器输出tex_coords，我们需要更改片段着色器以接收它们。有了这些坐标，我们最终可以使用采样器从纹理中获取颜色。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Fragment shader</span></span><br><span class="line"></span><br><span class="line">[[group(<span class="number">0</span>), binding(<span class="number">0</span>)]]</span><br><span class="line">var t_diffuse: texture_2d&lt;<span class="built_in">f32</span>&gt;;</span><br><span class="line">[[group(<span class="number">0</span>), binding(<span class="number">1</span>)]]</span><br><span class="line">var s_diffuse: sampler;</span><br><span class="line"></span><br><span class="line">[[stage(fragment)]]</span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>(<span class="keyword">in</span>: VertexOutput) -&gt; [[location(<span class="number">0</span>)]] vec4&lt;<span class="built_in">f32</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> textureSample(t_diffuse, s_diffuse, <span class="keyword">in</span>.tex_coords);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>The variables t_diffuse and s_diffuse are what’s known as uniforms. We’ll go over uniforms more in the cameras section. For now, all we need to know is that group() corresponds to the 1st parameter in set_bind_group() and binding() relates to the binding specified when we created the BindGroupLayout and BindGroup.</p>
<p>变量t_diffuse和s_diffuse称为uniforms。我们将在照相机部分详细介绍uniforms。现在，我们只需要知道group()对应于set_bind_group()中的第一个参数，binding()与创建BindGroupLayout和BindGroup时指定的绑定相关。</p>
<h1 id="The-results"><a href="#The-results" class="headerlink" title="The results"></a>The results</h1><p>If we run our program now we should get the following result:</p>
<p><img src="https://sotrh.github.io/learn-wgpu/assets/img/upside-down.d50c3643.png" alt="result"></p>
<p>That’s weird, our tree is upside down! This is because wgpu’s world coordinates have the y-axis pointing up, while texture coordinates have the y-axis pointing down. In other words, (0, 0) in texture coordinates coresponds to the top-left of the image, while (1, 1) is the bottom right.</p>
<p>真奇怪，我们的树倒了！这是因为wgpu的世界坐标的y轴指向上，而纹理坐标的y轴指向下。换句话说，纹理坐标中的（0，0）对应于图像的左上角，而（1，1）对应于右下角。</p>
<p><img src="https://sotrh.github.io/learn-wgpu/assets/img/happy-tree-uv-coords.aa3b7d36.png" alt="纹理"></p>
<p>We can get our triangle right-side up by inverting the y coordinate of each texture coordinate:</p>
<p>通过反转每个纹理坐标的y坐标，我们可以使三角形正面朝上：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> VERTICES: &amp;[Vertex] = &amp;[</span><br><span class="line">    <span class="comment">// Changed</span></span><br><span class="line">    Vertex &#123; position: [-<span class="number">0.0868241</span>, <span class="number">0.49240386</span>, <span class="number">0.0</span>], tex_coords: [<span class="number">0.4131759</span>, <span class="number">0.00759614</span>], &#125;, <span class="comment">// A</span></span><br><span class="line">    Vertex &#123; position: [-<span class="number">0.49513406</span>, <span class="number">0.06958647</span>, <span class="number">0.0</span>], tex_coords: [<span class="number">0.0048659444</span>, <span class="number">0.43041354</span>], &#125;, <span class="comment">// B</span></span><br><span class="line">    Vertex &#123; position: [-<span class="number">0.21918549</span>, -<span class="number">0.44939706</span>, <span class="number">0.0</span>], tex_coords: [<span class="number">0.28081453</span>, <span class="number">0.949397</span>], &#125;, <span class="comment">// C</span></span><br><span class="line">    Vertex &#123; position: [<span class="number">0.35966998</span>, -<span class="number">0.3473291</span>, <span class="number">0.0</span>], tex_coords: [<span class="number">0.85967</span>, <span class="number">0.84732914</span>], &#125;, <span class="comment">// D</span></span><br><span class="line">    Vertex &#123; position: [<span class="number">0.44147372</span>, <span class="number">0.2347359</span>, <span class="number">0.0</span>], tex_coords: [<span class="number">0.9414737</span>, <span class="number">0.2652641</span>], &#125;, <span class="comment">// E</span></span><br><span class="line">];</span><br></pre></td></tr></table></figure>

<p>With that in place, we now have our tree right-side up on our hexagon:</p>
<p>有了它，我们的树就在六边形的正确位置：</p>
<p><img src="https://sotrh.github.io/learn-wgpu/assets/img/rightside-up.75f852e2.png" alt="纹理"></p>
<h1 id="Cleaning-things-up"><a href="#Cleaning-things-up" class="headerlink" title="Cleaning things up"></a>Cleaning things up</h1><p>For convenience sake, let’s pull our texture code into its module. We’ll first need to add the anyhow crate to our Cargo.toml file to simplify error handling;</p>
<p>为了方便起见，让我们将纹理代码拉入其模块。我们首先需要将anyhow crate添加到Cargo.toml文件中，以简化错误处理；</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[dependencies]</span><br><span class="line">image = <span class="string">&quot;0.23&quot;</span></span><br><span class="line">cgmath = <span class="string">&quot;0.18&quot;</span></span><br><span class="line">winit = <span class="string">&quot;0.25&quot;</span></span><br><span class="line">env_logger = <span class="string">&quot;0.9&quot;</span></span><br><span class="line">log = <span class="string">&quot;0.4&quot;</span></span><br><span class="line">pollster = <span class="string">&quot;0.2&quot;</span></span><br><span class="line">wgpu = <span class="string">&quot;0.9&quot;</span></span><br><span class="line">bytemuck = &#123; version = <span class="string">&quot;1.4&quot;</span>, features = [ <span class="string">&quot;derive&quot;</span> ] &#125;</span><br><span class="line">anyhow = <span class="string">&quot;1.0&quot;</span> <span class="comment">// NEW!</span></span><br></pre></td></tr></table></figure>

<p>Then, in a new file called src/texture.rs, add the following:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> image::GenericImageView;</span><br><span class="line"><span class="keyword">use</span> anyhow::*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">Texture</span></span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> texture: wgpu::Texture,</span><br><span class="line">    <span class="keyword">pub</span> view: wgpu::TextureView,</span><br><span class="line">    <span class="keyword">pub</span> sampler: wgpu::Sampler,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> Texture &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">from_bytes</span></span>(</span><br><span class="line">        device: &amp;wgpu::Device,</span><br><span class="line">        queue: &amp;wgpu::Queue,</span><br><span class="line">        bytes: &amp;[<span class="built_in">u8</span>], </span><br><span class="line">        label: &amp;<span class="built_in">str</span></span><br><span class="line">    ) -&gt; <span class="built_in">Result</span>&lt;<span class="keyword">Self</span>&gt; &#123;</span><br><span class="line">        <span class="keyword">let</span> img = image::load_from_memory(bytes)?;</span><br><span class="line">        Self::from_image(device, queue, &amp;img, <span class="literal">Some</span>(label))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">from_image</span></span>(</span><br><span class="line">        device: &amp;wgpu::Device,</span><br><span class="line">        queue: &amp;wgpu::Queue,</span><br><span class="line">        img: &amp;image::DynamicImage,</span><br><span class="line">        label: <span class="built_in">Option</span>&lt;&amp;<span class="built_in">str</span>&gt;</span><br><span class="line">    ) -&gt; <span class="built_in">Result</span>&lt;<span class="keyword">Self</span>&gt; &#123;</span><br><span class="line">        <span class="keyword">let</span> rgba = img.as_rgba8().unwrap();</span><br><span class="line">        <span class="keyword">let</span> dimensions = img.dimensions();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> size = wgpu::Extent3d &#123;</span><br><span class="line">            width: dimensions.<span class="number">0</span>,</span><br><span class="line">            height: dimensions.<span class="number">1</span>,</span><br><span class="line">            depth_or_array_layers: <span class="number">1</span>,</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">let</span> texture = device.create_texture(</span><br><span class="line">            &amp;wgpu::TextureDescriptor &#123;</span><br><span class="line">                label,</span><br><span class="line">                size,</span><br><span class="line">                mip_level_count: <span class="number">1</span>,</span><br><span class="line">                sample_count: <span class="number">1</span>,</span><br><span class="line">                dimension: wgpu::TextureDimension::D2,</span><br><span class="line">                format: wgpu::TextureFormat::Rgba8UnormSrgb,</span><br><span class="line">                usage: wgpu::TextureUsage::SAMPLED | wgpu::TextureUsage::COPY_DST,</span><br><span class="line">            &#125;</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        queue.write_texture(</span><br><span class="line">            wgpu::ImageCopyTexture &#123;</span><br><span class="line">                texture: &amp;texture,</span><br><span class="line">                mip_level: <span class="number">0</span>,</span><br><span class="line">                origin: wgpu::Origin3d::ZERO,</span><br><span class="line">            &#125;,</span><br><span class="line">            rgba,</span><br><span class="line">            wgpu::ImageDataLayout &#123;</span><br><span class="line">                offset: <span class="number">0</span>,</span><br><span class="line">                bytes_per_row: std::num::NonZeroU32::new(<span class="number">4</span> * dimensions.<span class="number">0</span>),</span><br><span class="line">                rows_per_image: std::num::NonZeroU32::new(dimensions.<span class="number">1</span>),</span><br><span class="line">            &#125;,</span><br><span class="line">            size,</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> view = texture.create_view(&amp;wgpu::TextureViewDescriptor::default());</span><br><span class="line">        <span class="keyword">let</span> sampler = device.create_sampler(</span><br><span class="line">            &amp;wgpu::SamplerDescriptor &#123;</span><br><span class="line">                address_mode_u: wgpu::AddressMode::ClampToEdge,</span><br><span class="line">                address_mode_v: wgpu::AddressMode::ClampToEdge,</span><br><span class="line">                address_mode_w: wgpu::AddressMode::ClampToEdge,</span><br><span class="line">                mag_filter: wgpu::FilterMode::Linear,</span><br><span class="line">                min_filter: wgpu::FilterMode::Nearest,</span><br><span class="line">                mipmap_filter: wgpu::FilterMode::Nearest,</span><br><span class="line">                ..<span class="built_in">Default</span>::default()</span><br><span class="line">            &#125;</span><br><span class="line">        );</span><br><span class="line">        </span><br><span class="line">        <span class="literal">Ok</span>(<span class="keyword">Self</span> &#123; texture, view, sampler &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Note that we’re returning a CommandBuffer with our texture. This means we can load multiple textures at the same time, and then submit all their command buffers at once.</p>
<p>请注意，我们返回CommandBuffer使用纹理。这意味着我们可以同时加载多个纹理，然后一次提交它们的所有命令缓冲区。</p>
<p>We need to import texture.rs as a module, so somewhere at the top of main.rs add the following.</p>
<p>我们需要将texture.rs作为一个模块导入，因此在main.rs顶部的某处添加以下内容。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mod</span> texture;</span><br></pre></td></tr></table></figure>

<p>The texture creation code in new() now gets a lot simpler:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> swap_chain = device.create_swap_chain(&amp;surface, &amp;sc_desc);</span><br><span class="line"><span class="keyword">let</span> diffuse_bytes = include_bytes!(<span class="string">&quot;happy-tree.png&quot;</span>); <span class="comment">// CHANGED!</span></span><br><span class="line"><span class="keyword">let</span> diffuse_texture = texture::Texture::from_bytes(&amp;device, &amp;queue, diffuse_bytes, <span class="string">&quot;happy-tree.png&quot;</span>).unwrap(); <span class="comment">// CHANGED!</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Everything up until `let texture_bind_group_layout = ...` can now be removed.</span></span><br></pre></td></tr></table></figure>

<p>We still need to store the bind group separately so that Texture doesn’t need know how the BindGroup is laid out. Creating the diffuse_bind_group changes slightly to use the view and sampler fields of our diffuse_texture:</p>
<p>我们仍然需要单独存储bind group，这样纹理就不需要知道BindGroup是如何布置的。创建diffuse_bind_group时会稍微更改，以使用diffuse_texture的view和sampler字段：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> diffuse_bind_group = device.create_bind_group(</span><br><span class="line">    &amp;wgpu::BindGroupDescriptor &#123;</span><br><span class="line">        layout: &amp;texture_bind_group_layout,</span><br><span class="line">        entries: &amp;[</span><br><span class="line">            wgpu::BindGroupEntry &#123;</span><br><span class="line">                binding: <span class="number">0</span>,</span><br><span class="line">                resource: wgpu::BindingResource::TextureView(&amp;diffuse_texture.view), <span class="comment">// CHANGED!</span></span><br><span class="line">            &#125;,</span><br><span class="line">            wgpu::BindGroupEntry &#123;</span><br><span class="line">                binding: <span class="number">1</span>,</span><br><span class="line">                resource: wgpu::BindingResource::Sampler(&amp;diffuse_texture.sampler), <span class="comment">// CHANGED!</span></span><br><span class="line">            &#125;</span><br><span class="line">        ],</span><br><span class="line">        label: <span class="literal">Some</span>(<span class="string">&quot;diffuse_bind_group&quot;</span>),</span><br><span class="line">    &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>Finally, let’s update our State field to use our shiny new Texture struct, as we’ll need it in future tutorials.</p>
<p>最后，让我们更新State字段以使用闪亮的新纹理结构，因为我们将在未来的教程中需要它。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">State</span></span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    diffuse_bind_group: wgpu::BindGroup,</span><br><span class="line">    diffuse_texture: texture::Texture, <span class="comment">// NEW</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span> State &#123;</span><br><span class="line">    <span class="keyword">async</span> <span class="function"><span class="keyword">fn</span> <span class="title">new</span></span>() -&gt; <span class="keyword">Self</span> &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="keyword">Self</span> &#123;</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">            num_indices,</span><br><span class="line">            diffuse_bind_group,</span><br><span class="line">            diffuse_texture, <span class="comment">// NEW</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Phew!</p>
<p>With these changes in place, the code should be working the same as it was before, but we now have a much easier way to create textures.</p>
<p>有了这些更改，代码应该和以前一样工作，但是我们现在有了一种更简单的方法来创建纹理。</p>
<h1 id="Challenge"><a href="#Challenge" class="headerlink" title="Challenge"></a>Challenge</h1><p>创建另一个纹理，并在按空格键时将其调出。</p>
<p><a target="_blank" rel="noopener" href="https://github.com/sotrh/learn-wgpu/tree/master/code/beginner/tutorial5-textures/">Check out the code!</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://qianqians.github.io/2021/08/24/Wgpu%20Buffers%20and%20Indices/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="qianqians">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="qianqians'blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/08/24/Wgpu%20Buffers%20and%20Indices/" class="post-title-link" itemprop="url">Wgpu Buffers and Indices</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-08-24 14:46:40" itemprop="dateCreated datePublished" datetime="2021-08-24T14:46:40+08:00">2021-08-24</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-09-15 16:51:26" itemprop="dateModified" datetime="2021-09-15T16:51:26+08:00">2021-09-15</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Wgpu/" itemprop="url" rel="index"><span itemprop="name">Wgpu</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="We’re-finally-talking-about-them"><a href="#We’re-finally-talking-about-them" class="headerlink" title="We’re finally talking about them!"></a>We’re finally talking about them!</h1><p>You were probably getting sick of me saying stuff like “we’ll get to that when we talk about buffers”. Well now’s the time to finally talk about buffers, but first…</p>
<p>你可能已经厌倦了我说的那些话，比如”当我们谈论缓冲区的时候，我们会说到那个”。现在是时候讨论缓冲区了，但是首先。。。</p>
<h1 id="What-is-a-buffer"><a href="#What-is-a-buffer" class="headerlink" title="What is a buffer?"></a>What is a buffer?</h1><p>A buffer is a blob of data on the GPU. A buffer is guaranteed to be contiguous, meaning that all the data is stored sequentially in memory. Buffers are generally used to store simple things like structs or arrays, but it can store more complex stuff such as graph structures like trees (provided all the nodes are stored together and don’t reference anything outside of the buffer). We are going to use buffers a lot, so let’s get started with two of the most important ones: the vertex buffer, and the index buffer.</p>
<p>缓冲区是GPU上的一团数据。缓冲区保证是连续的，这意味着所有数据都按顺序存储在内存中。缓冲区通常用于存储简单的东西，如结构或数组，但它可以存储更复杂的东西，如树等图形结构（前提是所有节点都存储在一起，并且不引用缓冲区之外的任何内容）。我们将大量使用缓冲区，因此让我们从两个最重要的缓冲区开始：顶点缓冲区和索引缓冲区。</p>
<h1 id="The-vertex-buffer"><a href="#The-vertex-buffer" class="headerlink" title="The vertex buffer"></a>The vertex buffer</h1><p>Previously we’ve stored vertex data directly in the vertex shader. While that worked fine to get our bootstraps on, it simply won’t do for the long-term. The types of objects we need to draw will vary in size, and recompiling the shader whenever we need to update the model would massively slow down our program. Instead we are going to use buffers to store the vertex data we want to draw. Before we do that though we need to describe what a vertex looks like. We’ll do this by creating a new struct.</p>
<p>之前，我们将顶点数据直接存储在顶点着色器中。虽然这样做可以很好地启动我们的引导系统，但从长远来看，这样做是行不通的。我们需要绘制的对象类型在大小上会有所不同，每当我们需要更新模型时重新编译着色器将大大降低我们的程序速度。相反，我们将使用缓冲区来存储要绘制的顶点数据。在我们这样做之前，我们需要描述一个顶点是什么样子的。我们将通过创建一个新的结构来实现这一点。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main.rs</span></span><br><span class="line"><span class="meta">#[repr(C)]</span></span><br><span class="line"><span class="meta">#[derive(Copy, Clone, Debug)]</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Vertex</span></span> &#123;</span><br><span class="line">    position: [<span class="built_in">f32</span>; <span class="number">3</span>],</span><br><span class="line">    color: [<span class="built_in">f32</span>; <span class="number">3</span>],</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Our vertices will all have a position and a color. The position represents the x, y, and z of the vertex in 3d space. The color is the red, green, and blue values for the vertex. We need the Vertex to be copyable so we can create a buffer with it.</p>
<p>我们的顶点都有一个位置和颜色。该位置表示三维空间中顶点的x、y和z。颜色是顶点的红色、绿色和蓝色值。我们需要顶点是可复制的，这样我们就可以用它创建一个缓冲区。</p>
<p>Next we need the actual data that will make up our triangle. Below Vertex add the following.</p>
<p>接下来，我们需要组成三角形的实际数据。在顶点下方添加以下内容。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//main.rs</span></span><br><span class="line"><span class="keyword">const</span> VERTICES: &amp;[Vertex] = &amp;[</span><br><span class="line">    Vertex &#123; position: [<span class="number">0.0</span>, <span class="number">0.5</span>, <span class="number">0.0</span>], color: [<span class="number">1.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>] &#125;,</span><br><span class="line">    Vertex &#123; position: [-<span class="number">0.5</span>, -<span class="number">0.5</span>, <span class="number">0.0</span>], color: [<span class="number">0.0</span>, <span class="number">1.0</span>, <span class="number">0.0</span>] &#125;,</span><br><span class="line">    Vertex &#123; position: [<span class="number">0.5</span>, -<span class="number">0.5</span>, <span class="number">0.0</span>], color: [<span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">1.0</span>] &#125;,</span><br><span class="line">];</span><br></pre></td></tr></table></figure>

<p>We arrange the vertices in counter clockwise order: top, bottom left, bottom right. We do it this way partially out of tradition, but mostly because we specified in the rasterization_state of the render_pipeline that we want the front_face of our triangle to be wgpu::FrontFace::Ccw so that we cull the back face. This means that any triangle that should be facing us should have its vertices in counter clockwise order.</p>
<p>我们按逆时针顺序排列顶点：顶部、左下角、右下角。我们这样做部分是出于传统，但主要是因为我们在渲染管道的光栅化状态中指定，我们希望三角形的前表面为wgpu::FrontFace::Ccw，以便剔除后表面。这意味着任何面向我们的三角形的顶点都应该按逆时针顺序排列。</p>
<p>Now that we have our vertex data, we need to store it in a buffer. Let’s add a vertex_buffer field to State.</p>
<p>现在我们有了顶点数据，我们需要将其存储在缓冲区中。让我们向State添加一个顶点vertex_buffer字段。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main.rs</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">State</span></span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    render_pipeline: wgpu::RenderPipeline,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// NEW!</span></span><br><span class="line">    vertex_buffer: wgpu::Buffer,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Now let’s create the buffer in new().</p>
<p>现在让我们在new()中创建缓冲区。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// new()</span></span><br><span class="line"><span class="keyword">let</span> vertex_buffer = device.create_buffer_init(</span><br><span class="line">    &amp;wgpu::util::BufferInitDescriptor &#123;</span><br><span class="line">        label: <span class="literal">Some</span>(<span class="string">&quot;Vertex Buffer&quot;</span>),</span><br><span class="line">        contents: bytemuck::cast_slice(VERTICES),</span><br><span class="line">        usage: wgpu::BufferUsage::VERTEX,</span><br><span class="line">    &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>To access the create_buffer_init method on wgpu::Device we’ll have to import the DeviceExt extension trait. For more information on extension traits, check out this article.</p>
<p>要访问wgpu::Device上的create_buffer_init方法，我们必须导入DeviceExt扩展特性。有关扩展特性的更多信息，请参阅本文。</p>
<p>To import the extension trait, this line somewhere near the top of main.rs.</p>
<p>要导入扩展特性，请在main.rs顶部附近的某个位置输入如下代码。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> wgpu::util::DeviceExt;</span><br></pre></td></tr></table></figure>

<p>You’ll note that we’re using bytemuck to cast our VERTICES as a &amp;[u8]. The create_buffer_init() method expects a &amp;[u8], and bytemuck::cast_slice does that for us. Add the following to your Cargo.toml.</p>
<p>您会注意到，我们使用bytemuck将顶点转换为&amp;[u8]。create_buffer_init()方法需要一个&amp;[u8]，而bytemuck::cast_slice则为我们这样做。将以下内容添加到Cargo.toml中。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bytemuck = &#123; version = <span class="string">&quot;1.4&quot;</span>, features = [ <span class="string">&quot;derive&quot;</span> ] &#125;</span><br></pre></td></tr></table></figure>

<p>We’re also going to need to implement two traits to get bytemuck to work. These are bytemuck::Pod and bytemuck::Zeroable. Pod indicates that our Vertex is “Plain Old Data”, and thus can be interpretted as a &amp;[u8]. Zeroable indicates that we can use std::mem::zeroed(). We can modify our Vertex struct to derive these methods.</p>
<p>为了让bytemuck发挥作用，我们还需要实现两个特性。它们是bytemuck::Pod和bytemuck::Zeroable。Pod表示我们的顶点是“普通的旧数据”，因此可以解释为a&amp;[u8]。Zeroable表示我们可以使用std::mem::zeroed()。我们可以修改顶点结构来派生这些方法。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[repr(C)]</span></span><br><span class="line"><span class="meta">#[derive(Copy, Clone, Debug, bytemuck::Pod, bytemuck::Zeroable)]</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Vertex</span></span> &#123;</span><br><span class="line">    position: [<span class="built_in">f32</span>; <span class="number">3</span>],</span><br><span class="line">    color: [<span class="built_in">f32</span>; <span class="number">3</span>],</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<div class="note">

<p>If your struct includes types that don’t implement Pod and Zeroable, you’ll need to implement these traits manually. These traits don’t require us to implement any methods, so we just need to use the following to get our code to work.</p>
<p>如果您的结构包含未实现Pod和Zeroable的类型，则需要手动实现这些特性。这些特性不需要我们实现任何方法，所以我们只需要使用以下方法来让代码正常工作。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unsafe</span> <span class="keyword">impl</span> bytemuck::Pod <span class="keyword">for</span> Vertex &#123;&#125;</span><br><span class="line"><span class="keyword">unsafe</span> <span class="keyword">impl</span> bytemuck::Zeroable <span class="keyword">for</span> Vertex &#123;&#125;</span><br></pre></td></tr></table></figure>

</div>

<p>Finally we can add our vertex_buffer to our State struct.</p>
<p>最后，我们可以将顶点缓冲区添加到结构体State中。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Self</span> &#123;</span><br><span class="line">    surface,</span><br><span class="line">    device,</span><br><span class="line">    queue,</span><br><span class="line">    sc_desc,</span><br><span class="line">    swap_chain,</span><br><span class="line">    size,</span><br><span class="line">    render_pipeline,</span><br><span class="line">    vertex_buffer,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="So-what-do-I-do-with-it"><a href="#So-what-do-I-do-with-it" class="headerlink" title="So what do I do with it?"></a>So what do I do with it?</h1><p>We need to tell the render_pipeline to use this buffer when we are drawing, but first we need to tell the render_pipeline how to read the buffer. We do this using VertexBufferLayouts and the vertex_buffers field that I promised we’d talk about when we created the render_pipeline.</p>
<p>我们需要告诉render_pipeline在绘图时使用此缓冲区，但首先我们需要告诉render_pipeline如何读取缓冲区。我们使用VertexBufferLayouts和vertex_buffers字段来实现这一点，我在创建render_pipeline时承诺过要讨论这个字段。</p>
<p>A VertexBufferLayout defines how a buffer is layed out in memory. Without this, the render_pipeline has no idea how to map the buffer in the shader. Here’s what the descriptor for a buffer full of Vertex would look like.</p>
<p>VertexBufferLayout定义缓冲区在内存中的布局方式。如果没有此选项，渲染管道将不知道如何映射着色器中的缓冲区。下面是一个充满顶点的缓冲区的描述符。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">wgpu::VertexBufferLayout &#123;</span><br><span class="line">    array_stride: std::mem::size_of::&lt;Vertex&gt;() <span class="keyword">as</span> wgpu::BufferAddress, <span class="comment">// 1.</span></span><br><span class="line">    step_mode: wgpu::InputStepMode::Vertex, <span class="comment">// 2.</span></span><br><span class="line">    attributes: &amp;[ <span class="comment">// 3.</span></span><br><span class="line">        wgpu::VertexAttribute &#123;</span><br><span class="line">            offset: <span class="number">0</span>, <span class="comment">// 4.</span></span><br><span class="line">            shader_location: <span class="number">0</span>, <span class="comment">// 5.</span></span><br><span class="line">            format: wgpu::VertexFormat::Float32x3, <span class="comment">// 6.</span></span><br><span class="line">        &#125;,</span><br><span class="line">        wgpu::VertexAttribute &#123;</span><br><span class="line">            offset: std::mem::size_of::&lt;[<span class="built_in">f32</span>; <span class="number">3</span>]&gt;() <span class="keyword">as</span> wgpu::BufferAddress,</span><br><span class="line">            shader_location: <span class="number">1</span>,</span><br><span class="line">            format: wgpu::VertexFormat::Float32x3,</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>The array_stride defines how wide a vertex is. When the shader goes to read the next vertex, it will skip over array_stride number of bytes. In our case, array_stride will probably be 24 bytes.</li>
<li>step_mode tells the pipeline how often it should move to the next vertex. This seems redundant in our case, but we can specify wgpu::InputStepMode::Instance if we only want to change vertices when we start drawing a new instance. We’ll cover instancing in a later tutorial.</li>
<li>Vertex attributes describe the individual parts of the vertex. Generally this is a 1:1 mapping with a struct’s fields, which it is in our case.</li>
<li>This defines the offset in bytes that this attribute starts. The first attribute is usually zero, and any future attributes are the collective size_of the previous attributes data.</li>
<li>This tells the shader what location to store this attribute at. For example layout(location=0) in vec3 x in the vertex shader would correspond to the position field of the struct, while layout(location=1) in vec3 x would be the color field.</li>
<li>format tells the shader the shape of the attribute. Float3 corresponds to vec3 in shader code. The max value we can store in an attribute is Float4 (Uint4, and Int4 work as well). We’ll keep this in mind for when we have to store things that are bigger than Float4.</li>
</ol>
<div></div>

<ol>
<li>array_stride定义顶点的宽度。当着色器读取下一个顶点时，它将跳过数组的字节数。在我们的例子中，数组的步长可能是24字节。</li>
<li>step_mode告诉管道它应该移动到下一个顶点的频率。在我们的例子中，这似乎是多余的，但如果我们只想在开始绘制新实例时更改顶点，则可以指定wgpu::InputStepMode::Instance。我们将在后面的教程中介绍实例化。</li>
<li>顶点属性描述顶点的各个部分。通常，这是一个1:1映射，带有结构的字段，在我们的例子中就是这样。</li>
<li>这定义了该属性开始的偏移量（以字节为单位）。第一个属性通常为零，任何未来属性都是前一个属性数据的集合大小。</li>
<li>这将告知着色器存储此属性的位置。例如，顶点着色器中vec3 x中的布局（位置=0）将对应于结构的位置字段，而vec3 x中的布局（位置=1）将对应于颜色字段。</li>
<li>format告诉着色器属性的布局。Float3对应于着色器代码中的vec3。我们可以存储在属性中的最大值是Float4（Uint4和Int4也可以使用）。当我们必须存储比Float4大的东西时，我们会注意这一点。</li>
</ol>
<p>For you visually learners, our vertex buffer looks like this.</p>
<p>对于您来说，我们的顶点缓冲区如下所示。</p>
<p><img src="https://sotrh.github.io/learn-wgpu/assets/img/vb_desc.63afb652.png" alt="顶点缓冲区"></p>
<p>Let’s create a static method on Vertex that returns this descriptor.</p>
<p>让我们在顶点上创建一个静态方法，返回这个描述符。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main.rs</span></span><br><span class="line"><span class="keyword">impl</span> Vertex &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">desc</span></span>&lt;<span class="symbol">&#x27;a</span>&gt;() -&gt; wgpu::VertexBufferLayout&lt;<span class="symbol">&#x27;a</span>&gt; &#123;</span><br><span class="line">        wgpu::VertexBufferLayout &#123;</span><br><span class="line">            array_stride: std::mem::size_of::&lt;Vertex&gt;() <span class="keyword">as</span> wgpu::BufferAddress,</span><br><span class="line">            step_mode: wgpu::InputStepMode::Vertex,</span><br><span class="line">            attributes: &amp;[</span><br><span class="line">                wgpu::VertexAttribute &#123;</span><br><span class="line">                    offset: <span class="number">0</span>,</span><br><span class="line">                    shader_location: <span class="number">0</span>,</span><br><span class="line">                    format: wgpu::VertexFormat::Float32x3,</span><br><span class="line">                &#125;,</span><br><span class="line">                wgpu::VertexAttribute &#123;</span><br><span class="line">                    offset: std::mem::size_of::&lt;[<span class="built_in">f32</span>; <span class="number">3</span>]&gt;() <span class="keyword">as</span> wgpu::BufferAddress,</span><br><span class="line">                    shader_location: <span class="number">1</span>,</span><br><span class="line">                    format: wgpu::VertexFormat::Float32x3,</span><br><span class="line">                &#125;</span><br><span class="line">            ]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<div class="note">

<p>Specifying the attributes as we did now is quite verbose. We could use the vertex_attr_array macro provided by wgpu to clean things up a bit. With it our VertexBufferLayout becomes</p>
<p>像我们现在这样指定属性是相当冗长的。我们可以使用wgpu提供的vertex_attr_array宏稍微清理一下。有了它，我们的VertexBuffer布局变得</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">wgpu::VertexBufferLayout &#123;</span><br><span class="line">    array_stride: std::mem::size_of::&lt;Vertex&gt;() <span class="keyword">as</span> wgpu::BufferAddress,</span><br><span class="line">    step_mode: wgpu::InputStepMode::Vertex,</span><br><span class="line">    attributes: &amp;wgpu::vertex_attr_array![<span class="number">0</span> =&gt; Float32x3, <span class="number">1</span> =&gt; Float32x3],</span><br><span class="line">&#125;   </span><br></pre></td></tr></table></figure>

<p>While this is definitely nice, we would have to change the lifetime on wgpu::VertexBufferLayout to ‘static as rust wouldn’t compile the code because the result of vertex_attr_array is a temporary value, which we can’t return from a function.</p>
<p>虽然这确实很好，但我们必须将wgpu::VertexBufferLayout上的生存期更改为“静态”，因为rust不会编译代码，因为vertex_attr_array数组的结果是一个临时值，我们无法从函数返回。</p>
<p>Beyond that, I feel it’s good to show how the data gets mapped, so I’ll forgo using this macro for now.</p>
<p>除此之外，我觉得展示数据是如何映射的很好，所以我现在放弃使用这个宏。</p>
</div>

<p>Now we can use it when we create the render_pipeline.</p>
<p>现在，我们可以在创建render_pipeline时使用它。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> render_pipeline = device.create_render_pipeline(&amp;wgpu::RenderPipelineDescriptor &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    vertex: wgpu::VertexState &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        buffers: &amp;[</span><br><span class="line">            Vertex::desc(),</span><br><span class="line">        ],</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>One more thing: we need to actually set the vertex buffer in the render method otherwise our program will crash.</p>
<p>还有一件事：我们需要在渲染方法中实际设置顶点缓冲区，否则我们的程序将崩溃。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// render()</span></span><br><span class="line">render_pass.set_pipeline(&amp;<span class="keyword">self</span>.render_pipeline);</span><br><span class="line"><span class="comment">// NEW!</span></span><br><span class="line">render_pass.set_vertex_buffer(<span class="number">0</span>, <span class="keyword">self</span>.vertex_buffer.slice(..));</span><br><span class="line">render_pass.draw(<span class="number">0</span>..<span class="number">3</span>, <span class="number">0</span>..<span class="number">1</span>);</span><br></pre></td></tr></table></figure>

<p>set_vertex_buffer takes two parameters. The first is what buffer slot to use for this vertex buffer. You can have multiple vertex buffers set at a time.</p>
<p>set_vertex_buffer采用两个参数。第一个是用于此顶点缓冲区的缓冲槽。一次可以设置多个顶点缓冲区。</p>
<p>The second parameter is the slice of the buffer to use. You can store as many objects in a buffer as your hardware allows, so slice allows us to specify which portion of the buffer to use. We use .. to specify the entire buffer.</p>
<p>第二个参数是要使用的缓冲区的切片。在硬件允许的情况下，可以在缓冲区中存储任意多的对象，因此slice允许我们指定要使用的缓冲区部分。我们用..指定整个缓冲区。</p>
<p>Before we continue, we should change the render_pass.draw() call to use the number of vertices specified by VERTICES. Add a num_vertices to State, and set it to be equal to VERTICES.len().</p>
<p>在继续之前，我们应该更改render_pass.draw()调用以使用顶点指定的顶点数。将num_vertices添加到状态，并将其设置为等于VERTICES.len()。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main.rs</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">State</span></span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    num_vertices: <span class="built_in">u32</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> State &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">new</span></span>(...) -&gt; <span class="keyword">Self</span> &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="keyword">let</span> num_vertices = VERTICES.len() <span class="keyword">as</span> <span class="built_in">u32</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">Self</span> &#123;</span><br><span class="line">            surface,</span><br><span class="line">            device,</span><br><span class="line">            queue,</span><br><span class="line">            sc_desc,</span><br><span class="line">            swap_chain,</span><br><span class="line">            render_pipeline,</span><br><span class="line">            vertex_buffer,</span><br><span class="line">            num_vertices,</span><br><span class="line">            size,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Then use it in the draw call.</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// render</span></span><br><span class="line">render_pass.draw(<span class="number">0</span>..<span class="keyword">self</span>.num_vertices, <span class="number">0</span>..<span class="number">1</span>);</span><br></pre></td></tr></table></figure>

<p>Before our changes will have any effect, we need to update our vertex shader to get its data from the vertex buffer. We’ll also have it include the vertex color as well.</p>
<p>在更改产生任何效果之前，我们需要更新顶点着色器以从顶点缓冲区获取其数据。我们还将让它包括顶点颜色。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Vertex shader</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">VertexInput</span></span> &#123;</span><br><span class="line">    [[location(<span class="number">0</span>)]] position: vec3&lt;<span class="built_in">f32</span>&gt;;</span><br><span class="line">    [[location(<span class="number">1</span>)]] color: vec3&lt;<span class="built_in">f32</span>&gt;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">VertexOutput</span></span> &#123;</span><br><span class="line">    [[builtin(position)]] clip_position: vec4&lt;<span class="built_in">f32</span>&gt;;</span><br><span class="line">    [[location(<span class="number">0</span>)]] color: vec3&lt;<span class="built_in">f32</span>&gt;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">[[stage(vertex)]]</span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>(</span><br><span class="line">    model: VertexInput,</span><br><span class="line">) -&gt; VertexOutput &#123;</span><br><span class="line">    var out: VertexOutput;</span><br><span class="line">    out.color = model.color;</span><br><span class="line">    out.clip_position = vec4&lt;<span class="built_in">f32</span>&gt;(model.position, <span class="number">1.0</span>);</span><br><span class="line">    <span class="keyword">return</span> out;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Fragment shader</span></span><br><span class="line"></span><br><span class="line">[[stage(fragment)]]</span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>(<span class="keyword">in</span>: VertexOutput) -&gt; [[location(<span class="number">0</span>)]] vec4&lt;<span class="built_in">f32</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> vec4&lt;<span class="built_in">f32</span>&gt;(<span class="keyword">in</span>.color, <span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>If you’ve done things correctly, you should see a triangle that looks something like this.</p>
<p>如果你做的正确，你应该看到一个三角形，看起来像这样。</p>
<p><img src="https://sotrh.github.io/learn-wgpu/assets/img/triangle.11560f32.png" alt="三角形"></p>
<h1 id="The-index-buffer"><a href="#The-index-buffer" class="headerlink" title="The index buffer"></a>The index buffer</h1><p>We technically don’t need an index buffer, but they still are plenty useful. An index buffer comes into play when we start using models with a lot of triangles. Consider this pentagon.</p>
<p>从技术上讲，我们不需要索引缓冲区，但它们仍然非常有用。当我们开始使用带有大量三角形的模型时，索引缓冲区就开始发挥作用。考虑一下这个五角大厦。</p>
<p><img src="https://sotrh.github.io/learn-wgpu/assets/img/pentagon.2c2be93b.png" alt="五角形"></p>
<p>It has a total of 5 vertices, and 3 triangles. Now if we wanted to display something like this using just vertices we would need something like the following.</p>
<p>它总共有5个顶点和3个三角形。现在，如果我们只想用顶点来显示这样的东西，我们需要下面这样的东西。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> VERTICES: &amp;[Vertex] = &amp;[</span><br><span class="line">    Vertex &#123; position: [-<span class="number">0.0868241</span>, <span class="number">0.49240386</span>, <span class="number">0.0</span>], color: [<span class="number">0.5</span>, <span class="number">0.0</span>, <span class="number">0.5</span>] &#125;, <span class="comment">// A</span></span><br><span class="line">    Vertex &#123; position: [-<span class="number">0.49513406</span>, <span class="number">0.06958647</span>, <span class="number">0.0</span>], color: [<span class="number">0.5</span>, <span class="number">0.0</span>, <span class="number">0.5</span>] &#125;, <span class="comment">// B</span></span><br><span class="line">    Vertex &#123; position: [<span class="number">0.44147372</span>, <span class="number">0.2347359</span>, <span class="number">0.0</span>], color: [<span class="number">0.5</span>, <span class="number">0.0</span>, <span class="number">0.5</span>] &#125;, <span class="comment">// E</span></span><br><span class="line"></span><br><span class="line">    Vertex &#123; position: [-<span class="number">0.49513406</span>, <span class="number">0.06958647</span>, <span class="number">0.0</span>], color: [<span class="number">0.5</span>, <span class="number">0.0</span>, <span class="number">0.5</span>] &#125;, <span class="comment">// B</span></span><br><span class="line">    Vertex &#123; position: [-<span class="number">0.21918549</span>, -<span class="number">0.44939706</span>, <span class="number">0.0</span>], color: [<span class="number">0.5</span>, <span class="number">0.0</span>, <span class="number">0.5</span>] &#125;, <span class="comment">// C</span></span><br><span class="line">    Vertex &#123; position: [<span class="number">0.44147372</span>, <span class="number">0.2347359</span>, <span class="number">0.0</span>], color: [<span class="number">0.5</span>, <span class="number">0.0</span>, <span class="number">0.5</span>] &#125;, <span class="comment">// E</span></span><br><span class="line"></span><br><span class="line">    Vertex &#123; position: [-<span class="number">0.21918549</span>, -<span class="number">0.44939706</span>, <span class="number">0.0</span>], color: [<span class="number">0.5</span>, <span class="number">0.0</span>, <span class="number">0.5</span>] &#125;, <span class="comment">// C</span></span><br><span class="line">    Vertex &#123; position: [<span class="number">0.35966998</span>, -<span class="number">0.3473291</span>, <span class="number">0.0</span>], color: [<span class="number">0.5</span>, <span class="number">0.0</span>, <span class="number">0.5</span>] &#125;, <span class="comment">// D</span></span><br><span class="line">    Vertex &#123; position: [<span class="number">0.44147372</span>, <span class="number">0.2347359</span>, <span class="number">0.0</span>], color: [<span class="number">0.5</span>, <span class="number">0.0</span>, <span class="number">0.5</span>] &#125;, <span class="comment">// E</span></span><br><span class="line">];</span><br></pre></td></tr></table></figure>

<p>You’ll note though that some of the vertices are used more than once. C, and B get used twice, and E is repeated 3 times. Assuming that each float is 4 bytes, then that means of the 216 bytes we use for VERTICES, 96 of them are duplicate data. Wouldn’t it be nice if we could list these vertices once? Well we can! That’s were an index buffer comes into play.</p>
<p>但您会注意到，有些顶点被多次使用。C、 B使用两次，E重复三次。假设每个浮点是4个字节，那么这意味着我们用于顶点的216个字节中，有96个是重复数据。如果我们能列出这些顶点一次，不是很好吗？我们可以！这就是索引缓冲区发挥作用的原因。</p>
<p>Basically we store all the unique vertices in VERTICES and we create another buffer that stores indices to elements in VERTICES to create the triangles. Here’s an example of that with our pentagon.</p>
<p>基本上，我们将所有唯一的顶点存储在VERTICES中，并创建另一个缓冲区来存储顶点中元素的索引以创建三角形。这是我们五角大楼的一个例子。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main.rs</span></span><br><span class="line"><span class="keyword">const</span> VERTICES: &amp;[Vertex] = &amp;[</span><br><span class="line">    Vertex &#123; position: [-<span class="number">0.0868241</span>, <span class="number">0.49240386</span>, <span class="number">0.0</span>], color: [<span class="number">0.5</span>, <span class="number">0.0</span>, <span class="number">0.5</span>] &#125;, <span class="comment">// A</span></span><br><span class="line">    Vertex &#123; position: [-<span class="number">0.49513406</span>, <span class="number">0.06958647</span>, <span class="number">0.0</span>], color: [<span class="number">0.5</span>, <span class="number">0.0</span>, <span class="number">0.5</span>] &#125;, <span class="comment">// B</span></span><br><span class="line">    Vertex &#123; position: [-<span class="number">0.21918549</span>, -<span class="number">0.44939706</span>, <span class="number">0.0</span>], color: [<span class="number">0.5</span>, <span class="number">0.0</span>, <span class="number">0.5</span>] &#125;, <span class="comment">// C</span></span><br><span class="line">    Vertex &#123; position: [<span class="number">0.35966998</span>, -<span class="number">0.3473291</span>, <span class="number">0.0</span>], color: [<span class="number">0.5</span>, <span class="number">0.0</span>, <span class="number">0.5</span>] &#125;, <span class="comment">// D</span></span><br><span class="line">    Vertex &#123; position: [<span class="number">0.44147372</span>, <span class="number">0.2347359</span>, <span class="number">0.0</span>], color: [<span class="number">0.5</span>, <span class="number">0.0</span>, <span class="number">0.5</span>] &#125;, <span class="comment">// E</span></span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> INDICES: &amp;[<span class="built_in">u16</span>] = &amp;[</span><br><span class="line">    <span class="number">0</span>, <span class="number">1</span>, <span class="number">4</span>,</span><br><span class="line">    <span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>,</span><br><span class="line">    <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>,</span><br><span class="line">    <span class="comment">/* padding */</span> <span class="number">0</span>,</span><br><span class="line">];</span><br></pre></td></tr></table></figure>

<p>Now with this setup our VERTICES take up about 120 bytes and INDICES is just 18 bytes given that u16 is 2 bytes wide. We add 2 bytes padding as wgpu requires buffers to be aligned to 4 bytes. All together our pentagon is 134 bytes in total. That means we saved 82 bytes! It may not seem like much, but when dealing with tri counts in the hundreds of thousands, indexing saves a lot of memory.</p>
<p>现在，在这个设置中，我们的顶点占用了大约120个字节，而索引仅为18个字节，因为u16的宽度为2个字节。我们添加了2个字节的填充，因为wgpu要求缓冲区与4个字节对齐。我们的五角大楼总共有134字节。这意味着我们节省了82字节！它可能看起来不太多，但在处理数十万的三重计数时，索引可以节省大量内存。</p>
<p>There’s a couple of things we need to change in order to use indexing. The first is we need to create a buffer to store the indices. In State’s new() method create the index_buffer after you create the vertex_buffer. Also change num_vertices to num_indices and set it equal to INDICES.len().</p>
<p>为了使用索引，我们需要改变一些事情。首先，我们需要创建一个缓冲区来存储索引。在State的new()方法中，在创建顶点缓冲区之后创建索引缓冲区。还可以将num_vertices更改为num_indices，并将其设置为INDICES.len()。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> vertex_buffer = device.create_buffer_init(</span><br><span class="line">    &amp;wgpu::util::BufferInitDescriptor &#123;</span><br><span class="line">        label: <span class="literal">Some</span>(<span class="string">&quot;Vertex Buffer&quot;</span>),</span><br><span class="line">        contents: bytemuck::cast_slice(VERTICES),</span><br><span class="line">        usage: wgpu::BufferUsage::VERTEX,</span><br><span class="line">    &#125;</span><br><span class="line">);</span><br><span class="line"><span class="comment">// NEW!</span></span><br><span class="line"><span class="keyword">let</span> index_buffer = device.create_buffer_init(</span><br><span class="line">    &amp;wgpu::util::BufferInitDescriptor &#123;</span><br><span class="line">        label: <span class="literal">Some</span>(<span class="string">&quot;Index Buffer&quot;</span>),</span><br><span class="line">        contents: bytemuck::cast_slice(INDICES),</span><br><span class="line">        usage: wgpu::BufferUsage::INDEX,</span><br><span class="line">    &#125;</span><br><span class="line">);</span><br><span class="line"><span class="keyword">let</span> num_indices = INDICES.len() <span class="keyword">as</span> <span class="built_in">u32</span>;</span><br></pre></td></tr></table></figure>

<p>We don’t need to implement Pod and Zeroable for our indices, because bytemuck has already implemented them for basic types such as u16. That means we can just add index_buffer and num_indices to the State struct.</p>
<p>我们不需要为索引实现Pod和Zeroable，因为bytemuck已经为u16等基本类型实现了它们。这意味着我们可以将index_buffer和num_indices添加到State结构中。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">State</span></span> &#123;</span><br><span class="line">    surface: wgpu::Surface,</span><br><span class="line">    device: wgpu::Device,</span><br><span class="line">    queue: wgpu::Queue,</span><br><span class="line">    sc_desc: wgpu::SwapChainDescriptor,</span><br><span class="line">    swap_chain: wgpu::SwapChain,</span><br><span class="line">    size: winit::dpi::PhysicalSize&lt;<span class="built_in">u32</span>&gt;,</span><br><span class="line">    render_pipeline: wgpu::RenderPipeline,</span><br><span class="line">    vertex_buffer: wgpu::Buffer,</span><br><span class="line">    <span class="comment">// NEW!</span></span><br><span class="line">    index_buffer: wgpu::Buffer, </span><br><span class="line">    num_indices: <span class="built_in">u32</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>And then populate these fields in the constructor:</p>
<p>然后在构造函数中填充这些字段：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Self</span> &#123;</span><br><span class="line">    surface,</span><br><span class="line">    device,</span><br><span class="line">    queue,</span><br><span class="line">    sc_desc,</span><br><span class="line">    swap_chain,</span><br><span class="line">    size,</span><br><span class="line">    render_pipeline,</span><br><span class="line">    vertex_buffer,</span><br><span class="line">    <span class="comment">// NEW!</span></span><br><span class="line">    index_buffer,</span><br><span class="line">    num_indices,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>All we have to do now is update the render() method to use the index_buffer.</p>
<p>我们现在要做的就是更新render()方法以使用index_buffer。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// render()</span></span><br><span class="line">render_pass.set_pipeline(&amp;<span class="keyword">self</span>.render_pipeline);</span><br><span class="line">render_pass.set_vertex_buffer(<span class="number">0</span>, <span class="keyword">self</span>.vertex_buffer.slice(..));</span><br><span class="line">render_pass.set_index_buffer(<span class="keyword">self</span>.index_buffer.slice(..), wgpu::IndexFormat::Uint16); <span class="comment">// 1.</span></span><br><span class="line">render_pass.draw_indexed(<span class="number">0</span>..<span class="keyword">self</span>.num_indices, <span class="number">0</span>, <span class="number">0</span>..<span class="number">1</span>); <span class="comment">// 2.</span></span><br></pre></td></tr></table></figure>

<p>A couple things to note:</p>
<ol>
<li>The method name is set_index_buffer not set_index_buffers. You can only have one index buffer set at a time.</li>
<li>When using an index buffer, you need to use draw_indexed. The draw method ignores the index buffer. Also make sure you use the number of indices (num_indices), not vertices as your model will either draw wrong, or the method will panic because there are not enough indices.</li>
</ol>
<p>有几件事需要注意：</p>
<ol>
<li>方法名称是set_index_buffer而不是set_index_buffers。一次只能设置一个索引缓冲区。</li>
<li>使用索引缓冲区时，需要使用draw_indexed。draw方法忽略索引缓冲区。还要确保使用的是索引的数量（num_index），而不是顶点，否则您的模型可能会绘制错误，或者该方法会因为索引不足而死机。</li>
</ol>
<p>With all that you should have a garishly magenta pentagon in your window.</p>
<p>所有这些，你应该有一个华丽的洋红色五角大楼在你的窗口。</p>
<p><img src="data:image/png;base64,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EAEqzVSkP4QGAP0mRIDKEyOLIzYAGCQhAlBTQgOAMhMiQC00dSoiNgCoKiEC1EYdY0RoAFBXQgSolSrGiNgAoImECECfCQ0AuJIQAWoneyoiNABg4YQIUEu9jhGxAQC9JUQAQmgAQDYhAtTW5VMRsQEA5SFEgFoTHwBQTu1BLwAAAGgeIQIAAKQTIgAAQDohAgAApBMiAABAOiECAACkEyIAAEA6IQIAAKQTIgAAQDohAgAApBMiAABAOiECAACkEyIAAEA6IQIAAKQTIgAAQDohAgAApBMiAABAOiECAACkEyIAAEA6IQIAAKQTIgAAQDohAgAApBMiAABAOiECAACkEyIAAEA6IQIAAKQTIgAAQDohAgAApBMiAABAOiECAACkEyIAAEA6IQIAAKQTIgAAQDohAgAApBMiAABAOiECAACkEyIAAEA6IQIAAKQTIgAAQDohAgAApBMiAABAOiECAACkEyIAAEA6IQIAAKQTIgAAQDohAgAApBMiAABAOiECAACkEyIAAEA6IQIAAKQTIgAAQDohAgAApBMiAABAOiECAACkEyIAAEA6IQIAAKQTIgAAQDohAgAApBMiAABAOiECAACkEyIAAEA6IQIAAKQTIgAAQDohAgAApBMiAABAOiECAACkEyIAAEA6IQIAAKQTIgAAQDohAgAApBMiAABAOiECAACkEyIAAEA6IQIAAKQTIgAAQDohAgAApBMiAABAOiECAACkEyIAAEA6IQIAAKQTIgAAQDohAgAApBMiAABAOiECAACkEyIAAEA6IQIAAKQTIgAAQDohAgAApBMiAABAOiECAACkEyIAAEA6IQIAAKQTIgAAQDohAgAApBMiAABAOiECAACkEyIAAEA6IQIAAKQTIgAAQDohAgAApBMiAABAOiECAACkEyIAAEA6IQIAAKQTIgAAQDohAgAApBMiAABAOiECAACkEyIAAEA6IQIAAKQTIgAAQDohAgAApBMiAABAOiECAACkEyIAAEA6IQIAAKQTIgAAQDohAgAApBMiAABAOiECAACkEyIAAEA6IQIAAKQTIgAAQDohAgAApBMiAABAOiECAACkEyIAAEA6IQIAAKQTIgAAQDohAgAApBMiAABAOiECAACkEyIAAEA6IQIAAKQTIgAAQDohAgAApBMiAABAOiECAACkEyIAAEA6IQIAAKQTIgAAQDohAgAApBMiAABAOiECAACkEyIAAEA6IQIAAKQTIgAAQDohAgAApBMiAABAOiECAACkEyIAAEA6IQIAAKQTIgAAQDohAgAApBMiAABAOiECAACkEyIAAEA6IQIAAKQTIgAAQDohAgAApBMiAABAOiECAACkEyIAAEA6IQIAAKQbjoh4ZH1r0OsAAAAa5P8D75CpLfCP/NcAAAAASUVORK5CYII=" alt="索引五角形"></p>
<h1 id="Color-Correction"><a href="#Color-Correction" class="headerlink" title="Color Correction"></a>Color Correction</h1><p>If you use a color picker on the magenta pentagon, you’ll get a hex value of #BC00BC. If you convert this to RGB values you’ll get (188, 0, 188). Dividing these values by 255 to get them into the [0, 1] range we get roughly (0.737254902, 0, 0.737254902). This is not the same as we are using for our vertex colors which is (0.5, 0.0, 0.5). The reason for this has to do with color spaces.</p>
<p>如果在洋红五角大楼上使用颜色选择器，将得到十六进制值#BC00BC。如果您将其转换为RGB值，您将得到(188,0188)。将这些值除以255得到[0,1]范围，我们大致得到(0.737254902,0,0.737254902)。这与我们使用的顶点颜色(0.5、0.0、0.5)不同。这与颜色空间有关。</p>
<p>Most monitors use a color space know as sRGB. Our swap chain is (most likely depending on what is returned from adapter.get_swap_chain_preferred_format()) using an sRGB texture format. The sRGB format stores colors according to their relative brightness instead of their actual brightness. The reason for this is that our eyes don’t perceive light linearly. We notice more differences in darker colors than we do lighter colors.</p>
<p>大多数显示器使用的颜色空间称为sRGB。我们的swap chain是(很可能取决于适配器返回的内容。adapter.get_swap_chain_preferred_format())使用sRGB纹理格式。sRGB格式根据颜色的相对亮度而不是实际亮度存储颜色。原因是我们的眼睛不能线性感知光线。我们注意到深色的差异比浅色的多。</p>
<p>You get an approximation of the correct color using the following formula: srgb_color = (rgb_color / 255) ^ 2.2. Doing this with an RGB value of (188, 0, 188) will give us (0.511397819, 0.0, 0.511397819). A little off from our (0.5, 0.0, 0.5). While you could tweak the formula to get the desired values, you’ll likely save a lot of time by using textures instead as they are stored as sRGB by default, so they don’t suffer from the same color inaccuracies that vertex colors do. We’ll cover textures in the next lesson.</p>
<p>使用以下公式可以获得正确颜色的近似值：srgb_color=(rgb_color/255)^2.2。在RGB值为（188,0188）的情况下执行此操作将得到（0.511397819,0.0,0.511397819）。离我们的（0.5,0.0,0.5）有点远。虽然可以调整公式以获得所需的值，但使用纹理可能会节省大量时间，因为默认情况下纹理存储为sRGB，因此它们不会像顶点颜色那样出现颜色不准确的情况。我们将在下一课中介绍纹理。</p>
<h1 id="Challenge"><a href="#Challenge" class="headerlink" title="Challenge"></a>Challenge</h1><p>Create a more complex shape than the one we made (aka. more than three triangles) using a vertex buffer and an index buffer. Toggle between the two with the space key.</p>
<p>创建一个比我们制作的形状更复杂的形状（aka。三个以上的三角形）使用顶点缓冲区和索引缓冲区。使用空格键在两者之间切换。</p>
<p><a target="_blank" rel="noopener" href="https://github.com/sotrh/learn-wgpu/tree/master/code/beginner/tutorial4-buffer/">Check out the code! </a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://qianqians.github.io/2021/08/20/Wgpu%20The%20Pipeline/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="qianqians">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="qianqians'blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/08/20/Wgpu%20The%20Pipeline/" class="post-title-link" itemprop="url">Wgpu The Pipeline</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-08-20 15:17:03" itemprop="dateCreated datePublished" datetime="2021-08-20T15:17:03+08:00">2021-08-20</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-08-24 16:28:38" itemprop="dateModified" datetime="2021-08-24T16:28:38+08:00">2021-08-24</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Wgpu/" itemprop="url" rel="index"><span itemprop="name">Wgpu</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="What’s-a-pipeline"><a href="#What’s-a-pipeline" class="headerlink" title="What’s a pipeline?"></a>What’s a pipeline?</h1><p>If you’re familiar with OpenGL, you may remember using shader programs. You can think of a pipeline as a more robust version of that. A pipeline describes all the actions the gpu will perform when acting on a set of data. In this section, we will be creating a RenderPipeline specifically.</p>
<p>如果您熟悉OpenGL，可能还记得使用着色器程序。您可以将管道视为更健壮的版本。管道描述了gpu在处理一组数据时将执行的所有操作。在本节中，我们将专门创建渲染管线。</p>
<h1 id="Wait-shaders"><a href="#Wait-shaders" class="headerlink" title="Wait shaders?"></a>Wait shaders?</h1><p>Shaders are mini programs that you send to the gpu to perform operations on your data. There are 3 main types of shader: vertex, fragment, and compute. There are others such as geometry shaders, but they’re more of an advanced topic. For now we’re just going to use vertex, and fragment shaders.</p>
<p>着色器是发送到gpu以对数据执行操作的小型程序。着色器有3种主要类型：顶点、片段和计算。还有其他一些，如几何体着色器，但它们更像是一个高级主题。现在我们将使用顶点和片段着色器。</p>
<h1 id="Vertex-fragment-what-are-those"><a href="#Vertex-fragment-what-are-those" class="headerlink" title="Vertex, fragment.. what are those?"></a>Vertex, fragment.. what are those?</h1><p>A vertex is a point in 3d space (can also be 2d). These vertices are then bundled in groups of 2s to form lines and/or 3s to form triangles.</p>
<p>顶点是三维空间中的一个点（也可以是二维的）。然后将这些顶点捆绑成2个一组，形成直线或3个一组，形成三角形。</p>
<p><img src="https://sotrh.github.io/learn-wgpu/assets/img/tutorial3-pipeline-vertices.5e39e8fc.png" alt="vertices"></p>
<p>Most modern rendering uses triangles to make all shapes, from simple shapes (such as cubes), to complex ones (such as people). These triangles are stored as vertices which are the points that make up the corners of the triangles.</p>
<p>大多数现代渲染使用三角形生成所有形状，从简单形状（如立方体）到复杂形状（如人）。这些三角形存储为顶点，这些顶点是构成三角形角的点。</p>
<p>We use a vertex shader to manipulate the vertices, in order to transform the shape to look the way we want it.</p>
<p>我们使用顶点着色器来操纵顶点，以便将形状变换为我们想要的样子。</p>
<p>The vertices are then converted into fragments. Every pixel in the result image gets at least one fragment. Each fragment has a color that will be copied to its corresponding pixel. The fragment shader decides what color the fragment will be.</p>
<p>然后将顶点转换为片段。结果图像中的每个像素至少获得一个片段。每个片段都有一个将被复制到其相应像素的颜色。片段着色器决定片段的颜色。</p>
<h1 id="WGSL"><a href="#WGSL" class="headerlink" title="WGSL"></a>WGSL</h1><p>WebGPU supports two shader languages natively: SPIR-V, and WGSL. SPIR-V is actually a binary format developed by Kronos to be a compilation target for other languages such as GLSL and HLSL. It allows for easy porting of code. The only problem is that it’s not human readable as it’s a binary language. WGSL is meant to fix that. WGSL’s development focuses on getting it to easily convert into SPIR-V. WGPU even allows us to supply WGSL for our shaders.</p>
<p>WebGPU本机支持两种着色器语言：SPIR-V和WGSL。SPIR-V实际上是Kronos开发的二进制格式，用于其他语言（如GLSL和HLSL）的编译目标。它允许轻松移植代码。唯一的问题是它不是人类可读的，因为它是一种二进制语言。WGSL旨在解决这一问题。WGSL的开发重点是使其能够轻松转换为SPIR-V。WGPU同样允许我们为着色器提供WGSL。</p>
<p>If you’ve gone through this tutorial before you’ll likely notice that I’ve switched from using GLSL to using WGSL. Given that GLSL support is a secondary concern and that WGSL is the first class language of WGPU, I’ve elected to convert all the tutorials to use WGSL. Some of the showcase examples still use GLSL, but the main tutorial and all examples going forward will be using WGSL.</p>
<p>如果您之前阅读过本教程，您可能会注意到我已从使用GLSL切换到使用WGSL。考虑到GLSL支持是第二个问题，而WGSL是WGPU的第一类语言，我选择将所有教程转换为使用WGSL。一些showcase示例仍然使用GLSL，但主教程和所有后续示例将使用WGSL。</p>
<p>The WGSL spec and it’s inclusion in WGPU is still in development. If you run into trouble using it, you may want the folks at <a target="_blank" rel="noopener" href="https://app.element.io/#/room/#wgpu:matrix.org">https://app.element.io/#/room/#wgpu:matrix.org</a> to take a look at your code.</p>
<p>WGSL规范及其包含在WGPU中的内容仍在开发中。如果你在使用它时遇到麻烦，你可能想让人们在<a target="_blank" rel="noopener" href="https://app.element.io/#/room/#wgpu:matrix.org">https://app.element.io/#/room/#wgpu:matrix.org</a> 来看看你的代码。</p>
<h1 id="Writing-the-shaders"><a href="#Writing-the-shaders" class="headerlink" title="Writing the shaders"></a>Writing the shaders</h1><p>In the same folder as main.rs, create a file shader.wgsl. Write the following code in shader.wgsl.</p>
<p>在与main.rs相同的文件夹中，创建文件shader.wgsl。在shader.wgsl中编写以下代码。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Vertex shader</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">VertexOutput</span></span> &#123;</span><br><span class="line">    [[builtin(position)]] clip_position: vec4&lt;<span class="built_in">f32</span>&gt;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">[[stage(vertex)]]</span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>(</span><br><span class="line">    [[builtin(vertex_index)]] in_vertex_index: <span class="built_in">u32</span>,</span><br><span class="line">) -&gt; VertexOutput &#123;</span><br><span class="line">    var out: VertexOutput;</span><br><span class="line">    <span class="keyword">let</span> x = <span class="built_in">f32</span>(<span class="number">1</span> - <span class="built_in">i32</span>(in_vertex_index)) * <span class="number">0.5</span>;</span><br><span class="line">    <span class="keyword">let</span> y = <span class="built_in">f32</span>(<span class="built_in">i32</span>(in_vertex_index &amp; <span class="number">1</span>u) * <span class="number">2</span> - <span class="number">1</span>) * <span class="number">0.5</span>;</span><br><span class="line">    out.clip_position = vec4&lt;<span class="built_in">f32</span>&gt;(x, y, <span class="number">0.0</span>, <span class="number">1.0</span>);</span><br><span class="line">    <span class="keyword">return</span> out;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>First we declare struct to store the output of our vertex shader. This consists of only one field currently which is our vertex’s clip_position. The [[builtin(position)]] bit tells WGPU that this is the value we want to use as the vertex’s clip coordinates. This is analogous to GLSL’s gl_Position variable.</p>
<p>首先，我们声明struct来存储顶点着色器的输出。这当前只包含一个字段，它是顶点的剪辑位置。[[builtin（position）]位告诉WGPU这是我们要用作顶点剪辑坐标的值。这类似于GLSL的gl_位置变量。</p>
<blockquote>
<p>Vector types such as vec4 are generic. Currently you must specify the type of value the vector will contain. Thus a 3D vector using 32bit floats would be vec3<f32>.</p>
</blockquote>
<blockquote>
<p>向量类型（如vec4）是泛型的。当前必须指定向量将包含的值的类型。因此，使用32位浮点的3D向量将是vec3<f32>。</p>
</blockquote>
<p>The next part of the shader code is the main function. We are using [[stage(vertex)]] to mark this function as a valid entry point for a vertex shader. We expect a u32 called in_vertex_index which gets its value from [[builtin(vertex_index)]].</p>
<p>着色器代码的下一部分是主函数。我们使用[[stage(vertex)]]将此函数标记为顶点着色器的有效入口点。我们期望一个名为in_vertex_index的u32，它的值来自[[builtin(vertex_index)]]。</p>
<p>We then declare a variable called out using our VertexOutput struct. We create two other variables for the x, and y, of a triangle.</p>
<p>然后，我们声明一个使用VertexOutput结构调用的变量。我们为三角形创建x和y及另外两个变量。</p>
<div class="note">

<p>The f32() and i32() bits are examples of casts.</p>
<p>f32()和i32()位是强制转换的示例。</p>
</div>

<div class="note">

<p>Variables defined with <code>var</code> can be modified, but must specify their type. Variables created with <code>let</code> can have their types inferred, but their value cannot be changed during the shader.</p>
<p>可以修改用’var’定义的变量，但必须指定其类型。使用’let’创建的变量可以推断其类型，但在着色器期间不能更改其值。</p>
</div>

<p>Now we can save our clip_position to out. We then just return out and we’re done with the vertex shader!</p>
<p>现在我们可以将clip_position保存为out。然后我们返回，顶点着色器就完成了！</p>
<div class="note">

<p>We technically didn’t need a struct for this example, and could have just done something like the following:</p>
<p>从技术上讲，本例不需要结构，只需执行以下操作即可：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[[stage(vertex)]]</span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>(</span><br><span class="line">    [[builtin(vertex_index)]] in_vertex_index: <span class="built_in">u32</span></span><br><span class="line">) -&gt; [[builtin(position)]] vec4&lt;<span class="built_in">f32</span>&gt; &#123;</span><br><span class="line">    <span class="comment">// Vertex shader code...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>We’ll be adding more fields to VertexOutput later, so we might as well start using it now.</p>
<p>稍后，我们将向VertexOutput添加更多字段，因此我们不妨现在就开始使用它。</p>
</div>

<p>Next up the fragment shader. Still in shader.wgsl add the follow:</p>
<p>接下来是片段着色器。仍在shader.wgsl中添加以下内容：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Fragment shader</span></span><br><span class="line"></span><br><span class="line">[[stage(fragment)]]</span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>(<span class="keyword">in</span>: VertexOutput) -&gt; [[location(<span class="number">0</span>)]] vec4&lt;<span class="built_in">f32</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> vec4&lt;<span class="built_in">f32</span>&gt;(<span class="number">0.3</span>, <span class="number">0.2</span>, <span class="number">0.1</span>, <span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>All this does is set the color of the current fragment to brown color.</p>
<p>所有这些操作都是将当前片段的颜色设置为棕色。</p>
<div class="note">

<p>Notice that this function is also called main. Because this function is marked as a fragment shader entry point, this is ok. You can change the names around if you like, but I’ve opted to keep them the same.</p>
<p>请注意，此函数也称为main。因为此函数被标记为片段着色器入口点，所以这是确定的。如果你愿意的话，你可以改变名字，但我还是选择了保持不变。</p>
</div>

<p>The [[location(0)]] bit tells WGPU to store the value the vec4 returned by this function in the first color target. We’ll get into what this is later.</p>
<p>[[location(0)]]位告诉WGPU将此函数返回的vec4值存储在第一个颜色目标中。我们以后再谈这件事。</p>
<h1 id="How-do-we-use-the-shaders"><a href="#How-do-we-use-the-shaders" class="headerlink" title="How do we use the shaders?"></a>How do we use the shaders?</h1><p>This is the part where we finally make the thing in the title: the pipeline. First let’s modify State to include the following.</p>
<p>接着我们最终制作标题中的东西的部分：pipeline。首先，让我们修改State以包括以下内容。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main.rs</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">State</span></span> &#123;</span><br><span class="line">    surface: wgpu::Surface,</span><br><span class="line">    device: wgpu::Device,</span><br><span class="line">    queue: wgpu::Queue,</span><br><span class="line">    sc_desc: wgpu::SwapChainDescriptor,</span><br><span class="line">    swap_chain: wgpu::SwapChain,</span><br><span class="line">    size: winit::dpi::PhysicalSize&lt;<span class="built_in">u32</span>&gt;,</span><br><span class="line">    <span class="comment">// NEW!</span></span><br><span class="line">    render_pipeline: wgpu::RenderPipeline,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Now let’s move to the new() method, and start making the pipeline. We’ll have to load in those shaders we made earlier, as the render_pipeline requires those.</p>
<p>现在让我们转到new()方法，开始制作pipeline。我们必须加载之前制作的着色器，因为render_pipeline需要这些着色器。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> shader = device.create_shader_module(&amp;wgpu::ShaderModuleDescriptor &#123;</span><br><span class="line">    label: <span class="literal">Some</span>(<span class="string">&quot;Shader&quot;</span>),</span><br><span class="line">    flags: wgpu::ShaderFlags::all(),</span><br><span class="line">    source: wgpu::ShaderSource::Wgsl(<span class="built_in">include_str!</span>(<span class="string">&quot;shader.wgsl&quot;</span>).into()),</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>One more thing, we need to create a PipelineLayout. We’ll get more into this after we cover Buffers.</p>
<p>还有一件事，我们需要创建一个PipelineLayout。在我们讨论缓冲区之后，我们将进一步讨论这个问题。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> render_pipeline_layout =</span><br><span class="line">    device.create_pipeline_layout(&amp;wgpu::PipelineLayoutDescriptor &#123;</span><br><span class="line">        label: <span class="literal">Some</span>(<span class="string">&quot;Render Pipeline Layout&quot;</span>),</span><br><span class="line">        bind_group_layouts: &amp;[],</span><br><span class="line">        push_constant_ranges: &amp;[],</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure>

<p>Finally we have all we need to create the render_pipeline.</p>
<p>最后，我们有了创建render_pipeline所需的一切。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> render_pipeline = device.create_render_pipeline(&amp;wgpu::RenderPipelineDescriptor &#123;</span><br><span class="line">    label: <span class="literal">Some</span>(<span class="string">&quot;Render Pipeline&quot;</span>),</span><br><span class="line">    layout: <span class="literal">Some</span>(&amp;render_pipeline_layout),</span><br><span class="line">    vertex: wgpu::VertexState &#123;</span><br><span class="line">        module: &amp;shader,</span><br><span class="line">        entry_point: <span class="string">&quot;main&quot;</span>, <span class="comment">// 1.</span></span><br><span class="line">        buffers: &amp;[], <span class="comment">// 2.</span></span><br><span class="line">    &#125;,</span><br><span class="line">    fragment: <span class="literal">Some</span>(wgpu::FragmentState &#123; <span class="comment">// 3.</span></span><br><span class="line">        module: &amp;shader,</span><br><span class="line">        entry_point: <span class="string">&quot;main&quot;</span>,</span><br><span class="line">        targets: &amp;[wgpu::ColorTargetState &#123; <span class="comment">// 4.</span></span><br><span class="line">            format: sc_desc.format,</span><br><span class="line">            blend: <span class="literal">Some</span>(wgpu::BlendState::REPLACE),</span><br><span class="line">            write_mask: wgpu::ColorWrite::ALL,</span><br><span class="line">        &#125;],</span><br><span class="line">    &#125;),</span><br><span class="line">    <span class="comment">// continued ...</span></span><br></pre></td></tr></table></figure>

<p>Two things to note here:<br>这里需要注意两件事：</p>
<ol>
<li>Here you can specify which function inside of the shader should be called, which is known as the entry_point. These are the functions we marked with [[stage(vertex)]] and [[stage(fragment)]]</li>
<li>The buffers field tells wgpu what type of vertices we want to pass to the vertex shader. We’re specifying the vertices in the vertex shader itself so we’ll leave this empty. We’ll put something there in the next tutorial.</li>
<li>The fragment is technically optional, so you have to wrap it in Some(). We need it if we want to store color data to the swap_chain.</li>
<li>The targets field tells wgpu what color outputs it should set up.Currently we only need one for the swap_chain. We use the swap_chain’s format so that copying to it is easy, and we specify that the blending should just replace old pixel data with new data. We also tell wgpu to write to all colors: red, blue, green, and alpha. We’ll talk more aboutcolor_state when we talk about textures.</li>
</ol>
<div></div>

<ol>
<li>在这里，您可以指定应该调用着色器内部的哪个函数，该函数称为入口点。这些是我们用[[stage(vertex)]]和[[stage(fragment)]标记的函数</li>
<li>buffers字段告诉wgpu要传递给顶点着色器的顶点类型。我们将在顶点着色器本身中指定顶点，因此将此项留空。我们将在下一个教程中介绍一些内容。</li>
<li>片段着色器在技术上是可选的，因此您必须将其包装在Some()中。如果我们想将颜色数据存储到交换链，就需要它。</li>
<li>targets字段告诉wgpu应该设置什么颜色输出。目前，我们只需要一个用于交换链。我们使用swap_chain的格式，以便复制到它是很容易的，并且我们指定混合应该只是用新数据替换旧的像素数据。我们还告诉wgpu写入所有颜色：红色、蓝色、绿色和alpha。在讨论纹理时，我们将更多地讨论颜色状态。</li>
</ol>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">primitive: wgpu::PrimitiveState &#123;</span><br><span class="line">    topology: wgpu::PrimitiveTopology::TriangleList, <span class="comment">// 1.</span></span><br><span class="line">    strip_index_format: <span class="literal">None</span>,</span><br><span class="line">    front_face: wgpu::FrontFace::Ccw, <span class="comment">// 2.</span></span><br><span class="line">    cull_mode: <span class="literal">Some</span>(wgpu::Face::Back),</span><br><span class="line">    <span class="comment">// Setting this to anything other than Fill requires Features::NON_FILL_POLYGON_MODE</span></span><br><span class="line">    polygon_mode: wgpu::PolygonMode::Fill,</span><br><span class="line">    <span class="comment">// Requires Features::DEPTH_CLAMPING</span></span><br><span class="line">    clamp_depth: <span class="literal">false</span>,</span><br><span class="line">    <span class="comment">// Requires Features::CONSERVATIVE_RASTERIZATION</span></span><br><span class="line">    conservative: <span class="literal">false</span>,</span><br><span class="line">&#125;,</span><br><span class="line"><span class="comment">// continued ...</span></span><br></pre></td></tr></table></figure>

<p>The primitive field describes how to interpret our vertices when converting them into triangles.<br>primitive字段描述了在将顶点转换为三角形时如何解释顶点。</p>
<ol>
<li>Using PrimitiveTopology::TriangleList means that each three vertices will correspond to one triangle.</li>
<li>The front_face and cull_mode fields tell wgpu how to determine whether a given triangle is facing forward or not. FrontFace::Ccw means that a triangle is facing forward if the vertices are arranged in a counter clockwise direction. Triangles that are not considered facing forward are culled (not included in the render) as specified by CullMode::Back. We’ll cover culling a bit more when we cover Buffers.</li>
</ol>
<div></div>

<ol>
<li>使用PrimitiveTopology::TriangleList意味着每三个顶点对应一个三角形。</li>
<li>front_face和cull_mode字段告诉wgpu如何确定给定三角形是否朝前。FrontFace:：Ccw表示如果顶点按逆时针方向排列，则三角形朝前。根据CullMode:：Back的指定，将剔除（不包括在渲染中）不被视为朝前的三角形。当我们讨论缓冲区时，我们将更多地讨论剔除。</li>
</ol>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">    depth_stencil: <span class="literal">None</span>, <span class="comment">// 1.</span></span><br><span class="line">    multisample: wgpu::MultisampleState &#123;</span><br><span class="line">        count: <span class="number">1</span>, <span class="comment">// 2.</span></span><br><span class="line">        mask: !<span class="number">0</span>, <span class="comment">// 3.</span></span><br><span class="line">        alpha_to_coverage_enabled: <span class="literal">false</span>, <span class="comment">// 4.</span></span><br><span class="line">    &#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>The rest of the method is pretty simple:<br>该方法的其余部分非常简单：</p>
<ol>
<li>We’re not using a depth/stencil buffer currently, so we leave depth_stencil as None. This will change later.</li>
<li>This determines how many samples this pipeline will use. Multisampling is a complex topic, so we won’t get into it here.</li>
<li>sample_mask specifies which samples should be active. In this case we are using all of them.</li>
<li>alpha_to_coverage_enabled has to do with anti-aliasing. We’re not covering anti-aliasing here, so we’ll leave this as false now.</li>
</ol>
<div></div>

<ol>
<li>我们目前没有使用depth/stencil缓冲区，因此我们将depth/stencil保留为无。这将在以后改变。</li>
<li>这将确定此pipeline将使用多少个样本。多重采样是一个复杂的主题，因此我们在这里不进行讨论。</li>
<li>sample_mask指定哪些样本应处于活动状态。在本例中，我们使用了所有这些。</li>
<li>启用alpha_to_coverage_enabled与抗锯齿有关。我们这里不讨论反走样，所以现在将其保留为false。</li>
</ol>
<p>Now all we have to do is save the render_pipeline to State and then we can use it!</p>
<p>现在我们所要做的就是将render_pipeline保存到State，然后我们就可以使用它了！</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// new()</span></span><br><span class="line"><span class="keyword">Self</span> &#123;</span><br><span class="line">    surface,</span><br><span class="line">    device,</span><br><span class="line">    queue,</span><br><span class="line">    sc_desc,</span><br><span class="line">    swap_chain,</span><br><span class="line">    size,</span><br><span class="line">    <span class="comment">// NEW!</span></span><br><span class="line">    render_pipeline,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Using-a-pipeline"><a href="#Using-a-pipeline" class="headerlink" title="Using a pipeline"></a>Using a pipeline</h1><p>If you run your program now, it’ll take a little longer to start, but it will still show the blue screen we got in the last section. That’s because while we created the render_pipeline, we need to modify the code in render() to actually use it.</p>
<p>如果你现在运行你的程序，它将需要更长的时间来启动，但它仍然会显示我们在上一节中得到的蓝屏。这是因为当我们创建render_pipeline时，我们需要修改render()中的代码以实际使用它。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// render()</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 1.</span></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> render_pass = encoder.begin_render_pass(&amp;wgpu::RenderPassDescriptor &#123;</span><br><span class="line">        label: <span class="literal">Some</span>(<span class="string">&quot;Render Pass&quot;</span>),</span><br><span class="line">        color_attachments: &amp;[</span><br><span class="line">            <span class="comment">// This is what [[location(0)]] in the fragment shader targets</span></span><br><span class="line">            wgpu::RenderPassColorAttachment &#123;</span><br><span class="line">                view: &amp;frame.view,</span><br><span class="line">                resolve_target: <span class="literal">None</span>,</span><br><span class="line">                ops: wgpu::Operations &#123;</span><br><span class="line">                    load: wgpu::LoadOp::Clear(</span><br><span class="line">                        wgpu::Color &#123;</span><br><span class="line">                            r: <span class="number">0.1</span>,</span><br><span class="line">                            g: <span class="number">0.2</span>,</span><br><span class="line">                            b: <span class="number">0.3</span>,</span><br><span class="line">                            a: <span class="number">1.0</span>,</span><br><span class="line">                        &#125;</span><br><span class="line">                    ),</span><br><span class="line">                    store: <span class="literal">true</span>,</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        ],</span><br><span class="line">        depth_stencil_attachment: <span class="literal">None</span>,</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// NEW!</span></span><br><span class="line">    render_pass.set_pipeline(&amp;<span class="keyword">self</span>.render_pipeline); <span class="comment">// 2.</span></span><br><span class="line">    render_pass.draw(<span class="number">0</span>..<span class="number">3</span>, <span class="number">0</span>..<span class="number">1</span>); <span class="comment">// 3.</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure>

<p>We didn’t change much, but let’s talk about what we did change.<br>我们变化不大，但让我们谈谈我们改变了什么。</p>
<ol>
<li>We renamed _render_pass to render_pass and made it mutable.</li>
<li>We set the pipeline on the render_pass using the one we just created.</li>
<li>We tell wgpu to draw something with 3 vertices, and 1 instance. This is where [[builtin(vertex_index)]] comes from.</li>
</ol>
<div></div>

<ol>
<li>我们将_render_pass重命名为render_pass并使其可变。</li>
<li>我们将刚才创建的pipeline设置在render_pass上。</li>
<li>我们告诉wgpu用3个顶点和1个实例绘制一些东西。这就是[[builtin(vertex_index)]]的来源。</li>
</ol>
<p>With all that you should be seeing a lovely brown triangle.<br>所有这些，你应该看到一个可爱的棕色三角形。</p>
<h1 id="Challenge"><a href="#Challenge" class="headerlink" title="Challenge"></a>Challenge</h1><p>Create a second pipeline that uses the triangle’s position data to create a color that it then sends to the fragment shader. Have the app swap between these when you press the spacebar. Hint: you’ll need to modify VertexOutput</p>
<p>创建第二条管道，该管道使用三角形的位置数据创建颜色，然后发送到片段着色器。按空格键时，让应用程序在这两者之间切换。提示：您需要修改VertexOutput</p>
<p><a target="_blank" rel="noopener" href="https://github.com/sotrh/learn-wgpu/tree/master/code/beginner/tutorial3-pipeline/">Check out the code!</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">qianqians</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>

<script src="/js/bookmark.js"></script>




  















  

  

</body>
</html>
