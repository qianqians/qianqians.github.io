<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">
  <link rel="manifest" href="/images/manifest.json">
  <meta name="msapplication-config" content="/images/browserconfig.xml">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">
<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"qianqians.github.io","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"remove","padding":18,"offset":12,"onmobile":true},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":true,"scrollpercent":true},"bookmark":{"enable":true,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="Our scene right now is very simple: we have one object centered at (0,0,0). What if we wanted more objects? This is were instancing comes in. 我们现在的场景非常简单：我们有一个以（0,0,0）为中心的对象。如果我们想要更多的东西呢？这是实例的目标。 Inst">
<meta property="og:type" content="article">
<meta property="og:title" content="Wgpu Instancing">
<meta property="og:url" content="https://qianqians.github.io/2021/09/02/Wgpu%20Instancing/index.html">
<meta property="og:site_name" content="qianqians&#39;blog">
<meta property="og:description" content="Our scene right now is very simple: we have one object centered at (0,0,0). What if we wanted more objects? This is were instancing comes in. 我们现在的场景非常简单：我们有一个以（0,0,0）为中心的对象。如果我们想要更多的东西呢？这是实例的目标。 Inst">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://sotrh.github.io/learn-wgpu/assets/img/forest.5c5cf3ad.png">
<meta property="article:published_time" content="2021-09-02T06:49:22.516Z">
<meta property="article:modified_time" content="2021-09-02T07:33:51.239Z">
<meta property="article:author" content="qianqians">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://sotrh.github.io/learn-wgpu/assets/img/forest.5c5cf3ad.png">

<link rel="canonical" href="https://qianqians.github.io/2021/09/02/Wgpu%20Instancing/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>Wgpu Instancing | qianqians'blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">qianqians'blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档<span class="badge">22</span></a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>分类<span class="badge">2</span></a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-fw fa-user"></i>关于</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <a role="button" class="book-mark-link book-mark-link-fixed"></a>

  <a href="https://github.com/qianqians" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://qianqians.github.io/2021/09/02/Wgpu%20Instancing/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="qianqians">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="qianqians'blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Wgpu Instancing
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2021-09-02 14:49:22 / 修改时间：15:33:51" itemprop="dateCreated datePublished" datetime="2021-09-02T14:49:22+08:00">2021-09-02</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Wgpu/" itemprop="url" rel="index"><span itemprop="name">Wgpu</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>Our scene right now is very simple: we have one object centered at (0,0,0). What if we wanted more objects? This is were instancing comes in.</p>
<p>我们现在的场景非常简单：我们有一个以（0,0,0）为中心的对象。如果我们想要更多的东西呢？这是实例的目标。</p>
<p>Instancing allows us to draw the same object multiple times with different properties (position, orientation, size, color, etc.). There are multiple ways of doing instancing. One way would be to modify the uniform buffer to include these properties and then update it before we draw each instance of our object.</p>
<p>实例化允许我们使用不同的属性（位置、方向、大小、颜色等）多次绘制同一对象。有多种方法可以进行实例化。一种方法是修改uniform缓冲区以包含这些属性，然后在绘制对象的每个实例之前更新它。</p>
<p>We don’t want to use this method for performance reasons. Updating the uniform buffer for each instance would require multiple buffer copies each frame. On top of that, our method to update the uniform buffer currently requires use to create a new buffer to store the updated data. That’s a lot of time wasted between draw calls.</p>
<p>出于性能原因，我们不希望使用此方法。更新每个实例的uniform缓冲区将需要每个帧有多个缓冲区副本。除此之外，我们更新uniform缓冲区的方法目前需要创建一个新的缓冲区来存储更新后的数据。在两次draw calls之间浪费了很多时间。</p>
<p>If we look at the parameters for the draw_indexed function in the wgpu docs, we can see a solution to our problem.</p>
<p>如果我们查看wgpu文档中draw_indexed函数的参数，我们可以看到问题的解决方案。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">draw_indexed</span></span>(</span><br><span class="line">    &amp;<span class="keyword">mut</span> <span class="keyword">self</span>,</span><br><span class="line">    indices: Range&lt;<span class="built_in">u32</span>&gt;,</span><br><span class="line">    base_vertex: <span class="built_in">i32</span>,</span><br><span class="line">    instances: Range&lt;<span class="built_in">u32</span>&gt; <span class="comment">// &lt;-- This right here</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>The instances parameter takes a Range<u32>. This parameter tells the GPU how many copies, or instances, of our model we want to draw. Currently we are specifying 0..1, which instructs the GPU to draw our model once, and then stop. If we used 0..5, our code would draw 5 instances.</p>
<p>instances的参数为Range<u32>。此参数告诉GPU我们要绘制模型的多少副本或实例。目前我们正在指定0..1，它指示GPU绘制一次我们的模型，然后停止。如果我们使用0..5，我们的代码将绘制5个实例。</p>
<p>The fact that instances is a Range<u32> may seem weird as using 1..2 for instances would still draw 1 instance of our object. Seems like it would be simpler to just use a u32 right? The reason it’s a range is because sometimes we don’t want to draw all of our objects. Sometimes we want to draw a selection of them, because others are not in frame, or we are debugging and want to look at a particular set of instances.</p>
<p>instances是一个Range<u32>的事实可能看起来很奇怪，因为使用1..2 for instances仍然会绘制对象的一个实例。看起来使用u32会更简单，对吗？它是一个Range的原因是因为有时我们不想绘制所有的对象。有时，我们希望选择它们，因为其他的不在视野中，或者我们正在调试并希望查看一组特定的实例。</p>
<p>Ok, now we know how to draw multiple instances of an object, how do we tell wgpu what particular instance to draw? We are going to use something known as an instance buffer.</p>
<p>好的，现在我们知道了如何绘制一个对象的多个实例，我们如何告诉wgpu要绘制的特定实例？我们将使用实例缓冲区。</p>
<h1 id="The-Instance-Buffer"><a href="#The-Instance-Buffer" class="headerlink" title="The Instance Buffer"></a>The Instance Buffer</h1><p>We’ll create an instance buffer in a similar way to how we create a uniform buffer. First we’ll create a struct called Instance.</p>
<p>我们将以类似于创建uniform缓冲区的方式创建instance缓冲区。首先，我们将创建一个名为Instance的结构。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main.rs</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// NEW!</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Instance</span></span> &#123;</span><br><span class="line">    position: cgmath::Vector3&lt;<span class="built_in">f32</span>&gt;,</span><br><span class="line">    rotation: cgmath::Quaternion&lt;<span class="built_in">f32</span>&gt;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<div class="note">

<p>A Quaternion is a mathematical structure often used to represent rotation. The math behind them is beyond me (it involves imaginary numbers and 4D space) so I won’t be covering them here. If you really want to dive into them <a target="_blank" rel="noopener" href="https://mathworld.wolfram.com/Quaternion.html">here’s a Wolfram Alpha article</a>.</p>
<p>四元数是一种常用于表示旋转的数学结构。它们背后的数学是我无法理解的(它涉及虚数和4D空间)，所以我不会在这里讨论它们。如果你真的想深入了解它们，<a target="_blank" rel="noopener" href="https://mathworld.wolfram.com/Quaternion.html">这里有一篇Wolfram Alpha文章</a>。</p>
</div>

<p>Using these values directly in the shader would be a pain as quaternions don’t have a WGSL analog. I don’t feel like writing the math in the shader, so we’ll convert the Instance data into a matrix and store it into a struct called InstanceRaw.</p>
<p>直接在着色器中使用这些值会很痛苦，因为WGSL没有四元数模拟。我不想在着色器中编写数学，所以我们将实例数据转换为矩阵，并将其存储到名为InstanceRaw的结构中。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// NEW!</span></span><br><span class="line"><span class="meta">#[repr(C)]</span></span><br><span class="line"><span class="meta">#[derive(Copy, Clone, bytemuck::Pod, bytemuck::Zeroable)]</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">InstanceRaw</span></span> &#123;</span><br><span class="line">    model: [[<span class="built_in">f32</span>; <span class="number">4</span>]; <span class="number">4</span>],</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>This is the data that will go into the wgpu::Buffer. We keep these separate so that we can update the Instance as much as we want without needing to mess with matrices. We only need to update the raw data before we draw.</p>
<p>这是将进入wgpu::Buffer的数据。我们将它们分开，这样我们就可以随心所欲地更新实例，而无需弄乱矩阵。我们只需要在绘制之前更新原始数据。</p>
<p>Let’s create a method on Instance to convert to InstanceRaw.</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// NEW!</span></span><br><span class="line"><span class="keyword">impl</span> Instance &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">to_raw</span></span>(&amp;<span class="keyword">self</span>) -&gt; InstanceRaw &#123;</span><br><span class="line">        InstanceRaw &#123;</span><br><span class="line">            model: (cgmath::Matrix4::from_translation(<span class="keyword">self</span>.position) * cgmath::Matrix4::from(<span class="keyword">self</span>.rotation)).into(),</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Now we need to add 2 fields to State: instances, and instance_buffer.</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">State</span></span> &#123;</span><br><span class="line">    instances: <span class="built_in">Vec</span>&lt;Instance&gt;,</span><br><span class="line">    instance_buffer: wgpu::Buffer,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>We’ll create the instances in new(). We’ll use some constants to simplify things. We’ll display our instances in 10 rows of 10, and they’ll be spaced evenly apart.</p>
<p>我们将在new()中创建实例。我们将使用一些常量来简化事情。我们将以10行10列的形式显示我们的实例，并且它们将均匀地间隔开。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> NUM_INSTANCES_PER_ROW: <span class="built_in">u32</span> = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> NUM_INSTANCES: <span class="built_in">u32</span> = NUM_INSTANCES_PER_ROW * NUM_INSTANCES_PER_ROW;</span><br><span class="line"><span class="keyword">const</span> INSTANCE_DISPLACEMENT: cgmath::Vector3&lt;<span class="built_in">f32</span>&gt; = cgmath::Vector3::new(NUM_INSTANCES_PER_ROW <span class="keyword">as</span> <span class="built_in">f32</span> * <span class="number">0.5</span>, <span class="number">0.0</span>, NUM_INSTANCES_PER_ROW <span class="keyword">as</span> <span class="built_in">f32</span> * <span class="number">0.5</span>);</span><br></pre></td></tr></table></figure>

<p>Now we can create the actual instances.</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span> State &#123;</span><br><span class="line">    <span class="keyword">async</span> <span class="function"><span class="keyword">fn</span> <span class="title">new</span></span>(window: &amp;Window) -&gt; <span class="keyword">Self</span> &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="keyword">let</span> instances = (<span class="number">0</span>..NUM_INSTANCES_PER_ROW).flat_map(|z| &#123;</span><br><span class="line">            (<span class="number">0</span>..NUM_INSTANCES_PER_ROW).map(<span class="keyword">move</span> |x| &#123;</span><br><span class="line">                <span class="keyword">let</span> position = cgmath::Vector3 &#123; x: x <span class="keyword">as</span> <span class="built_in">f32</span>, y: <span class="number">0.0</span>, z: z <span class="keyword">as</span> <span class="built_in">f32</span> &#125; - INSTANCE_DISPLACEMENT;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">let</span> rotation = <span class="keyword">if</span> position.is_zero() &#123;</span><br><span class="line">                    <span class="comment">// this is needed so an object at (0, 0, 0) won&#x27;t get scaled to zero</span></span><br><span class="line">                    <span class="comment">// as Quaternions can effect scale if they&#x27;re not created correctly</span></span><br><span class="line">                    cgmath::Quaternion::from_axis_angle(cgmath::Vector3::unit_z(), cgmath::Deg(<span class="number">0.0</span>))</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    cgmath::Quaternion::from_axis_angle(position.normalize(), cgmath::Deg(<span class="number">45.0</span>))</span><br><span class="line">                &#125;;</span><br><span class="line"></span><br><span class="line">                Instance &#123;</span><br><span class="line">                    position, rotation,</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;).collect::&lt;<span class="built_in">Vec</span>&lt;_&gt;&gt;();</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Now that we have our data, we can create the actual instance_buffer.</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> instance_data = instances.iter().map(Instance::to_raw).collect::&lt;<span class="built_in">Vec</span>&lt;_&gt;&gt;();</span><br><span class="line"><span class="keyword">let</span> instance_buffer = device.create_buffer_init(</span><br><span class="line">    &amp;wgpu::util::BufferInitDescriptor &#123;</span><br><span class="line">        label: <span class="literal">Some</span>(<span class="string">&quot;Instance Buffer&quot;</span>),</span><br><span class="line">        contents: bytemuck::cast_slice(&amp;instance_data),</span><br><span class="line">        usage: wgpu::BufferUsage::VERTEX,</span><br><span class="line">    &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>We’re going to need to create a new VertexBufferLayout for InstanceRaw.</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span> InstanceRaw &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">desc</span></span>&lt;<span class="symbol">&#x27;a</span>&gt;() -&gt; wgpu::VertexBufferLayout&lt;<span class="symbol">&#x27;a</span>&gt; &#123;</span><br><span class="line">        <span class="keyword">use</span> std::mem;</span><br><span class="line">        wgpu::VertexBufferLayout &#123;</span><br><span class="line">            array_stride: mem::size_of::&lt;InstanceRaw&gt;() <span class="keyword">as</span> wgpu::BufferAddress,</span><br><span class="line">            <span class="comment">// We need to switch from using a step mode of Vertex to Instance</span></span><br><span class="line">            <span class="comment">// This means that our shaders will only change to use the next</span></span><br><span class="line">            <span class="comment">// instance when the shader starts processing a new instance</span></span><br><span class="line">            step_mode: wgpu::InputStepMode::Instance,</span><br><span class="line">            attributes: &amp;[</span><br><span class="line">                wgpu::VertexAttribute &#123;</span><br><span class="line">                    offset: <span class="number">0</span>,</span><br><span class="line">                    <span class="comment">// While our vertex shader only uses locations 0, and 1 now, in later tutorials we&#x27;ll</span></span><br><span class="line">                    <span class="comment">// be using 2, 3, and 4, for Vertex. We&#x27;ll start at slot 5 not conflict with them later</span></span><br><span class="line">                    shader_location: <span class="number">5</span>,</span><br><span class="line">                    format: wgpu::VertexFormat::Float32x4,</span><br><span class="line">                &#125;,</span><br><span class="line">                <span class="comment">// A mat4 takes up 4 vertex slots as it is technically 4 vec4s. We need to define a slot</span></span><br><span class="line">                <span class="comment">// for each vec4. We&#x27;ll have to reassemble the mat4 in</span></span><br><span class="line">                <span class="comment">// the shader.</span></span><br><span class="line">                wgpu::VertexAttribute &#123;</span><br><span class="line">                    offset: mem::size_of::&lt;[<span class="built_in">f32</span>; <span class="number">4</span>]&gt;() <span class="keyword">as</span> wgpu::BufferAddress,</span><br><span class="line">                    shader_location: <span class="number">6</span>,</span><br><span class="line">                    format: wgpu::VertexFormat::Float32x4,</span><br><span class="line">                &#125;,</span><br><span class="line">                wgpu::VertexAttribute &#123;</span><br><span class="line">                    offset: mem::size_of::&lt;[<span class="built_in">f32</span>; <span class="number">8</span>]&gt;() <span class="keyword">as</span> wgpu::BufferAddress,</span><br><span class="line">                    shader_location: <span class="number">7</span>,</span><br><span class="line">                    format: wgpu::VertexFormat::Float32x4,</span><br><span class="line">                &#125;,</span><br><span class="line">                wgpu::VertexAttribute &#123;</span><br><span class="line">                    offset: mem::size_of::&lt;[<span class="built_in">f32</span>; <span class="number">12</span>]&gt;() <span class="keyword">as</span> wgpu::BufferAddress,</span><br><span class="line">                    shader_location: <span class="number">8</span>,</span><br><span class="line">                    format: wgpu::VertexFormat::Float32x4,</span><br><span class="line">                &#125;,</span><br><span class="line">            ],</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>We need to add this descriptor to the render pipeline so that we can use it when we render.</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> render_pipeline = device.create_render_pipeline(&amp;wgpu::RenderPipelineDescriptor &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    vertex: wgpu::VertexState &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="comment">// UPDATED!</span></span><br><span class="line">        buffers: &amp;[Vertex::desc(), InstanceRaw::desc()],</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>Don’t forget to return our new variables!</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Self</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">// NEW!</span></span><br><span class="line">    instances,</span><br><span class="line">    instance_buffer,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>The last change we need to make is in the render() method. We need to bind our instance_buffer and we need to change the range we’re using in draw_indexed() to include the number of instances.</p>
<p>我们需要做的最后一个更改是render()方法。我们需要绑定实例缓冲区，并且需要更改在draw_indexed()中使用的范围，以包括实例数。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">render_pass.set_pipeline(&amp;<span class="keyword">self</span>.render_pipeline);</span><br><span class="line">render_pass.set_bind_group(<span class="number">0</span>, &amp;<span class="keyword">self</span>.diffuse_bind_group, &amp;[]);</span><br><span class="line">render_pass.set_bind_group(<span class="number">1</span>, &amp;<span class="keyword">self</span>.camera_bind_group, &amp;[]);</span><br><span class="line">render_pass.set_vertex_buffer(<span class="number">0</span>, <span class="keyword">self</span>.vertex_buffer.slice(..));</span><br><span class="line"><span class="comment">// NEW!</span></span><br><span class="line">render_pass.set_vertex_buffer(<span class="number">1</span>, <span class="keyword">self</span>.instance_buffer.slice(..));</span><br><span class="line">render_pass.set_index_buffer(<span class="keyword">self</span>.index_buffer.slice(..), wgpu::IndexFormat::Uint16);</span><br><span class="line"></span><br><span class="line"><span class="comment">// UPDATED!</span></span><br><span class="line">render_pass.draw_indexed(<span class="number">0</span>..<span class="keyword">self</span>.num_indices, <span class="number">0</span>, <span class="number">0</span>..<span class="keyword">self</span>.instances.len() <span class="keyword">as</span> _);</span><br></pre></td></tr></table></figure>

<div class="note">

<p>Make sure if you add new instances to the Vec, that you recreate the instance_buffer and as well as camera_bind_group, otherwise your new instances won’t show up correctly.</p>
<p>如果向Vec添加新实例，请确保重新创建instance_buffer和camera_bind_group，否则新实例将无法正确显示。</p>
</div>

<p>We need to reference the parts of our new matrix in shader.wgsl so that we can use it for our instances. Add the following to the top of shader.wgsl.</p>
<p>我们需要在shader.wgsl中引用新矩阵的部分，以便将其用于实例。将以下内容添加到shader.wgsl的顶部。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">InstanceInput</span></span> &#123;</span><br><span class="line">    [[location(<span class="number">5</span>)]] model_matrix_0: vec4&lt;<span class="built_in">f32</span>&gt;;</span><br><span class="line">    [[location(<span class="number">6</span>)]] model_matrix_1: vec4&lt;<span class="built_in">f32</span>&gt;;</span><br><span class="line">    [[location(<span class="number">7</span>)]] model_matrix_2: vec4&lt;<span class="built_in">f32</span>&gt;;</span><br><span class="line">    [[location(<span class="number">8</span>)]] model_matrix_3: vec4&lt;<span class="built_in">f32</span>&gt;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>We need to reassemble the matrix before we can use it.</p>
<p>我们需要重新组装矩阵才能使用它。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[[stage(vertex)]]</span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>(</span><br><span class="line">    model: VertexInput,</span><br><span class="line">    instance: InstanceInput,</span><br><span class="line">) -&gt; VertexOutput &#123;</span><br><span class="line">    <span class="keyword">let</span> model_matrix = mat4x4&lt;<span class="built_in">f32</span>&gt;(</span><br><span class="line">        instance.model_matrix_0,</span><br><span class="line">        instance.model_matrix_1,</span><br><span class="line">        instance.model_matrix_2,</span><br><span class="line">        instance.model_matrix_3,</span><br><span class="line">    );</span><br><span class="line">    <span class="comment">// Continued...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>We’ll apply the model_matrix before we apply camera_uniform.view_proj. We do this because the camera_uniform.view_proj changes the coordinate system from world space to camera space. Our model_matrix is a world space transformation, so we don’t want to be in camera space when using it.</p>
<p>在应用camera_uniform.view_proj项目之前，我们将应用model_matrix。我们这样做是因为camera_uniform.view_proj将坐标系从世界空间更改为camera空间。我们的model_matrix是一个世界空间变换，所以我们不希望在使用它时处于摄影机空间。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[[stage(vertex)]]</span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>(</span><br><span class="line">    model: VertexInput,</span><br><span class="line">    instance: InstanceInput,</span><br><span class="line">) -&gt; VertexOutput &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    var out: VertexOutput;</span><br><span class="line">    out.tex_coords = model.tex_coords;</span><br><span class="line">    out.clip_position = camera.view_proj * model_matrix * vec4&lt;<span class="built_in">f32</span>&gt;(model.position, <span class="number">1.0</span>);</span><br><span class="line">    <span class="keyword">return</span> out;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>With all that done, we should have a forest of trees!</p>
<p><img src="https://sotrh.github.io/learn-wgpu/assets/img/forest.5c5cf3ad.png" alt="trees"></p>
<h1 id="Challenge"><a href="#Challenge" class="headerlink" title="Challenge"></a>Challenge</h1><p>Modify the position and/or rotation of the instances every frame.</p>
<p><a target="_blank" rel="noopener" href="https://github.com/sotrh/learn-wgpu/tree/master/code/beginner/tutorial7-instancing/">Check out the code!</a></p>

    </div>

    
    
    
        

<div>
<ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>本文作者： </strong>qianqians
  </li>
  <li class="post-copyright-link">
    <strong>本文链接：</strong>
    <a href="https://qianqians.github.io/2021/09/02/Wgpu%20Instancing/" title="Wgpu Instancing">https://qianqians.github.io/2021/09/02/Wgpu Instancing/</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/zh-CN" rel="noopener" target="_blank"><i class="fa fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！
  </li>
</ul>
</div>


      <footer class="post-footer">

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2021/09/01/Wgpu%20Uniform%20buffers%20and%20a%203d%20camera/" rel="prev" title="Wgpu Uniform buffers and a 3d camera">
      <i class="fa fa-chevron-left"></i> Wgpu Uniform buffers and a 3d camera
    </a></div>
      <div class="post-nav-item">
    <a href="/2021/09/03/Wgpu%20The%20Depth%20Buffer/" rel="next" title="Wgpu The Depth Buffer">
      Wgpu The Depth Buffer <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">qianqians</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>

<script src="/js/bookmark.js"></script>




  















  

  

</body>
</html>
