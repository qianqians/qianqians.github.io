<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">
  <link rel="manifest" href="/images/manifest.json">
  <meta name="msapplication-config" content="/images/browserconfig.xml">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">
<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"qianqians.github.io","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"remove","padding":18,"offset":12,"onmobile":true},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":true,"scrollpercent":true},"bookmark":{"enable":true,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="Up to this point we have been drawing super simple shapes. While we can make a game with just triangles, trying to draw highly detailed objects would massively limit what devices could even run our ga">
<meta property="og:type" content="article">
<meta property="og:title" content="Wgpu Textures and bind groups">
<meta property="og:url" content="https://qianqians.github.io/2021/08/25/Wgpu%20Textures%20and%20bind%20groups/index.html">
<meta property="og:site_name" content="qianqians&#39;blog">
<meta property="og:description" content="Up to this point we have been drawing super simple shapes. While we can make a game with just triangles, trying to draw highly detailed objects would massively limit what devices could even run our ga">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://sotrh.github.io/learn-wgpu/assets/img/happy-tree.bdff8a19.png">
<meta property="og:image" content="https://sotrh.github.io/learn-wgpu/assets/img/address_mode.66a7cd1a.png">
<meta property="og:image" content="https://sotrh.github.io/learn-wgpu/assets/img/upside-down.d50c3643.png">
<meta property="og:image" content="https://sotrh.github.io/learn-wgpu/assets/img/happy-tree-uv-coords.aa3b7d36.png">
<meta property="og:image" content="https://sotrh.github.io/learn-wgpu/assets/img/rightside-up.75f852e2.png">
<meta property="article:published_time" content="2021-08-25T06:55:56.257Z">
<meta property="article:modified_time" content="2021-08-26T07:50:42.897Z">
<meta property="article:author" content="qianqians">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://sotrh.github.io/learn-wgpu/assets/img/happy-tree.bdff8a19.png">

<link rel="canonical" href="https://qianqians.github.io/2021/08/25/Wgpu%20Textures%20and%20bind%20groups/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>Wgpu Textures and bind groups | qianqians'blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">qianqians'blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档<span class="badge">29</span></a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>分类<span class="badge">6</span></a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-fw fa-user"></i>关于</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <a role="button" class="book-mark-link book-mark-link-fixed"></a>

  <a href="https://github.com/qianqians" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://qianqians.github.io/2021/08/25/Wgpu%20Textures%20and%20bind%20groups/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="qianqians">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="qianqians'blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Wgpu Textures and bind groups
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-08-25 14:55:56" itemprop="dateCreated datePublished" datetime="2021-08-25T14:55:56+08:00">2021-08-25</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-08-26 15:50:42" itemprop="dateModified" datetime="2021-08-26T15:50:42+08:00">2021-08-26</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Wgpu/" itemprop="url" rel="index"><span itemprop="name">Wgpu</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>Up to this point we have been drawing super simple shapes. While we can make a game with just triangles, trying to draw highly detailed objects would massively limit what devices could even run our game. However, we can get around this problem with textures.</p>
<p>到目前为止，我们一直在画超级简单的形状。虽然我们可以制作一个只有三角形的游戏，但尝试绘制高度详细的对象将极大地限制哪些设备甚至可以运行我们的游戏。然而，我们可以通过纹理来解决这个问题。</p>
<p>Textures are images overlayed on a triangle mesh to make it seem more detailed. There are multiple types of textures such as normal maps, bump maps, specular maps and diffuse maps. We’re going to talk about diffuse maps, or more simply, the color texture.</p>
<p>纹理是叠加在三角形网格上的图像，使其看起来更详细。有多种类型的纹理，例如法线贴图、凹凸贴图、镜面反射贴图和漫反射贴图。我们将讨论漫反射贴图，或者更简单地说，颜色纹理。</p>
<h1 id="Loading-an-image-from-a-file"><a href="#Loading-an-image-from-a-file" class="headerlink" title="Loading an image from a file"></a>Loading an image from a file</h1><p>If we want to map an image to our mesh, we first need an image. Let’s use this happy little tree:</p>
<p>如果要将图像映射到网格，首先需要一个图像。让我们用这棵快乐的小树：</p>
<p><img src="https://sotrh.github.io/learn-wgpu/assets/img/happy-tree.bdff8a19.png" alt="小树"></p>
<p>We’ll use the image crate to load our tree. We already added to our dependencies in the first section, so all we have to do is use it.</p>
<p>我们将使用image crate来装载我们的树。我们已经在第一节中添加了依赖项，所以我们所要做的就是使用它。</p>
<p>In State’s new() method add the following just after creating the swap_chain:</p>
<p>在State的new()方法中，在创建swap_chain之后添加以下内容：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> swap_chain = device.create_swap_chain(&amp;surface, &amp;sc_desc);</span><br><span class="line"><span class="comment">// NEW!</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> diffuse_bytes = include_bytes!(<span class="string">&quot;happy-tree.png&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> diffuse_image = image::load_from_memory(diffuse_bytes).unwrap();</span><br><span class="line"><span class="keyword">let</span> diffuse_rgba = diffuse_image.as_rgba8().unwrap();</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> image::GenericImageView;</span><br><span class="line"><span class="keyword">let</span> dimensions = diffuse_image.dimensions();</span><br></pre></td></tr></table></figure>

<p>Here we grab the bytes from our image file and load them into an image which is then converted into a Vec of rgba bytes. We also save the image’s dimensions for when we create the actual Texture.</p>
<p>在这里，我们从图像文件中获取bytes，并将它们加载到图像中，然后将图像转换为rgba字节的Vec。我们还保存图像的尺寸，以便在创建实际纹理时使用。</p>
<p>Now, let’s create the Texture:</p>
<p>现在，让我们创建纹理：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> texture_size = wgpu::Extent3d &#123;</span><br><span class="line">    width: dimensions.<span class="number">0</span>,</span><br><span class="line">    height: dimensions.<span class="number">1</span>,</span><br><span class="line">    depth_or_array_layers: <span class="number">1</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> diffuse_texture = device.create_texture(</span><br><span class="line">    &amp;wgpu::TextureDescriptor &#123;</span><br><span class="line">        <span class="comment">// All textures are stored as 3D, we represent our 2D texture</span></span><br><span class="line">        <span class="comment">// by setting depth to 1.</span></span><br><span class="line">        size: texture_size,</span><br><span class="line">        mip_level_count: <span class="number">1</span>, <span class="comment">// We&#x27;ll talk about this a little later</span></span><br><span class="line">        sample_count: <span class="number">1</span>,</span><br><span class="line">        dimension: wgpu::TextureDimension::D2,</span><br><span class="line">        <span class="comment">// Most images are stored using sRGB so we need to reflect that here.</span></span><br><span class="line">        format: wgpu::TextureFormat::Rgba8UnormSrgb,</span><br><span class="line">        <span class="comment">// SAMPLED tells wgpu that we want to use this texture in shaders</span></span><br><span class="line">        <span class="comment">// COPY_DST means that we want to copy data to this texture</span></span><br><span class="line">        usage: wgpu::TextureUsage::SAMPLED | wgpu::TextureUsage::COPY_DST,</span><br><span class="line">        label: <span class="literal">Some</span>(<span class="string">&quot;diffuse_texture&quot;</span>),</span><br><span class="line">    &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<h1 id="Getting-data-into-a-Texture"><a href="#Getting-data-into-a-Texture" class="headerlink" title="Getting data into a Texture"></a>Getting data into a Texture</h1><p>The Texture struct has no methods to interact with the data directly. However, we can use a method on the queue we created earlier called write_texture to load the texture in. Let’s take a look at how we do that:</p>
<p>纹理结构没有直接与数据交互的方法。但是，我们可以在前面创建的队列上使用一个名为write_texture的方法来加载纹理。让我们来看看我们是如何做到这一点的：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">queue.write_texture(</span><br><span class="line">    <span class="comment">// Tells wgpu where to copy the pixel data</span></span><br><span class="line">    wgpu::ImageCopyTexture &#123;</span><br><span class="line">        texture: &amp;diffuse_texture,</span><br><span class="line">        mip_level: <span class="number">0</span>,</span><br><span class="line">        origin: wgpu::Origin3d::ZERO,</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// The actual pixel data</span></span><br><span class="line">    diffuse_rgba,</span><br><span class="line">    <span class="comment">// The layout of the texture</span></span><br><span class="line">    wgpu::ImageDataLayout &#123;</span><br><span class="line">        offset: <span class="number">0</span>,</span><br><span class="line">        bytes_per_row: std::num::NonZeroU32::new(<span class="number">4</span> * dimensions.<span class="number">0</span>),</span><br><span class="line">        rows_per_image: std::num::NonZeroU32::new(dimensions.<span class="number">1</span>),</span><br><span class="line">    &#125;,</span><br><span class="line">    texture_size,</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<dic class="note">

<p>The old way of writing data to a texture was to copy the pixel data to a buffer and then copy it to the texture. Using write_texture is a bit more efficient as it uses one less buffer - I’ll leave it here though in case you need it.</p>
<p>将数据写入纹理的旧方法是将像素数据复制到缓冲区，然后将其复制到纹理。使用write_texture更有效，因为它使用的缓冲区少了一个，不过我会把它放在这里，以备您需要。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> buffer = device.create_buffer_init(</span><br><span class="line">    &amp;wgpu::util::BufferInitDescriptor &#123;</span><br><span class="line">        label: <span class="literal">Some</span>(<span class="string">&quot;Temp Buffer&quot;</span>),</span><br><span class="line">        contents: &amp;diffuse_rgba,</span><br><span class="line">        usage: wgpu::BufferUsage::COPY_SRC,</span><br><span class="line">    &#125;</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut</span> encoder = device.create_command_encoder(&amp;wgpu::CommandEncoderDescriptor &#123;</span><br><span class="line">    label: <span class="literal">Some</span>(<span class="string">&quot;texture_buffer_copy_encoder&quot;</span>),</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">encoder.copy_buffer_to_texture(</span><br><span class="line">    wgpu::ImageCopyBuffer &#123;</span><br><span class="line">        buffer: &amp;buffer,</span><br><span class="line">        offset: <span class="number">0</span>,</span><br><span class="line">        bytes_per_row: <span class="number">4</span> * dimensions.<span class="number">0</span>,</span><br><span class="line">        rows_per_image: dimensions.<span class="number">1</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    wgpu::ImageCopyTexture &#123;</span><br><span class="line">        texture: &amp;diffuse_texture,</span><br><span class="line">        mip_level: <span class="number">0</span>,</span><br><span class="line">        array_layer: <span class="number">0</span>,</span><br><span class="line">        origin: wgpu::Origin3d::ZERO,</span><br><span class="line">    &#125;,</span><br><span class="line">    size,</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">queue.submit(std::iter::once(encoder.finish()));</span><br></pre></td></tr></table></figure>

<p>The bytes_per_row field needs some consideration. This value needs to be a multiple of 256. Check out the gif tutorial for more details.</p>
<p>每行字节数字段需要考虑。此值必须是256的倍数。有关详细信息，请查看gif教程。</p>
</div>

<h1 id="TextureViews-and-Samplers"><a href="#TextureViews-and-Samplers" class="headerlink" title="TextureViews and Samplers"></a>TextureViews and Samplers</h1><p>Now that our texture has data in it, we need a way to use it. This is where a TextureView and a Sampler come in. A TextureView offers us a view into our texture. A Sampler controls how the Texture is sampled. Sampling works similar to the eyedropper tool in GIMP/Photoshop. Our program supplies a coordinate on the texture (known as a texture coordinate), and the sampler then returns the corresponding color based on the texture and some internal parameters.</p>
<p>既然我们的纹理中有数据，我们需要一种使用它的方法。这就是TextureView和采样器的作用。纹理视图为我们提供了纹理视图。采样器控制纹理的采样方式。采样的工作原理类似于GIMP/Photoshop中的滴管工具。我们的程序在纹理上提供一个坐标(称为纹理坐标)，然后采样器根据纹理和一些内部参数返回相应的颜色。</p>
<p>Let’s define our diffuse_texture_view and diffuse_sampler now:</p>
<p>现在让我们定义diffuse_texture_view和diffuse_sampler：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// We don&#x27;t need to configure the texture view much, so let&#x27;s</span></span><br><span class="line"><span class="comment">// let wgpu define it.</span></span><br><span class="line"><span class="keyword">let</span> diffuse_texture_view = diffuse_texture.create_view(&amp;wgpu::TextureViewDescriptor::default());</span><br><span class="line"><span class="keyword">let</span> diffuse_sampler = device.create_sampler(&amp;wgpu::SamplerDescriptor &#123;</span><br><span class="line">    address_mode_u: wgpu::AddressMode::ClampToEdge,</span><br><span class="line">    address_mode_v: wgpu::AddressMode::ClampToEdge,</span><br><span class="line">    address_mode_w: wgpu::AddressMode::ClampToEdge,</span><br><span class="line">    mag_filter: wgpu::FilterMode::Linear,</span><br><span class="line">    min_filter: wgpu::FilterMode::Nearest,</span><br><span class="line">    mipmap_filter: wgpu::FilterMode::Nearest,</span><br><span class="line">    ..<span class="built_in">Default</span>::default()</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>The address_mode_* parameters determine what to do if the sampler gets a texture coordinate that’s outside of the texture itself. We have a few options to choose from:</p>
<p>address_mode_*参数决定了如果采样器获得的纹理坐标位于纹理本身之外，该怎么办。我们有几个选项可供选择：</p>
<ul>
<li>ClampToEdge: Any texture coordinates outside the texture will return the color of the nearest pixel on the edges of the texture.</li>
<li>Repeat: The texture will repeat as texture coordinates exceed the textures dimensions.</li>
<li>MirrorRepeat: Similar to Repeat, but the image will flip when going over boundaries.</li>
</ul>
<div></div>

<ul>
<li>ClampToEdge：纹理外部的任何纹理坐标都将返回纹理边缘上最近像素的颜色。</li>
<li>Repeat：纹理坐标超过纹理尺寸时，纹理将重复。</li>
<li>MirrorRepeat: 与“重复”类似，但图像在越过边界时将翻转。</li>
</ul>
<p><img src="https://sotrh.github.io/learn-wgpu/assets/img/address_mode.66a7cd1a.png" alt="sampler"></p>
<p>The mag_filter and min_filter options describe what to do when a fragment covers multiple pixels, or there are multiple fragments for a single pixel. This often comes into play when viewing a surface from up close, or from far away.</p>
<p>mag_filter和min_filter选项描述了当一个片段覆盖多个像素，或者一个像素有多个片段时该怎么做。这通常在从近距离或远处查看曲面时起作用。</p>
<p>There are 2 options:</p>
<p>有两种选择：</p>
<ul>
<li>Linear: Attempt to blend the in-between fragments so that they seem to flow together.</li>
<li>Nearest: In-between fragments will use the color of the nearest pixel. This creates an image that’s crisper from far away, but pixelated up close. This can be desirable, however, if your textures are designed to be pixelated, like in pixel art games, or voxel games like Minecraft.</li>
</ul>
<div></div>

<ul>
<li>Linear: 尝试将片段混合在一起，使它们看起来是一起流动的。</li>
<li>Nearest: 在片段之间，将使用最近像素的颜色。这将创建一个从远处看更清晰的图像，但在近距离内像素化。然而，如果你的纹理被设计成像素化，比如像素艺术游戏，或者像Minecraft这样的体素游戏，这可能是可取的。</li>
</ul>
<p>Mipmaps are a complex topic, and will require their own section in the future. For now, we can say that mipmap_filter functions similar to (mag/min)_filter as it tells the sampler how to blend between mipmaps.</p>
<p>mipmap是一个复杂的主题，将来需要的部分讨论。现在，我们可以说mipmap_filter的功能类似于(mag/min)_filter，因为它告诉采样器如何在mipmap之间混合。</p>
<p>I’m using some defaults for the other fields. If you want to see what they are, check <a target="_blank" rel="noopener" href="https://docs.rs/wgpu/0.7.0/wgpu/struct.SamplerDescriptor.html">the wgpu docs</a>.</p>
<p>我对其他字段使用了一些默认值。如果您想查看它们是什么，请查看<a target="_blank" rel="noopener" href="https://docs.rs/wgpu/0.7.0/wgpu/struct.SamplerDescriptor.html">wgpu文档</a>。</p>
<p>All these different resources are nice and all, but they don’t do us much good if we can’t plug them in anywhere. This is where BindGroups and PipelineLayouts come in.</p>
<p>所有这些不同的资源都很好，但是如果我们不能在任何地方插入它们，它们对我们没有多大好处。这就是BindGroups和PipelineLayouts的用武之地。</p>
<h1 id="The-BindGroup"><a href="#The-BindGroup" class="headerlink" title="The BindGroup"></a>The BindGroup</h1><p>A BindGroup describes a set of resources and how they can be accessed by a shader. We create a BindGroup using a BindGroupLayout. Let’s make one of those first.</p>
<p>BindGroup描述一组资源以及着色器如何访问这些资源。我们使用BindGroupLayout创建一个BindGroup。让我们先做一个。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> texture_bind_group_layout = device.create_bind_group_layout(</span><br><span class="line">    &amp;wgpu::BindGroupLayoutDescriptor &#123;</span><br><span class="line">        entries: &amp;[</span><br><span class="line">            wgpu::BindGroupLayoutEntry &#123;</span><br><span class="line">                binding: <span class="number">0</span>,</span><br><span class="line">                visibility: wgpu::ShaderStage::FRAGMENT,</span><br><span class="line">                ty: wgpu::BindingType::Texture &#123;</span><br><span class="line">                    multisampled: <span class="literal">false</span>,</span><br><span class="line">                    view_dimension: wgpu::TextureViewDimension::D2,</span><br><span class="line">                    sample_type: wgpu::TextureSampleType::Float &#123; filterable: <span class="literal">true</span> &#125;,</span><br><span class="line">                &#125;,</span><br><span class="line">                count: <span class="literal">None</span>,</span><br><span class="line">            &#125;,</span><br><span class="line">            wgpu::BindGroupLayoutEntry &#123;</span><br><span class="line">                binding: <span class="number">1</span>,</span><br><span class="line">                visibility: wgpu::ShaderStage::FRAGMENT,</span><br><span class="line">                ty: wgpu::BindingType::Sampler &#123;</span><br><span class="line">                    <span class="comment">// This is only for TextureSampleType::Depth</span></span><br><span class="line">                    comparison: <span class="literal">false</span>,</span><br><span class="line">                    <span class="comment">// This should be true if the sample_type of the texture is:</span></span><br><span class="line">                    <span class="comment">//     TextureSampleType::Float &#123; filterable: true &#125;</span></span><br><span class="line">                    <span class="comment">// Otherwise you&#x27;ll get an error.</span></span><br><span class="line">                    filtering: <span class="literal">true</span>,</span><br><span class="line">                &#125;,</span><br><span class="line">                count: <span class="literal">None</span>,</span><br><span class="line">            &#125;,</span><br><span class="line">        ],</span><br><span class="line">        label: <span class="literal">Some</span>(<span class="string">&quot;texture_bind_group_layout&quot;</span>),</span><br><span class="line">    &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>Our texture_bind_group_layout has two entries: one for a sampled texture at binding 0, and one for a sampler at binding 1. Both of these bindings are visible only to the fragment shader as specified by FRAGMENT. The possible values for this field are any bitwise combination of NONE, VERTEX, FRAGMENT, or COMPUTE. Most of the time we’ll only use FRAGMENT for textures and samplers, but it’s good to know what else is available.</p>
<p>我们的texture_bind_group_layout有两个条目：一个用于绑定0处的sampled texture，另一个用于绑定1处的sampler。这两个绑定仅对片段指定的片段着色器可见。visibility字段的可能值是NONE、VERTEX、FRAGMENT或COMPUTE的任意位组合。大多数情况下，我们只会对片段使用纹理和采样器，但最好知道还有什么可用的。</p>
<p>With texture_bind_group_layout, we can now create our BindGroup:</p>
<p>使用texture_bind_group_layout，我们现在可以创建BindGroup：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> diffuse_bind_group = device.create_bind_group(</span><br><span class="line">    &amp;wgpu::BindGroupDescriptor &#123;</span><br><span class="line">        layout: &amp;texture_bind_group_layout,</span><br><span class="line">        entries: &amp;[</span><br><span class="line">            wgpu::BindGroupEntry &#123;</span><br><span class="line">                binding: <span class="number">0</span>,</span><br><span class="line">                resource: wgpu::BindingResource::TextureView(&amp;diffuse_texture_view),</span><br><span class="line">            &#125;,</span><br><span class="line">            wgpu::BindGroupEntry &#123;</span><br><span class="line">                binding: <span class="number">1</span>,</span><br><span class="line">                resource: wgpu::BindingResource::Sampler(&amp;diffuse_sampler),</span><br><span class="line">            &#125;</span><br><span class="line">        ],</span><br><span class="line">        label: <span class="literal">Some</span>(<span class="string">&quot;diffuse_bind_group&quot;</span>),</span><br><span class="line">    &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>Looking at this you might get a bit of déjà vu! That’s because a BindGroup is a more specific declaration of the BindGroupLayout. The reason why they’re separate is it allows us to swap out BindGroups on the fly, so long as they all share the same BindGroupLayout. Each texture and sampler we create will need to be added to a BindGroup. For our purposes, we’ll create a new bind group for each texture.</p>
<p>看看这个，你可能会有点似曾相识！这是因为BindGroup是BindGroupLayout的更具体的声明。它们分开的原因是它允许我们动态地交换BindGroups，只要它们都共享相同的BindGroupLayout。我们创建的每个纹理和采样器都需要添加到BindGroup中。出于我们的目的，我们将为每个纹理创建一个新的绑定组。</p>
<p>Now that we have our diffuse_bind_group, let’s add it to our State struct:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">State</span></span> &#123;</span><br><span class="line">    surface: wgpu::Surface,</span><br><span class="line">    device: wgpu::Device,</span><br><span class="line">    queue: wgpu::Queue,</span><br><span class="line">    sc_desc: wgpu::SwapChainDescriptor,</span><br><span class="line">    swap_chain: wgpu::SwapChain,</span><br><span class="line">    size: winit::dpi::PhysicalSize&lt;<span class="built_in">u32</span>&gt;,</span><br><span class="line">    render_pipeline: wgpu::RenderPipeline,</span><br><span class="line">    vertex_buffer: wgpu::Buffer,</span><br><span class="line">    index_buffer: wgpu::Buffer,</span><br><span class="line">    num_indicies: <span class="built_in">u32</span>,</span><br><span class="line">    diffuse_bind_group: wgpu::BindGroup, <span class="comment">// NEW!</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>And make sure we return these fields in the new method:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span> State &#123;</span><br><span class="line">    <span class="keyword">async</span> <span class="function"><span class="keyword">fn</span> <span class="title">new</span></span>() -&gt; <span class="keyword">Self</span> &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="keyword">Self</span> &#123;</span><br><span class="line">            surface,</span><br><span class="line">            device,</span><br><span class="line">            queue,</span><br><span class="line">            sc_desc,</span><br><span class="line">            swap_chain,</span><br><span class="line">            size,</span><br><span class="line">            render_pipeline,</span><br><span class="line">            vertex_buffer,</span><br><span class="line">            index_buffer,</span><br><span class="line">            num_indices,</span><br><span class="line">            <span class="comment">// NEW!</span></span><br><span class="line">            diffuse_bind_group,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Now that we’ve got our BindGroup, we can use it in our render() function.</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// render()</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">render_pass.set_pipeline(&amp;<span class="keyword">self</span>.render_pipeline);</span><br><span class="line">render_pass.set_bind_group(<span class="number">0</span>, &amp;<span class="keyword">self</span>.diffuse_bind_group, &amp;[]); <span class="comment">// NEW!</span></span><br><span class="line">render_pass.set_vertex_buffer(<span class="number">0</span>, <span class="keyword">self</span>.vertex_buffer.slice(..));</span><br><span class="line">render_pass.set_index_buffer(<span class="keyword">self</span>.index_buffer.slice(..), wgpu::IndexFormat::Uint16);</span><br><span class="line"></span><br><span class="line">render_pass.draw_indexed(<span class="number">0</span>..<span class="keyword">self</span>.num_indices, <span class="number">0</span>, <span class="number">0</span>..<span class="number">1</span>);</span><br></pre></td></tr></table></figure>

<h1 id="PipelineLayout"><a href="#PipelineLayout" class="headerlink" title="PipelineLayout"></a>PipelineLayout</h1><p>Remember the PipelineLayout we created back in the pipeline section? Now we finally get to use it! The PipelineLayout contains a list of BindGroupLayouts that the pipeline can use. Modify render_pipeline_layout to use our texture_bind_group_layout.</p>
<p>还记得我们在管道部分创建的PipelineLayout吗？现在我们终于可以使用它了！PipelineLayout包含pipeline可以使用的BindGroupLayouts列表。修改render_pipeline_layout以使用texture_bind_group_layout。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">fn</span> <span class="title">new</span></span>(...) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">let</span> render_pipeline_layout = device.create_pipeline_layout(</span><br><span class="line">        &amp;wgpu::PipelineLayoutDescriptor &#123;</span><br><span class="line">            label: <span class="literal">Some</span>(<span class="string">&quot;Render Pipeline Layout&quot;</span>), <span class="comment">// NEW!</span></span><br><span class="line">            bind_group_layouts: &amp;[&amp;texture_bind_group_layout], <span class="comment">// NEW!</span></span><br><span class="line">            push_constant_ranges: &amp;[],</span><br><span class="line">        &#125;</span><br><span class="line">    );</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="A-change-to-the-VERTICES"><a href="#A-change-to-the-VERTICES" class="headerlink" title="A change to the VERTICES"></a>A change to the VERTICES</h1><p>There’s a few things we need to change about our Vertex definition. Up to now we’ve been using a color attribute to set the color of our mesh. Now that we’re using a texture, we want to replace our color with tex_coords. These coordinates will then be passed to the Sampler to retrieve the appropriate color.</p>
<p>关于顶点定义，我们需要更改一些内容。到目前为止，我们一直在使用颜色属性来设置网格的颜色。现在我们正在使用纹理，我们想用tex_coords替换我们的颜色。然后，这些坐标将传递给采样器以检索适当的颜色。</p>
<p>Since our tex_coords are two dimensional, we’ll change the field to take two floats instead of three.</p>
<p>由于tex_coords是二维的，因此我们将字段更改为采用两个浮点数，而不是三个浮点数。</p>
<p>First, we’ll change the Vertex struct:</p>
<p>首先，我们将更改顶点结构：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[repr(C)]</span></span><br><span class="line"><span class="meta">#[derive(Copy, Clone, Debug, bytemuck::Pod, bytemuck::Zeroable)]</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Vertex</span></span> &#123;</span><br><span class="line">    position: [<span class="built_in">f32</span>; <span class="number">3</span>],</span><br><span class="line">    tex_coords: [<span class="built_in">f32</span>; <span class="number">2</span>], <span class="comment">// NEW!</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>And then reflect these changes in the VertexBufferLayout:</p>
<p>然后在VertexBufferLayout中反映这些更改：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span> Vertex &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">desc</span></span>&lt;<span class="symbol">&#x27;a</span>&gt;() -&gt; wgpu::VertexBufferLayout&lt;<span class="symbol">&#x27;a</span>&gt; &#123;</span><br><span class="line">        <span class="keyword">use</span> std::mem;</span><br><span class="line">        wgpu::VertexBufferLayout &#123;</span><br><span class="line">            array_stride: mem::size_of::&lt;Vertex&gt;() <span class="keyword">as</span> wgpu::BufferAddress,</span><br><span class="line">            step_mode: wgpu::InputStepMode::Vertex,</span><br><span class="line">            attributes: &amp;[</span><br><span class="line">                wgpu::VertexAttribute &#123;</span><br><span class="line">                    offset: <span class="number">0</span>,</span><br><span class="line">                    shader_location: <span class="number">0</span>,</span><br><span class="line">                    format: wgpu::VertexFormat::Float32x3,</span><br><span class="line">                &#125;,</span><br><span class="line">                wgpu::VertexAttribute &#123;</span><br><span class="line">                    offset: mem::size_of::&lt;[<span class="built_in">f32</span>; <span class="number">3</span>]&gt;() <span class="keyword">as</span> wgpu::BufferAddress,</span><br><span class="line">                    shader_location: <span class="number">1</span>,</span><br><span class="line">                    format: wgpu::VertexFormat::Float32x2, <span class="comment">// NEW!</span></span><br><span class="line">                &#125;,</span><br><span class="line">            ]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Lastly we need to change VERTICES itself. Replace the existing definition with the following:</p>
<p>最后，我们需要改变顶点本身。将现有定义替换为以下内容：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Changed</span></span><br><span class="line"><span class="keyword">const</span> VERTICES: &amp;[Vertex] = &amp;[</span><br><span class="line">    Vertex &#123; position: [-<span class="number">0.0868241</span>, <span class="number">0.49240386</span>, <span class="number">0.0</span>], tex_coords: [<span class="number">0.4131759</span>, <span class="number">0.99240386</span>], &#125;, <span class="comment">// A</span></span><br><span class="line">    Vertex &#123; position: [-<span class="number">0.49513406</span>, <span class="number">0.06958647</span>, <span class="number">0.0</span>], tex_coords: [<span class="number">0.0048659444</span>, <span class="number">0.56958646</span>], &#125;, <span class="comment">// B</span></span><br><span class="line">    Vertex &#123; position: [-<span class="number">0.21918549</span>, -<span class="number">0.44939706</span>, <span class="number">0.0</span>], tex_coords: [<span class="number">0.28081453</span>, <span class="number">0.050602943</span>], &#125;, <span class="comment">// C</span></span><br><span class="line">    Vertex &#123; position: [<span class="number">0.35966998</span>, -<span class="number">0.3473291</span>, <span class="number">0.0</span>], tex_coords: [<span class="number">0.85967</span>, <span class="number">0.15267089</span>], &#125;, <span class="comment">// D</span></span><br><span class="line">    Vertex &#123; position: [<span class="number">0.44147372</span>, <span class="number">0.2347359</span>, <span class="number">0.0</span>], tex_coords: [<span class="number">0.9414737</span>, <span class="number">0.7347359</span>], &#125;, <span class="comment">// E</span></span><br><span class="line">];</span><br></pre></td></tr></table></figure>

<h1 id="Shader-time"><a href="#Shader-time" class="headerlink" title="Shader time"></a>Shader time</h1><p>With our new Vertex structure in place it’s time to update our shaders. We’ll first need to pass our tex_coords into the vertex shader and then use them over to our fragment shader to get the final color from the Sampler. Let’s start with the vertex shader:</p>
<p>随着新顶点结构的就位，是时候更新着色器了。我们首先需要将tex_coords传递到顶点着色器，然后将它们传递到片段着色器，以从采样器获得最终颜色。让我们从顶点着色器开始：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Vertex shader</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">VertexInput</span></span> &#123;</span><br><span class="line">    [[location(<span class="number">0</span>)]] position: vec3&lt;<span class="built_in">f32</span>&gt;;</span><br><span class="line">    [[location(<span class="number">1</span>)]] tex_coords: vec2&lt;<span class="built_in">f32</span>&gt;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">VertexOutput</span></span> &#123;</span><br><span class="line">    [[builtin(position)]] clip_position: vec4&lt;<span class="built_in">f32</span>&gt;;</span><br><span class="line">    [[location(<span class="number">0</span>)]] tex_coords: vec2&lt;<span class="built_in">f32</span>&gt;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">[[stage(vertex)]]</span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>(</span><br><span class="line">    model: VertexInput,</span><br><span class="line">) -&gt; VertexOutput &#123;</span><br><span class="line">    var out: VertexOutput;</span><br><span class="line">    out.tex_coords = model.tex_coords;</span><br><span class="line">    out.clip_position = vec4&lt;<span class="built_in">f32</span>&gt;(model.position, <span class="number">1.0</span>);</span><br><span class="line">    <span class="keyword">return</span> out;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Now that we have our vertex shader outputting our tex_coords, we need to change the fragment shader to take them in. With these coordinates, we’ll finally be able to use our sampler to get a color from our texture.</p>
<p>现在我们已经有了顶点着色器输出tex_coords，我们需要更改片段着色器以接收它们。有了这些坐标，我们最终可以使用采样器从纹理中获取颜色。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Fragment shader</span></span><br><span class="line"></span><br><span class="line">[[group(<span class="number">0</span>), binding(<span class="number">0</span>)]]</span><br><span class="line">var t_diffuse: texture_2d&lt;<span class="built_in">f32</span>&gt;;</span><br><span class="line">[[group(<span class="number">0</span>), binding(<span class="number">1</span>)]]</span><br><span class="line">var s_diffuse: sampler;</span><br><span class="line"></span><br><span class="line">[[stage(fragment)]]</span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>(<span class="keyword">in</span>: VertexOutput) -&gt; [[location(<span class="number">0</span>)]] vec4&lt;<span class="built_in">f32</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> textureSample(t_diffuse, s_diffuse, <span class="keyword">in</span>.tex_coords);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>The variables t_diffuse and s_diffuse are what’s known as uniforms. We’ll go over uniforms more in the cameras section. For now, all we need to know is that group() corresponds to the 1st parameter in set_bind_group() and binding() relates to the binding specified when we created the BindGroupLayout and BindGroup.</p>
<p>变量t_diffuse和s_diffuse称为uniforms。我们将在照相机部分详细介绍uniforms。现在，我们只需要知道group()对应于set_bind_group()中的第一个参数，binding()与创建BindGroupLayout和BindGroup时指定的绑定相关。</p>
<h1 id="The-results"><a href="#The-results" class="headerlink" title="The results"></a>The results</h1><p>If we run our program now we should get the following result:</p>
<p><img src="https://sotrh.github.io/learn-wgpu/assets/img/upside-down.d50c3643.png" alt="result"></p>
<p>That’s weird, our tree is upside down! This is because wgpu’s world coordinates have the y-axis pointing up, while texture coordinates have the y-axis pointing down. In other words, (0, 0) in texture coordinates coresponds to the top-left of the image, while (1, 1) is the bottom right.</p>
<p>真奇怪，我们的树倒了！这是因为wgpu的世界坐标的y轴指向上，而纹理坐标的y轴指向下。换句话说，纹理坐标中的（0，0）对应于图像的左上角，而（1，1）对应于右下角。</p>
<p><img src="https://sotrh.github.io/learn-wgpu/assets/img/happy-tree-uv-coords.aa3b7d36.png" alt="纹理"></p>
<p>We can get our triangle right-side up by inverting the y coordinate of each texture coordinate:</p>
<p>通过反转每个纹理坐标的y坐标，我们可以使三角形正面朝上：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> VERTICES: &amp;[Vertex] = &amp;[</span><br><span class="line">    <span class="comment">// Changed</span></span><br><span class="line">    Vertex &#123; position: [-<span class="number">0.0868241</span>, <span class="number">0.49240386</span>, <span class="number">0.0</span>], tex_coords: [<span class="number">0.4131759</span>, <span class="number">0.00759614</span>], &#125;, <span class="comment">// A</span></span><br><span class="line">    Vertex &#123; position: [-<span class="number">0.49513406</span>, <span class="number">0.06958647</span>, <span class="number">0.0</span>], tex_coords: [<span class="number">0.0048659444</span>, <span class="number">0.43041354</span>], &#125;, <span class="comment">// B</span></span><br><span class="line">    Vertex &#123; position: [-<span class="number">0.21918549</span>, -<span class="number">0.44939706</span>, <span class="number">0.0</span>], tex_coords: [<span class="number">0.28081453</span>, <span class="number">0.949397</span>], &#125;, <span class="comment">// C</span></span><br><span class="line">    Vertex &#123; position: [<span class="number">0.35966998</span>, -<span class="number">0.3473291</span>, <span class="number">0.0</span>], tex_coords: [<span class="number">0.85967</span>, <span class="number">0.84732914</span>], &#125;, <span class="comment">// D</span></span><br><span class="line">    Vertex &#123; position: [<span class="number">0.44147372</span>, <span class="number">0.2347359</span>, <span class="number">0.0</span>], tex_coords: [<span class="number">0.9414737</span>, <span class="number">0.2652641</span>], &#125;, <span class="comment">// E</span></span><br><span class="line">];</span><br></pre></td></tr></table></figure>

<p>With that in place, we now have our tree right-side up on our hexagon:</p>
<p>有了它，我们的树就在六边形的正确位置：</p>
<p><img src="https://sotrh.github.io/learn-wgpu/assets/img/rightside-up.75f852e2.png" alt="纹理"></p>
<h1 id="Cleaning-things-up"><a href="#Cleaning-things-up" class="headerlink" title="Cleaning things up"></a>Cleaning things up</h1><p>For convenience sake, let’s pull our texture code into its module. We’ll first need to add the anyhow crate to our Cargo.toml file to simplify error handling;</p>
<p>为了方便起见，让我们将纹理代码拉入其模块。我们首先需要将anyhow crate添加到Cargo.toml文件中，以简化错误处理；</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[dependencies]</span><br><span class="line">image = <span class="string">&quot;0.23&quot;</span></span><br><span class="line">cgmath = <span class="string">&quot;0.18&quot;</span></span><br><span class="line">winit = <span class="string">&quot;0.25&quot;</span></span><br><span class="line">env_logger = <span class="string">&quot;0.9&quot;</span></span><br><span class="line">log = <span class="string">&quot;0.4&quot;</span></span><br><span class="line">pollster = <span class="string">&quot;0.2&quot;</span></span><br><span class="line">wgpu = <span class="string">&quot;0.9&quot;</span></span><br><span class="line">bytemuck = &#123; version = <span class="string">&quot;1.4&quot;</span>, features = [ <span class="string">&quot;derive&quot;</span> ] &#125;</span><br><span class="line">anyhow = <span class="string">&quot;1.0&quot;</span> <span class="comment">// NEW!</span></span><br></pre></td></tr></table></figure>

<p>Then, in a new file called src/texture.rs, add the following:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> image::GenericImageView;</span><br><span class="line"><span class="keyword">use</span> anyhow::*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">Texture</span></span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> texture: wgpu::Texture,</span><br><span class="line">    <span class="keyword">pub</span> view: wgpu::TextureView,</span><br><span class="line">    <span class="keyword">pub</span> sampler: wgpu::Sampler,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> Texture &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">from_bytes</span></span>(</span><br><span class="line">        device: &amp;wgpu::Device,</span><br><span class="line">        queue: &amp;wgpu::Queue,</span><br><span class="line">        bytes: &amp;[<span class="built_in">u8</span>], </span><br><span class="line">        label: &amp;<span class="built_in">str</span></span><br><span class="line">    ) -&gt; <span class="built_in">Result</span>&lt;<span class="keyword">Self</span>&gt; &#123;</span><br><span class="line">        <span class="keyword">let</span> img = image::load_from_memory(bytes)?;</span><br><span class="line">        Self::from_image(device, queue, &amp;img, <span class="literal">Some</span>(label))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">from_image</span></span>(</span><br><span class="line">        device: &amp;wgpu::Device,</span><br><span class="line">        queue: &amp;wgpu::Queue,</span><br><span class="line">        img: &amp;image::DynamicImage,</span><br><span class="line">        label: <span class="built_in">Option</span>&lt;&amp;<span class="built_in">str</span>&gt;</span><br><span class="line">    ) -&gt; <span class="built_in">Result</span>&lt;<span class="keyword">Self</span>&gt; &#123;</span><br><span class="line">        <span class="keyword">let</span> rgba = img.as_rgba8().unwrap();</span><br><span class="line">        <span class="keyword">let</span> dimensions = img.dimensions();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> size = wgpu::Extent3d &#123;</span><br><span class="line">            width: dimensions.<span class="number">0</span>,</span><br><span class="line">            height: dimensions.<span class="number">1</span>,</span><br><span class="line">            depth_or_array_layers: <span class="number">1</span>,</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">let</span> texture = device.create_texture(</span><br><span class="line">            &amp;wgpu::TextureDescriptor &#123;</span><br><span class="line">                label,</span><br><span class="line">                size,</span><br><span class="line">                mip_level_count: <span class="number">1</span>,</span><br><span class="line">                sample_count: <span class="number">1</span>,</span><br><span class="line">                dimension: wgpu::TextureDimension::D2,</span><br><span class="line">                format: wgpu::TextureFormat::Rgba8UnormSrgb,</span><br><span class="line">                usage: wgpu::TextureUsage::SAMPLED | wgpu::TextureUsage::COPY_DST,</span><br><span class="line">            &#125;</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        queue.write_texture(</span><br><span class="line">            wgpu::ImageCopyTexture &#123;</span><br><span class="line">                texture: &amp;texture,</span><br><span class="line">                mip_level: <span class="number">0</span>,</span><br><span class="line">                origin: wgpu::Origin3d::ZERO,</span><br><span class="line">            &#125;,</span><br><span class="line">            rgba,</span><br><span class="line">            wgpu::ImageDataLayout &#123;</span><br><span class="line">                offset: <span class="number">0</span>,</span><br><span class="line">                bytes_per_row: std::num::NonZeroU32::new(<span class="number">4</span> * dimensions.<span class="number">0</span>),</span><br><span class="line">                rows_per_image: std::num::NonZeroU32::new(dimensions.<span class="number">1</span>),</span><br><span class="line">            &#125;,</span><br><span class="line">            size,</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> view = texture.create_view(&amp;wgpu::TextureViewDescriptor::default());</span><br><span class="line">        <span class="keyword">let</span> sampler = device.create_sampler(</span><br><span class="line">            &amp;wgpu::SamplerDescriptor &#123;</span><br><span class="line">                address_mode_u: wgpu::AddressMode::ClampToEdge,</span><br><span class="line">                address_mode_v: wgpu::AddressMode::ClampToEdge,</span><br><span class="line">                address_mode_w: wgpu::AddressMode::ClampToEdge,</span><br><span class="line">                mag_filter: wgpu::FilterMode::Linear,</span><br><span class="line">                min_filter: wgpu::FilterMode::Nearest,</span><br><span class="line">                mipmap_filter: wgpu::FilterMode::Nearest,</span><br><span class="line">                ..<span class="built_in">Default</span>::default()</span><br><span class="line">            &#125;</span><br><span class="line">        );</span><br><span class="line">        </span><br><span class="line">        <span class="literal">Ok</span>(<span class="keyword">Self</span> &#123; texture, view, sampler &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Note that we’re returning a CommandBuffer with our texture. This means we can load multiple textures at the same time, and then submit all their command buffers at once.</p>
<p>请注意，我们返回CommandBuffer使用纹理。这意味着我们可以同时加载多个纹理，然后一次提交它们的所有命令缓冲区。</p>
<p>We need to import texture.rs as a module, so somewhere at the top of main.rs add the following.</p>
<p>我们需要将texture.rs作为一个模块导入，因此在main.rs顶部的某处添加以下内容。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mod</span> texture;</span><br></pre></td></tr></table></figure>

<p>The texture creation code in new() now gets a lot simpler:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> swap_chain = device.create_swap_chain(&amp;surface, &amp;sc_desc);</span><br><span class="line"><span class="keyword">let</span> diffuse_bytes = include_bytes!(<span class="string">&quot;happy-tree.png&quot;</span>); <span class="comment">// CHANGED!</span></span><br><span class="line"><span class="keyword">let</span> diffuse_texture = texture::Texture::from_bytes(&amp;device, &amp;queue, diffuse_bytes, <span class="string">&quot;happy-tree.png&quot;</span>).unwrap(); <span class="comment">// CHANGED!</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Everything up until `let texture_bind_group_layout = ...` can now be removed.</span></span><br></pre></td></tr></table></figure>

<p>We still need to store the bind group separately so that Texture doesn’t need know how the BindGroup is laid out. Creating the diffuse_bind_group changes slightly to use the view and sampler fields of our diffuse_texture:</p>
<p>我们仍然需要单独存储bind group，这样纹理就不需要知道BindGroup是如何布置的。创建diffuse_bind_group时会稍微更改，以使用diffuse_texture的view和sampler字段：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> diffuse_bind_group = device.create_bind_group(</span><br><span class="line">    &amp;wgpu::BindGroupDescriptor &#123;</span><br><span class="line">        layout: &amp;texture_bind_group_layout,</span><br><span class="line">        entries: &amp;[</span><br><span class="line">            wgpu::BindGroupEntry &#123;</span><br><span class="line">                binding: <span class="number">0</span>,</span><br><span class="line">                resource: wgpu::BindingResource::TextureView(&amp;diffuse_texture.view), <span class="comment">// CHANGED!</span></span><br><span class="line">            &#125;,</span><br><span class="line">            wgpu::BindGroupEntry &#123;</span><br><span class="line">                binding: <span class="number">1</span>,</span><br><span class="line">                resource: wgpu::BindingResource::Sampler(&amp;diffuse_texture.sampler), <span class="comment">// CHANGED!</span></span><br><span class="line">            &#125;</span><br><span class="line">        ],</span><br><span class="line">        label: <span class="literal">Some</span>(<span class="string">&quot;diffuse_bind_group&quot;</span>),</span><br><span class="line">    &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>Finally, let’s update our State field to use our shiny new Texture struct, as we’ll need it in future tutorials.</p>
<p>最后，让我们更新State字段以使用闪亮的新纹理结构，因为我们将在未来的教程中需要它。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">State</span></span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    diffuse_bind_group: wgpu::BindGroup,</span><br><span class="line">    diffuse_texture: texture::Texture, <span class="comment">// NEW</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span> State &#123;</span><br><span class="line">    <span class="keyword">async</span> <span class="function"><span class="keyword">fn</span> <span class="title">new</span></span>() -&gt; <span class="keyword">Self</span> &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="keyword">Self</span> &#123;</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">            num_indices,</span><br><span class="line">            diffuse_bind_group,</span><br><span class="line">            diffuse_texture, <span class="comment">// NEW</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Phew!</p>
<p>With these changes in place, the code should be working the same as it was before, but we now have a much easier way to create textures.</p>
<p>有了这些更改，代码应该和以前一样工作，但是我们现在有了一种更简单的方法来创建纹理。</p>
<h1 id="Challenge"><a href="#Challenge" class="headerlink" title="Challenge"></a>Challenge</h1><p>创建另一个纹理，并在按空格键时将其调出。</p>
<p><a target="_blank" rel="noopener" href="https://github.com/sotrh/learn-wgpu/tree/master/code/beginner/tutorial5-textures/">Check out the code!</a></p>

    </div>

    
    
    
        

<div>
<ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>本文作者： </strong>qianqians
  </li>
  <li class="post-copyright-link">
    <strong>本文链接：</strong>
    <a href="https://qianqians.github.io/2021/08/25/Wgpu%20Textures%20and%20bind%20groups/" title="Wgpu Textures and bind groups">https://qianqians.github.io/2021/08/25/Wgpu Textures and bind groups/</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/zh-CN" rel="noopener" target="_blank"><i class="fa fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！
  </li>
</ul>
</div>


      <footer class="post-footer">

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2021/08/24/Wgpu%20Buffers%20and%20Indices/" rel="prev" title="Wgpu Buffers and Indices">
      <i class="fa fa-chevron-left"></i> Wgpu Buffers and Indices
    </a></div>
      <div class="post-nav-item">
    <a href="/2021/09/01/Wgpu%20Uniform%20buffers%20and%20a%203d%20camera/" rel="next" title="Wgpu Uniform buffers and a 3d camera">
      Wgpu Uniform buffers and a 3d camera <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">qianqians</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>

<script src="/js/bookmark.js"></script>




  















  

  

</body>
</html>
