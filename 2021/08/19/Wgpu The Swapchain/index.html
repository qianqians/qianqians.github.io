<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">
  <link rel="manifest" href="/images/manifest.json">
  <meta name="msapplication-config" content="/images/browserconfig.xml">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">
<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"qianqians.github.io","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"remove","padding":18,"offset":12,"onmobile":true},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":true,"scrollpercent":true},"bookmark":{"enable":true,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="First, some house keeping: StateFor convenience we’re going to pack all the fields into a struct, and create some methods on that. 为了方便起见，我们将把所有字段打包到一个结构中，并在此基础上创建一些方法。 1234567891011121314151617181920">
<meta property="og:type" content="article">
<meta property="og:title" content="Wgpu The Swapchain">
<meta property="og:url" content="https://qianqians.github.io/2021/08/19/Wgpu%20The%20Swapchain/index.html">
<meta property="og:site_name" content="qianqians&#39;blog">
<meta property="og:description" content="First, some house keeping: StateFor convenience we’re going to pack all the fields into a struct, and create some methods on that. 为了方便起见，我们将把所有字段打包到一个结构中，并在此基础上创建一些方法。 1234567891011121314151617181920">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2021-08-19T08:08:20.377Z">
<meta property="article:modified_time" content="2021-08-24T08:28:42.118Z">
<meta property="article:author" content="qianqians">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://qianqians.github.io/2021/08/19/Wgpu%20The%20Swapchain/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>Wgpu The Swapchain | qianqians'blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">qianqians'blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档<span class="badge">43</span></a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>分类<span class="badge">10</span></a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-fw fa-user"></i>关于</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <a role="button" class="book-mark-link book-mark-link-fixed"></a>

  <a href="https://github.com/qianqians" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://qianqians.github.io/2021/08/19/Wgpu%20The%20Swapchain/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="qianqians">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="qianqians'blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Wgpu The Swapchain
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-08-19 16:08:20" itemprop="dateCreated datePublished" datetime="2021-08-19T16:08:20+08:00">2021-08-19</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-08-24 16:28:42" itemprop="dateModified" datetime="2021-08-24T16:28:42+08:00">2021-08-24</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Wgpu/" itemprop="url" rel="index"><span itemprop="name">Wgpu</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="First-some-house-keeping-State"><a href="#First-some-house-keeping-State" class="headerlink" title="First, some house keeping: State"></a>First, some house keeping: State</h1><p>For convenience we’re going to pack all the fields into a struct, and create some methods on that.</p>
<p>为了方便起见，我们将把所有字段打包到一个结构中，并在此基础上创建一些方法。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main.rs</span></span><br><span class="line"><span class="keyword">use</span> winit::window::Window;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">State</span></span> &#123;</span><br><span class="line">    surface: wgpu::Surface,</span><br><span class="line">    device: wgpu::Device,</span><br><span class="line">    queue: wgpu::Queue,</span><br><span class="line">    sc_desc: wgpu::SwapChainDescriptor,</span><br><span class="line">    swap_chain: wgpu::SwapChain,</span><br><span class="line">    size: winit::dpi::PhysicalSize&lt;<span class="built_in">u32</span>&gt;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> State &#123;</span><br><span class="line">    <span class="comment">// Creating some of the wgpu types requires async code</span></span><br><span class="line">    <span class="keyword">async</span> <span class="function"><span class="keyword">fn</span> <span class="title">new</span></span>(window: &amp;Window) -&gt; <span class="keyword">Self</span> &#123;</span><br><span class="line">        todo!()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">resize</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, new_size: winit::dpi::PhysicalSize&lt;<span class="built_in">u32</span>&gt;) &#123;</span><br><span class="line">        todo!()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">input</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, event: &amp;WindowEvent) -&gt; <span class="built_in">bool</span> &#123;</span><br><span class="line">        todo!()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">update</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) &#123;</span><br><span class="line">        todo!()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">render</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) -&gt; <span class="built_in">Result</span>&lt;(), wgpu::SwapChainError&gt; &#123;</span><br><span class="line">        todo!()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>I’m glossing over States fields, but they’ll make more sense as I explain the code behind the methods.</p>
<p>我对States字段进行了润色，但当我解释方法背后的代码时，它们会更有意义。</p>
<h1 id="State-new"><a href="#State-new" class="headerlink" title="State::new()"></a>State::new()</h1><p>The code for this is pretty straight forward, but let’s break this down a bit.</p>
<p>这方面的代码非常简单，但是让我们把它分解一下。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span> State &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">async</span> <span class="function"><span class="keyword">fn</span> <span class="title">new</span></span>(window: &amp;Window) -&gt; <span class="keyword">Self</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> size = window.inner_size();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// The instance is a handle to our GPU</span></span><br><span class="line">        <span class="comment">// BackendBit::PRIMARY =&gt; Vulkan + Metal + DX12 + Browser WebGPU</span></span><br><span class="line">        <span class="keyword">let</span> instance = wgpu::Instance::new(wgpu::BackendBit::PRIMARY);</span><br><span class="line">        <span class="keyword">let</span> surface = <span class="keyword">unsafe</span> &#123; instance.create_surface(window) &#125;;</span><br><span class="line">        <span class="keyword">let</span> adapter = instance.request_adapter(</span><br><span class="line">            &amp;wgpu::RequestAdapterOptions &#123;</span><br><span class="line">                power_preference: wgpu::PowerPreference::default(),</span><br><span class="line">                compatible_surface: <span class="literal">Some</span>(&amp;surface),</span><br><span class="line">            &#125;,</span><br><span class="line">        ).<span class="keyword">await</span>.unwrap();</span><br></pre></td></tr></table></figure>

<p>The surface is used to create the swap_chain. Our window needs to implement raw-window-handle’s HasRawWindowHandle trait to access the native window implementation for wgpu to properly create the graphics backend. Fortunately, winit’s Window fits the bill. We also need it to request our adapter.</p>
<p>surface用于创建swap_chain。我们的窗口需要实现原始raw-window-handle’s HasRawWindowHandle特性，以便wgpu访问本机窗口实现，从而正确创建图形后端。幸运的是，winit的窗口符合要求。我们还需要它来请求适配器。</p>
<blockquote>
<p>The options I’ve passed to request_adapter aren’t guaranteed to work for all devices, but will work for most of them. If you want to get all adapters for a particular backend you can use enumerate_adapters. This will give you an iterator that you can loop over to check if one of the adapters works for your needs.<br>我传递给request_adapter的选项不能保证对所有设备都有效，但对大多数设备都有效。如果要获取特定后端的所有适配器，可以使用enumerate_adapters。这将为您提供一个迭代器，您可以循环检查其中一个适配器是否满足您的需要。</p>
</blockquote>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> adapter = instance</span><br><span class="line">   .enumerate_adapters(wgpu::BackendBit::PRIMARY)</span><br><span class="line">   .filter(|adapter| &#123;</span><br><span class="line">       <span class="comment">// Check if this adapter supports our surface</span></span><br><span class="line">       adapter.get_swap_chain_preferred_format(&amp;surface).is_some()</span><br><span class="line">   &#125;)</span><br><span class="line">   .first()</span><br><span class="line">   .unwrap()</span><br></pre></td></tr></table></figure>

<blockquote>
<p>For more fields you can use to refine you’re search check out the docs.<br>有关可用于优化搜索的更多字段，<a target="_blank" rel="noopener" href="https://docs.rs/wgpu/0.9.0/wgpu/struct.Adapter.html">请查看文档</a></p>
</blockquote>
<p>We need the adapter to create the device and queue.<br>我们需要适配器来创建设备和队列。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> (device, queue) = adapter.request_device(</span><br><span class="line">    &amp;wgpu::DeviceDescriptor &#123;</span><br><span class="line">        features: wgpu::Features::empty(),</span><br><span class="line">        limits: wgpu::Limits::default(),</span><br><span class="line">        label: <span class="literal">None</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="literal">None</span>, <span class="comment">// Trace path</span></span><br><span class="line">).<span class="keyword">await</span>.unwrap();</span><br></pre></td></tr></table></figure>
<p>The features field on DeviceDescriptor, allows us to specify what extra features we want. For this simple example, I’ve decided not to use any extra features.<br>DeviceDescriptor上的features字段允许我们指定所需的额外功能。对于这个简单的例子，我决定不使用任何额外的特性。</p>
<blockquote>
<p>The device you have limits the features you can use. If you want to use certain features you may need to limit what devices you support, or provide work arounds.<br>You can get a list of features supported by your device using adapter.features(), or device.features().<br>You can view a full list of features here.</p>
</blockquote>
<blockquote>
<p>您拥有的设备限制了您可以使用的功能。如果您想使用某些功能，您可能需要限制您支持的设备，或提供解决方案。<br>您可以使用adapter.features（）或device.features（）获取设备支持的功能列表。<br>您可以在此处查看功能的<a target="_blank" rel="noopener" href="https://docs.rs/wgpu/0.9.0/wgpu/struct.Features.html">完整列表</a>。</p>
</blockquote>
<p>The limits field describes the limit of certain types of resource we can create. We’ll use the defaults for this tutorial, so we can support most devices. You can view a list of limits here.</p>
<p>limits字段描述了我们可以创建的特定类型资源的限制。本教程将使用默认设置，因此我们可以支持大多数设备。您可以在此处查看<a target="_blank" rel="noopener" href="https://docs.rs/wgpu/0.9.0/wgpu/struct.Limits.html">limits列表</a>。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> sc_desc = wgpu::SwapChainDescriptor &#123;</span><br><span class="line">    usage: wgpu::TextureUsage::RENDER_ATTACHMENT,</span><br><span class="line">    format: adapter.get_swap_chain_preferred_format(&amp;surface).unwrap(),</span><br><span class="line">    width: size.width,</span><br><span class="line">    height: size.height,</span><br><span class="line">    present_mode: wgpu::PresentMode::Fifo,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> swap_chain = device.create_swap_chain(&amp;surface, &amp;sc_desc);</span><br></pre></td></tr></table></figure>

<p>Here we are defining and creating the swap_chain. The usage field describes how the swap_chain’s underlying textures will be used. RENDER_ATTACHMENT specifies that the textures will be used to write to the screen (we’ll talk about more TextureUsages later).</p>
<p>这里我们定义并创建swap_chain。usage字段描述如何使用swap_chain的基础纹理。RENDER_ATTACHMENT指定纹理将用于写入屏幕（稍后我们将讨论更多纹理图像）。</p>
<p>The format defines how the swap_chains textures will be stored on the gpu. Different displays prefer different formats. We use adapter.get_swap_chain_preferred_format() to figure out the best format to use.</p>
<p>该格式定义如何将swap_chains纹理存储在gpu上。不同的显示器喜欢不同的格式。我们使用adapter.get_swap_chain_preferred_format()来找出最佳的使用格式。</p>
<p>width and height, are the width and height in pixels of the swap chain. This should usually be the width and height of the window.</p>
<p>宽度和高度是swap_chain的宽度和高度(以像素为单位)。这通常应该是窗口的宽度和高度。</p>
<p>The present_mode uses the wgpu::PresentMode enum which determines how to sync the swap chain with the display. You can see all the options in the docs</p>
<p>当前模式使用wgpu::PresentMode枚举，该枚举确定如何将swap_chain与显示同步。您可以在文档中看到<a target="_blank" rel="noopener" href="https://docs.rs/wgpu/0.9.0/wgpu/enum.PresentMode.html">所有选项</a></p>
<p>At the end of the method, we simply return the resulting struct.</p>
<p>在方法的末尾，我们只返回结构体结果。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">        <span class="keyword">Self</span> &#123;</span><br><span class="line">            surface,</span><br><span class="line">            device,</span><br><span class="line">            queue,</span><br><span class="line">            sc_desc,</span><br><span class="line">            swap_chain,</span><br><span class="line">            size,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>We’ll want to call this in our main method before we enter the event loop.</p>
<p>在进入事件循环之前，我们希望在main方法中调用它。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Since main can&#x27;t be async, we&#x27;re going to need to block</span></span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut</span> state = pollster::block_on(State::new(&amp;window));</span><br></pre></td></tr></table></figure>

<blockquote>
<p>You can use heavier libraries like async_std and tokio to make main async, so you can await futures. I’ve elected not to use these crates as this tutorial is not about writing an async application, and the futures created by wgpu do not require special executor support. We just need some way to interact with wgpu’s async functions, and the pollster crate is enough for that.</p>
</blockquote>
<blockquote>
<p>您可以使用较重的库（如async_std和tokio）来实现main函数异步，因此您可以等待futures。我选择不使用这些crates，因为本教程不是关于编写异步应用程序的，而且wgpu创建的crates不需要特殊的执行器支持。我们只需要一些与wgpu的异步函数交互的方法，the pollster crate就足够了。</p>
</blockquote>
<h1 id="resize"><a href="#resize" class="headerlink" title="resize()"></a>resize()</h1><p>If we want to support resizing in our application, we’re going to need to recreate the swap_chain everytime the window’s size changes. That’s the reason we stored the physical size and the sc_desc used to create the swapchain. With all of these, the resize method is very simple.</p>
<p>如果我们想在应用程序中支持调整大小，我们需要在每次窗口大小更改时重新创建swap_chain。这就是我们存储用于创建swap_chain的物理大小和sc_desc的原因。有了所有这些，调整大小的方法非常简单。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// impl State</span></span><br><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">resize</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, new_size: winit::dpi::PhysicalSize&lt;<span class="built_in">u32</span>&gt;) &#123;</span><br><span class="line">    <span class="keyword">if</span> new_size.width &gt; <span class="number">0</span> &amp;&amp; new_size.height &gt; <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.size = new_size;</span><br><span class="line">        <span class="keyword">self</span>.sc_desc.width = new_size.width;</span><br><span class="line">        <span class="keyword">self</span>.sc_desc.height = new_size.height;</span><br><span class="line">        <span class="keyword">self</span>.swap_chain = <span class="keyword">self</span>.device.create_swap_chain(&amp;<span class="keyword">self</span>.surface, &amp;<span class="keyword">self</span>.sc_desc);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>There’s nothing really different here from creating the swap_chain initially, so I won’t get into it.</p>
<p>这里与最初创建swap_chain没有什么不同，所以我就不谈了。</p>
<p>We call this method in main() in the event loop for the following events.</p>
<p>对于以下事件，我们在main函数的事件循环的中调用此方法。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">match</span> event &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">if</span> window_id == window.id() =&gt; <span class="keyword">if</span> !state.input(event) &#123;</span><br><span class="line">        <span class="keyword">match</span> event &#123;</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">            WindowEvent::Resized(physical_size) =&gt; &#123;</span><br><span class="line">                state.resize(*physical_size);</span><br><span class="line">            &#125;</span><br><span class="line">            WindowEvent::ScaleFactorChanged &#123; new_inner_size, .. &#125; =&gt; &#123;</span><br><span class="line">                <span class="comment">// new_inner_size is &amp;&amp;mut so we have to dereference it twice</span></span><br><span class="line">                state.resize(**new_inner_size);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="input"><a href="#input" class="headerlink" title="input()"></a>input()</h1><p>input() returns a bool to indicate whether an event has been fully processed. If the method returns true, the main loop won’t process the event any further.</p>
<p>input函数返回一个bool以指示事件是否已被完全处理。如果该方法返回true，则主循环将不再进一步处理该事件。</p>
<p>We’re just going to return false for now because we don’t have any events we want to capture.</p>
<p>我们现在只返回false，因为我们没有任何要捕获的事件。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// impl State</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">input</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, event: &amp;WindowEvent) -&gt; <span class="built_in">bool</span> &#123;</span><br><span class="line">    <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>We need to do a little more work in the event loop. We want State to have priority over main(). Doing that (and previous changes) should have your loop looking like this.</p>
<p>我们需要在事件循环中做更多的工作。我们希望State优先于main（）。这样做（以及之前的更改）应该使循环看起来像这样。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main()</span></span><br><span class="line">event_loop.run(<span class="keyword">move</span> |event, _, control_flow| &#123;</span><br><span class="line">    <span class="keyword">match</span> event &#123;</span><br><span class="line">        Event::WindowEvent &#123;</span><br><span class="line">            <span class="keyword">ref</span> event,</span><br><span class="line">            window_id,</span><br><span class="line">        &#125; <span class="keyword">if</span> window_id == window.id() =&gt; <span class="keyword">if</span> !state.input(event) &#123; <span class="comment">// UPDATED!</span></span><br><span class="line">            <span class="keyword">match</span> event &#123;</span><br><span class="line">                WindowEvent::CloseRequested</span><br><span class="line">                | WindowEvent::KeyboardInput &#123;</span><br><span class="line">                    input:</span><br><span class="line">                        KeyboardInput &#123;</span><br><span class="line">                            state: ElementState::Pressed,</span><br><span class="line">                            virtual_keycode: <span class="literal">Some</span>(VirtualKeyCode::Escape),</span><br><span class="line">                            ..</span><br><span class="line">                        &#125;,</span><br><span class="line">                    ..</span><br><span class="line">                &#125; =&gt; *control_flow = ControlFlow::Exit,</span><br><span class="line">                WindowEvent::Resized(physical_size) =&gt; &#123;</span><br><span class="line">                    state.resize(*physical_size);</span><br><span class="line">                &#125;</span><br><span class="line">                WindowEvent::ScaleFactorChanged &#123; new_inner_size, .. &#125; =&gt; &#123;</span><br><span class="line">                    state.resize(**new_inner_size);</span><br><span class="line">                &#125;</span><br><span class="line">                _ =&gt; &#123;&#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        _ =&gt; &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h1 id="update"><a href="#update" class="headerlink" title="update()"></a>update()</h1><p>We don’t have anything to update yet, so leave the method empty.</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">update</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) &#123;</span><br><span class="line">    <span class="comment">// remove `todo!()`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="render"><a href="#render" class="headerlink" title="render()"></a>render()</h1><p>Here’s where the magic happens. First we need to get a frame to render to. This will include a wgpu::Texture and wgpu::TextureView that will hold the actual image we’re drawing to (we’ll cover this more when we talk about textures).</p>
<p>这就是魔法发生的地方。首先，我们需要得到一个帧来渲染。这将包括wgpu:：Texture和wgpu:：TextureView，它们将保存我们正在绘制的实际图像（我们将在讨论纹理时详细介绍这一点）。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// impl State</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">render</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) -&gt; <span class="built_in">Result</span>&lt;(), wgpu::SwapChainError&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> frame = <span class="keyword">self</span></span><br><span class="line">        .swap_chain</span><br><span class="line">        .get_current_frame()?</span><br><span class="line">        .output;</span><br></pre></td></tr></table></figure>

<p>We also need to create a CommandEncoder to create the actual commands to send to the gpu. Most modern graphics frameworks expect commands to be stored in a command buffer before being sent to the gpu. The encoder builds a command buffer that we can then send to the gpu.</p>
<p>我们还需要创建CommandEncoder来创建发送到gpu的实际命令。大多数现代图形框架都希望命令在发送到gpu之前存储在命令缓冲区中。编码器构建一个命令缓冲区，然后我们可以将其发送到gpu。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut</span> encoder = <span class="keyword">self</span>.device.create_command_encoder(&amp;wgpu::CommandEncoderDescriptor &#123;</span><br><span class="line">    label: <span class="literal">Some</span>(<span class="string">&quot;Render Encoder&quot;</span>),</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>Now we can actually get to clearing the screen (long time coming). We need to use the encoder to create a RenderPass. The RenderPass has all the methods to do the actual drawing. The code for creating a RenderPass is a bit nested, so I’ll copy it all here, and talk about the pieces.</p>
<p>现在我们可以开始清理屏幕了（很长一段时间就要到了）。我们需要使用编码器来创建一个RenderPass。RenderPass具有进行实际绘制的所有方法。创建RenderPass的代码有点嵌套，所以我将在这里全部复制，并讨论各个部分。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">let</span> _render_pass = encoder.begin_render_pass(&amp;wgpu::RenderPassDescriptor &#123;</span><br><span class="line">            label: <span class="literal">Some</span>(<span class="string">&quot;Render Pass&quot;</span>),</span><br><span class="line">            color_attachments: &amp;[</span><br><span class="line">                wgpu::RenderPassColorAttachment &#123;</span><br><span class="line">                    view: &amp;frame.view,</span><br><span class="line">                    resolve_target: <span class="literal">None</span>,</span><br><span class="line">                    ops: wgpu::Operations &#123;</span><br><span class="line">                        load: wgpu::LoadOp::Clear(wgpu::Color &#123;</span><br><span class="line">                            r: <span class="number">0.1</span>,</span><br><span class="line">                            g: <span class="number">0.2</span>,</span><br><span class="line">                            b: <span class="number">0.3</span>,</span><br><span class="line">                            a: <span class="number">1.0</span>,</span><br><span class="line">                        &#125;),</span><br><span class="line">                        store: <span class="literal">true</span>,</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            ],</span><br><span class="line">            depth_stencil_attachment: <span class="literal">None</span>,</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// submit will accept anything that implements IntoIter</span></span><br><span class="line">    <span class="keyword">self</span>.queue.submit(std::iter::once(encoder.finish()));</span><br><span class="line"></span><br><span class="line">    <span class="literal">Ok</span>(())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>First things first, let’s talk about the {}. encoder.begin_render_pass(…) borrows encoder mutably (aka &amp;mut self). We can’t call encoder.finish() until we release that mutable borrow. The {} around encoder.begin_render_pass(…) tells rust to drop any variables within them when the code leaves that scope thus releasing the mutable borrow on encoder and allowing us to finish() it. If you don’t like the {}, you can also use drop(render_pass) to achieve the same effect.</p>
<p>首先，让我们先谈谈{}包括的代码。 encoder.begin_render_pass(…)使encoder可变(aka &amp;mut self)。在释放该可变借用之前，我们无法调用encoder.finish()。使用{}包括encoder.begin_render_pass(…)告诉rust在代码离开该范围时删除其中的任何变量，从而释放借用的可变编码器，并允许我们完成它。如果不喜欢{}，也可以使用drop(render_pass)来实现相同的效果。</p>
<p>We can get the same results by removing the {}, and the let _render_pass = line, but we need access to the _render_pass in the next tutorial, so we’ll leave it as is.</p>
<p>我们可以通过删除{}和let _render_pass=line来获得相同的结果，但是我们需要在下一个教程中访问_render_pass，所以我们将保持原样。</p>
<p>The last lines of the code tell wgpu to finish the command buffer, and to submit it to the gpu’s render queue.</p>
<p>代码的最后几行告诉wgpu完成命令缓冲区，并将其提交到gpu的渲染队列。</p>
<p>We need to update the event loop again to call this method. We’ll also call update before it too.</p>
<p>我们需要再次更新事件循环以调用此方法。我们也会在更新之前调用update。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main()</span></span><br><span class="line">event_loop.run(<span class="keyword">move</span> |event, _, control_flow| &#123;</span><br><span class="line">    <span class="keyword">match</span> event &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        Event::RedrawRequested(_) =&gt; &#123;</span><br><span class="line">            state.update();</span><br><span class="line">            <span class="keyword">match</span> state.render() &#123;</span><br><span class="line">                <span class="literal">Ok</span>(_) =&gt; &#123;&#125;</span><br><span class="line">                <span class="comment">// Recreate the swap_chain if lost</span></span><br><span class="line">                <span class="literal">Err</span>(wgpu::SwapChainError::Lost) =&gt; state.resize(state.size),</span><br><span class="line">                <span class="comment">// The system is out of memory, we should probably quit</span></span><br><span class="line">                <span class="literal">Err</span>(wgpu::SwapChainError::OutOfMemory) =&gt; *control_flow = ControlFlow::Exit,</span><br><span class="line">                <span class="comment">// All other errors (Outdated, Timeout) should be resolved by the next frame</span></span><br><span class="line">                <span class="literal">Err</span>(e) =&gt; eprintln!(<span class="string">&quot;&#123;:?&#125;&quot;</span>, e),</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        Event::MainEventsCleared =&gt; &#123;</span><br><span class="line">            <span class="comment">// RedrawRequested will only trigger once, unless we manually</span></span><br><span class="line">            <span class="comment">// request it.</span></span><br><span class="line">            window.request_redraw();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h1 id="Wait-what’s-going-on-with-RenderPassDescriptor"><a href="#Wait-what’s-going-on-with-RenderPassDescriptor" class="headerlink" title="Wait, what’s going on with RenderPassDescriptor?"></a>Wait, what’s going on with RenderPassDescriptor?</h1><p>Some of you may be able to tell what’s going on just by looking at it, but I’d be remiss if I didn’t go over it. Let’s take a look at the code again.</p>
<p>你们中的一些人可能仅仅通过看它就能知道发生了什么，但如果我不仔细看一下，那我就是失职了。让我们再看一遍代码。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&amp;wgpu::RenderPassDescriptor &#123;</span><br><span class="line">    label: <span class="literal">Some</span>(<span class="string">&quot;Render Pass&quot;</span>),</span><br><span class="line">    color_attachments: &amp;[</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    ],</span><br><span class="line">    depth_stencil_attachment: <span class="literal">None</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>A RenderPassDescriptor only has three fields: label, color_attachments and depth_stencil_attachment. The color_attachements describe where we are going to draw our color to. We’ll use depth_stencil_attachment later, but we’ll set it to None for now.</p>
<p>RenderPassDescriptor只有三个字段：label、color_attachments和depth_stencil_attachment。color_attachments描述了我们将在何处绘制颜色。稍后我们将使用depth_stencil_attachment，但现在将其设置为None。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">wgpu::RenderPassColorAttachment &#123;</span><br><span class="line">    view: &amp;frame.view,</span><br><span class="line">    resolve_target: <span class="literal">None</span>,</span><br><span class="line">    ops: wgpu::Operations &#123;</span><br><span class="line">        load: wgpu::LoadOp::Clear(wgpu::Color &#123;</span><br><span class="line">            r: <span class="number">0.1</span>,</span><br><span class="line">            g: <span class="number">0.2</span>,</span><br><span class="line">            b: <span class="number">0.3</span>,</span><br><span class="line">            a: <span class="number">1.0</span>,</span><br><span class="line">        &#125;),</span><br><span class="line">        store: <span class="literal">true</span>,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>The RenderPassColorAttachment has the view field which informs wgpu what texture to save the colors to. In this case we specify frame.view that we created using swap_chain.get_current_frame(). This means that any colors we draw to this attachment will get drawn to the screen.</p>
<p>RenderPassColorAttachment有一个视图字段，用于通知wgpu要保存颜色的纹理。在本例中，我们指定使用swap_chain.get_current_frame()创建的frame.view。这意味着我们在此附件中绘制的任何颜色都将被绘制到屏幕上。</p>
<p>The resolve_target is the texture that will receive the resolved output. This will be the same as attachment unless multisampling is enabled. We don’t need to specify this, so we leave it as None.</p>
<p>resolve_target是将接收解析输出的纹理。除非启用了多重采样，否则这将与attachment相同。我们不需要指定它，所以我们将其保留为None。</p>
<p>The ops field takes a wpgu::Operations object. This tells wgpu what to do with the colors on the screen (specified by frame.view). The load field tells wgpu how to handle colors stored from the previous frame. Currently we are clearing the screen with a bluish color.</p>
<p>ops字段接受一个wpgu::Operations对象。这告诉wgpu如何处理屏幕上的颜色(由frame.view指定)。load字段告诉wgpu如何处理从上一帧存储的颜色。目前，我们正在清除带有蓝色的屏幕。</p>
<h1 id="Challenge"><a href="#Challenge" class="headerlink" title="Challenge"></a>Challenge</h1><p>Modify the input() method to capture mouse events, and update the clear color using that. Hint: you’ll probably need to use WindowEvent::CursorMoved.</p>
<p>修改input()方法以捕获鼠标事件，并使用该方法更新清除颜色。提示：您可能需要使用WindowEvent::CursorMoved。</p>
<p><a target="_blank" rel="noopener" href="https://github.com/sotrh/learn-wgpu/tree/master/code/beginner/tutorial2-swapchain/">Check out the code!</a></p>

    </div>

    
    
    
        

<div>
<ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>本文作者： </strong>qianqians
  </li>
  <li class="post-copyright-link">
    <strong>本文链接：</strong>
    <a href="https://qianqians.github.io/2021/08/19/Wgpu%20The%20Swapchain/" title="Wgpu The Swapchain">https://qianqians.github.io/2021/08/19/Wgpu The Swapchain/</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/zh-CN" rel="noopener" target="_blank"><i class="fa fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！
  </li>
</ul>
</div>


      <footer class="post-footer">

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2021/08/17/WebGPU%203.4.2.%20Memory%20Model/" rel="prev" title="WebGPU 3.4.2. Memory Model">
      <i class="fa fa-chevron-left"></i> WebGPU 3.4.2. Memory Model
    </a></div>
      <div class="post-nav-item">
    <a href="/2021/08/20/Wgpu%20The%20Pipeline/" rel="next" title="Wgpu The Pipeline">
      Wgpu The Pipeline <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">qianqians</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>

<script src="/js/bookmark.js"></script>




  















  

  

</body>
</html>
