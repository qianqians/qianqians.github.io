<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">
  <link rel="manifest" href="/images/manifest.json">
  <meta name="msapplication-config" content="/images/browserconfig.xml">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">
<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"qianqians.github.io","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"remove","padding":18,"offset":12,"onmobile":true},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":true,"scrollpercent":true},"bookmark":{"enable":true,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="qianqians&#39;blog">
<meta property="og:url" content="https://qianqians.github.io/index.html">
<meta property="og:site_name" content="qianqians&#39;blog">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="qianqians">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://qianqians.github.io/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>qianqians'blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">qianqians'blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档<span class="badge">31</span></a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>分类<span class="badge">7</span></a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-fw fa-user"></i>关于</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <a role="button" class="book-mark-link book-mark-link-fixed"></a>

  <a href="https://github.com/qianqians" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://qianqians.github.io/2023/11/24/ice_Slice_Source_Files/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="qianqians">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="qianqians'blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/11/24/ice_Slice_Source_Files/" class="post-title-link" itemprop="url">Slice Source Files</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2023-11-24 22:04:03 / 修改时间：22:15:07" itemprop="dateCreated datePublished" datetime="2023-11-24T22:04:03+08:00">2023-11-24</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/ice/" itemprop="url" rel="index"><span itemprop="name">ice</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>Slice defines a number of rules for the naming and contents of Slice source files.</p>
<p>Slice 定义了许多 Slice 源文件的命名和内容的规则。</p>
<p>File Naming<br>Files containing Slice definitions must end in a .ice file extension, for example, Clock.ice is a valid file name. Other file extensions are rejected by the compilers.</p>
<p>For case-insensitive file systems, the file extension may be written as uppercase or lowercase, so Clock.ICE is legal. For case-sensitive file systems (such as Unix), Clock.ICE is illegal. (The extension must be in lowercase.)</p>
<p>文件命名<br>包含Slice定义的文件必须以 .ice 文件扩展名结尾，例如，Clock.ice 是有效的文件名。 其他文件扩展名会被编译器拒绝。</p>
<p>对于不区分大小写的文件系统，文件扩展名可以写为大写或小写，因此 Clock.ICE 是合法的。 对于区分大小写的文件系统（例如Unix），Clock.ICE 是非法的。 （扩展名必须为小写。）</p>
<p>File Format<br>Slice is a free-form language so you can use spaces, horizontal and vertical tab stops, form feeds, and newline characters to lay out your code in any way you wish. (White space characters are token separators). Slice does not attach semantics to the layout of a definition. You may wish to follow the style we have used for the Slice examples throughout this book.</p>
<p>Slice files can be ASCII text files or use the UTF-8 character encoding with an optional byte order marker (BOM) at the beginning of each file. However, Slice identifiers are limited to ASCII letters and digits; non-ASCII letters can appear only in comments and string literals.</p>
<p>文件格式<br>Slice 是一种自由格式的语言，因此您可以使用空格、水平和垂直制表位、换页符和换行符以您希望的任何方式布局代码。 （空白字符是标记分隔符）。 Slice 不会将语义附加到定义的布局上。 您可能希望遵循我们在本书中使用的 Slice 示例的风格。</p>
<p>Slice文件可以是 ASCII 文本文件，也可以使用 UTF-8 字符编码，并在每个文件的开头带有可选的字节顺序标记 (BOM)。 然而，Slice标识符仅限于 ASCII 字母和数字； 非 ASCII 字母只能出现在注释和字符串文字中。</p>
<p>Preprocessing<br>Slice supports the same preprocessor directives as C++, so you can use directives such as #include and macro definitions. However, Slice permits #include directives only at the beginning of a file, before any Slice definitions.</p>
<p>If you use #include directives, it is a good idea to protect them with guards to prevent double inclusion of a file:</p>
<p>预处理<br>Slice 支持与 C++ 相同的预处理器指令，因此您可以使用 #include 和宏定义等指令。 但是，Slice 只允许在文件开头、任何 Slice 定义之前使用 #include 指令。</p>
<p>如果您使用 #include 指令，最好使用防护装置来保护它们，以防止文件的双重包含：</p>
<p>Slice```cpp<br>// File Clock.ice<br>#ifndef _CLOCK_ICE<br>#define _CLOCK_ICE</p>
<p>// #include directives here…<br>// Definitions here…</p>
<p>#endif _CLOCK_ICE</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">The following #pragma directive offers a simpler way to achieve the same result:</span><br><span class="line"></span><br><span class="line">以下 #pragma 指令提供了一种更简单的方法来实现相同的结果：</span><br><span class="line"></span><br><span class="line">Slice```cpp</span><br><span class="line">// File Clock.ice</span><br><span class="line">#pragma once</span><br><span class="line"> </span><br><span class="line">// #include directives here...</span><br><span class="line">// Definitions here...</span><br></pre></td></tr></table></figure>

<p>#include directives permit a Slice definition to use types defined in a different source file. The Slice compilers parse all of the code in a source file, including the code in subordinate #include files. However, the compilers generate code only for the top-level file(s) nominated on the command line. You must separately compile subordinate #include files to obtain generated code for all the files that make up your Slice definition.</p>
<p>Note that you should avoid #include with double quotes:</p>
<p>#include 指令允许 Slice 定义使用不同源文件中定义的类型。 Slice 编译器解析源文件中的所有代码，包括从属 #include 文件中的代码。 但是，编译器仅为命令行上指定的顶级文件生成代码。 您必须单独编译从属 #include 文件，以获得构成 Slice 定义的所有文件的生成代码。</p>
<p>请注意，您应该避免使用双引号#include：</p>
<p>Slice```cpp<br>#include “Clock.ice” // Not recommended!</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">While double quotes will work, the directory in which the preprocessor tries to locate the file can vary depending on the operating system, so the included file may not always be found where you expect it. Instead, use angle brackets (&lt;&gt;); you can control which directories are searched for the file with the -I option of the Slice compiler.</span><br><span class="line"></span><br><span class="line">Also note that, if you include a path separator in a #include directive, you must use a forward slash:</span><br><span class="line"></span><br><span class="line">虽然双引号可以工作，但预处理器尝试在其中查找文件的目录可能会因操作系统而异，因此可能并不总是能在您期望的位置找到包含的文件。 相反，请使用尖括号 (&lt;&gt;)； 您可以使用 Slice 编译器的 -I 选项来控制在哪些目录中搜索文件。</span><br><span class="line"></span><br><span class="line">另请注意，如果在 #include 指令中包含路径分隔符，则必须使用正斜杠：</span><br><span class="line"></span><br><span class="line">Slice```cpp</span><br><span class="line">#include &lt;SliceDefs/Clock.ice&gt;  // OK</span><br></pre></td></tr></table></figure>

<p>You cannot use a backslash in #include directives:</p>
<p>您不能在 #include 指令中使用反斜杠：</p>
<p>Slice```cpp<br>#include &lt;SliceDefs\Clock.ice&gt;  // Illegal</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">Detecting Ice Versions</span><br><span class="line">The Slice compilers define the preprocessor macro __ICE_VERSION__ with a numeric representation of the Ice version. The value of this macro is the same as the C++ macro ICE_INT_VERSION. You can use this macro to make your Slice definitions backward-compatible with older Ice releases, while still taking advantage of newer Ice features when possible. For example, the Slice definition shown below makes use of custom enumerator values:</span><br><span class="line"></span><br><span class="line">检测 Ice 版本</span><br><span class="line">Slice 编译器使用 Ice 版本的数字表示来定义预处理器宏 __ICE_VERSION__ 。 该宏的值与 C++ 宏 ICE_INT_VERSION 相同。 您可以使用此宏使您的 Slice 定义向后兼容较旧的 Ice 版本，同时尽可能利用较新的 Ice 功能。 例如，下面显示的 Slice 定义使用自定义枚举值：</span><br><span class="line"></span><br><span class="line">Slice```cpp</span><br><span class="line">#if defined(__ICE_VERSION__) &amp;&amp; __ICE_VERSION__ &gt;= 030500</span><br><span class="line">enum Fruit &#123; Apple, Pear = 3, Orange &#125;</span><br><span class="line">#else</span><br><span class="line">enum Fruit &#123; Apple, Pear, Orange &#125;</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure>

<p>Although this example is intended to show how to use the ICE_VERSION macro, it also highlights a potential pitfall that you must be aware of when trying to maintain backward compatibility: the two definitions of Fruit are not wire-compatible. </p>
<p>尽管此示例旨在展示如何使用 ICE_VERSION 宏，但它也强调了在尝试保持向后兼容性时必须注意的潜在陷阱：Fruit 的两个定义不兼容。</p>
<p>Detecting Slice Compilers<br>Each Slice compiler defines its own macro so that you can customize your Slice code for certain language mappings. The macro name is <strong><compiler name in upper case></strong>, such as <strong>SLICE2CPP</strong> and <strong>SLICE2MATLAB</strong> for slice2cpp resp. slice2matlab.</p>
<p>检测Slice编译器<br>每个 Slice 编译器都定义自己的宏，以便您可以针对某些语言映射自定义 Slice 代码。 宏名称为 __&lt;大写的编译器名称&gt;__，例如 slice2cpp 的宏名称为 <strong>SLICE2CPP</strong> 和 __SLICE2MATLAB__。 slice2matlab。</p>
<p>For example, .NET developers may elect to avoid the use of default values for structure members because the presence of default values changes the C# mapping of the structure from struct to class:</p>
<p>例如，.NET 开发人员可能会选择避免对结构成员使用默认值，因为默认值的存在会更改结构从结构到类的 C# 映射：</p>
<p>Slice```cpp<br>struct Record<br>{<br>    // …<br>#if <strong>SLICE2CS</strong><br>    bool active;<br>#else<br>    bool active = true;<br>#endif<br>}</p>
<p>```</p>
<p>Definition Order<br>Slice constructs, such as modules, interfaces, or type definitions, can appear in any order you prefer. However, identifiers must be declared before they can be used.</p>
<p>定义顺序<br>Slice构造（例如模块、接口或类型定义）可以按您喜欢的任何顺序出现。 但是，标识符在使用之前必须先声明。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://qianqians.github.io/2023/11/22/ice_Slice_Compilation/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="qianqians">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="qianqians'blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/11/22/ice_Slice_Compilation/" class="post-title-link" itemprop="url">Slice Compilation</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2023-11-22 21:36:12 / 修改时间：21:52:05" itemprop="dateCreated datePublished" datetime="2023-11-22T21:36:12+08:00">2023-11-22</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/ice/" itemprop="url" rel="index"><span itemprop="name">ice</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>Slice Compilation</p>
<p>Compilation<br>A Slice compiler produces source files that must be combined with application code to produce client and server executables.</p>
<p>Slice 编译器生成的源文件必须与应用程序代码组合才能生成客户端和服务器可执行文件。</p>
<p>Single Development Environment for Client and Server</p>
<p>The figure below shows the situation when both client and server are developed in C++. The Slice compiler generates two files from a Slice definition in a source file Printer.ice: a header file (Printer.h) and a source file (Printer.cpp)</p>
<p>下图展示了客户端和服务器端均采用C++开发时的情况。 Slice 编译器根据源文件 Printer.ice 中的 Slice 定义生成两个文件：头文件 (Printer.h) 和源文件 (Printer.cpp)</p>
<p><img src="https://doc.zeroc.com/ice/files/3.7/14026220/25591829/1/1515168282000/Client_server_same_development_environment.gif" alt="Alt text"></p>
<p>Development process if client and server share the same development environment.</p>
<p>The Printer.h header file contains definitions that correspond to the types used in the Slice definition. It is included in the source code of both client and server to ensure that client and server agree about the types and interfaces used by the application.<br>The Printer.cpp source file provides an API to the client for sending messages to remote objects. The client source code (Client.cpp, written by the client developer) contains the client-side application logic. The generated source code and the client code are compiled and linked into the client executable.</p>
<p>客户端和服务器共享相同开发环境的开发流程。</p>
<p>Printer.h 头文件包含与 Slice 定义中使用的类型相对应的定义。 它包含在客户端和服务器的源代码中，以确保客户端和服务器就应用程序使用的类型和接口达成一致。<br>Printer.cpp 源文件向客户端提供 API，用于将消息发送到远程对象。 客户端源代码（Client.cpp，由客户端开发人员编写）包含客户端应用程序逻辑。 生成的源代码和客户端代码被编译并链接到客户端可执行文件中。</p>
<p>The Printer.cpp source file also contains source code that provides an up-call interface from the Ice run time into the server code written by the developer and provides the connection between the networking layer of Ice and the application code. The server implementation file (Server.cpp, written by the server developer) contains the server-side application logic (the object implementations, properly termed servants). The generated source code and the implementation source code are compiled and linked into the server executable.</p>
<p>Printer.cpp 源文件还包含源代码，该源代码提供从 Ice 运行时到开发人员编写的服务器代码的上行调用接口，并提供 Ice 网络层和应用程序代码之间的连接。 服务器实现文件（Server.cpp，由服务器开发人员编写）包含服务器端应用程序逻辑（对象实现，正确称为servants）。 生成的源代码和实现源代码被编译并链接到服务器可执行文件中。</p>
<p>Both client and server also link with an Ice library that provides the necessary run-time support.</p>
<p>客户端和服务器还与提供必要的运行时支持的 Ice 库链接。</p>
<p>You are not limited to a single implementation of a client or server. For example, you can build multiple servers, each of which implements the same interfaces but uses different implementations (for example, with different performance characteristics). Multiple such server implementations can coexist in the same system. This arrangement provides one fundamental scalability mechanism in Ice: if you find that a server process starts to bog down as the number of objects increases, you can run an additional server for the same interfaces on a different machine. Such federated servers provide a single logical service that is distributed over a number of processes on different machines. Each server in the federation implements the same interfaces but hosts different object instances. (Of course, federated servers must somehow ensure consistency of any databases they share across the federation.)</p>
<p>您不限于客户端或服务器的单一实现。 例如，您可以构建多个服务器，每个服务器都实现相同的接口，但使用不同的实现（例如，具有不同的性能特征）。 多个此类服务器实现可以共存于同一系统中。 这种安排在 Ice 中提供了一种基本的可扩展性机制：如果您发现服务器进程随着对象数量的增加而开始陷入困境，您可以为不同机器上的相同接口运行额外的服务器。 此类联合服务器提供分布在不同机器上的多个进程上的单一逻辑服务。 联合中的每个服务器都实现相同的接口，但托管不同的对象实例。 （当然，联合服务器必须以某种方式确保它们在联合中共享的任何数据库的一致性。）</p>
<p>Ice also provides support for replicated servers. Replication permits multiple servers to each implement the same set of object instances. This improves performance and scalability (because client load can be shared over a number of servers) as well as redundancy (because each object is implemented in more than one server).</p>
<p>Ice 还提供对复制服务器的支持。 复制允许多个服务器各自实现同一组对象实例。 这提高了性能和可伸缩性（因为客户端负载可以在多个服务器上共享）以及冗余（因为每个对象都在多个服务器中实现）。</p>
<p>Different Development Environments for Client and Server</p>
<p>Client and server cannot share any source or binary components if they are developed in different languages. For example, a client written in Java cannot include a C++ header file.</p>
<p>如果客户端和服务器使用不同语言开发，则不能共享任何源代码或二进制组件。 例如，用 Java 编写的客户端不能包含 C++ 头文件。</p>
<p>This figure shows the situation when a client written in Java and the corresponding server is written in C++. In this case, the client and server developers are completely independent, and each uses his or her own development environment and language mapping. The only link between client and server developers is the Slice definition each one uses.</p>
<p>该图显示了当客户端用Java编写而相应的服务器用C++编写时的情况。 在这种情况下，客户端和服务器开发人员是完全独立的，并且各自使用自己的开发环境和语言映射。 客户端和服务器开发人员之间的唯一联系是各自使用的 Slice 定义。</p>
<p><img src="https://doc.zeroc.com/ice/files/3.7/14026220/25591831/1/1515168283000/Development_process_different_development_environment.gif" alt="Alt text"></p>
<p>Development process for different development environments.</p>
<p>For Java, the slice compiler creates a number of files whose names depend on the names of various Slice constructs. (These files are collectively referred to as *.java in the above figure.)</p>
<p>针对不同开发环境的开发流程。</p>
<p>对于 Java，slice编译器创建许多文件，其名称取决于各种 Slice 构造的名称。 （这些文件在上图中统称为*.java。）</p>
<p>Slice Compilation and your Build Environment</p>
<p>One way to integrate Slice compilation in your build system is to compile your Slice files manually, and then keep (check-in) the generated files like other source files. Later on, each time you change a Slice file, you have to remember to recompile this Slice file and update the generated files. While simple, this approach can lead to inconsistencies and bugs if you forget to recompile a modified Slice file.</p>
<p>将 Slice 编译集成到构建系统中的一种方法是手动编译 Slice 文件，然后像其他源文件一样保留（签入）生成的文件。 以后，每次更改 Slice 文件时，都必须记住重新编译该 Slice 文件并更新生成的文件。 虽然简单，但如果您忘记重新编译修改后的 Slice 文件，这种方法可能会导致不一致和错误。</p>
<p>We recommend you use instead an Ice Builder for your build environment to manage the compilation of your Slice files. An Ice Builder is a simple plug-in or task for your build environment that compiles or recompiles Slice files when it detects the corresponding generated files are missing or out of date. A Builder performs this Slice compilation by invoking the Slice compiler for the target programming language–it does compile the files itself and usually supports several versions of Ice.</p>
<p>我们建议您在构建环境中使用 Ice Builder 来管理 Slice 文件的编译。 Ice Builder 是一个适用于构建环境的简单插件或任务，当它检测到相应的生成文件丢失或过期时，它会编译或重新编译 Slice 文件。 Builder 通过调用目标编程语言的 Slice 编译器来执行此 Slice 编译 - 它本身会编译文件，并且通常支持多个版本的 Ice。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://qianqians.github.io/2023/11/21/ice_slice/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="qianqians">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="qianqians'blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/11/21/ice_slice/" class="post-title-link" itemprop="url">Slice</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2023-11-21 22:26:12 / 修改时间：22:33:46" itemprop="dateCreated datePublished" datetime="2023-11-21T22:26:12+08:00">2023-11-21</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/ice/" itemprop="url" rel="index"><span itemprop="name">ice</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>Slice (Specification Language for Ice)</p>
<p>Each Ice object has an interface with a number of operations. Interfaces, operations, and the types of data that are exchanged between client and server are defined using the Slice language. Slice allows you to define the client-server contract in a way that is independent of a specific programming language, such as C++, Java, or C#. The Slice definitions are compiled by a compiler into an API for a specific programming language, that is, the part of the API that is specific to the interfaces and types you have defined consists of generated code.</p>
<p>每个 Ice 对象都有一个包含许多操作的接口。 客户端和服务器之间交换的接口、操作和数据类型都是使用 Slice 语言定义的。 Slice 允许您以独立于特定编程语言（例如 C++、Java 或 C#）的方式定义客户端-服务器协定。 Slice 定义由编译器编译为特定编程语言的 API，即 API 中特定于您定义的接口和类型的部分由生成的代码组成。</p>
<p>The Slice Language</p>
<p>Slice (Specification Language for Ice) is the fundamental abstraction mechanism for separating object interfaces from their implementations. Slice establishes a contract between client and server that describes the interfaces, operations and parameter types used by an application. This description is independent of the implementation language, so it does not matter whether the client is written in the same language as the server.</p>
<p>Even though Slice is an acronym, it is pronounced as a single syllable, like a slice of bread.</p>
<p>Slice definitions are compiled for a particular implementation language by a compiler. The language-specific Slice compiler translates the language-independent Slice definitions into language-specific type definitions and APIs. These types and APIs are used by the developer to provide application functionality and to interact with Ice. The translation algorithms for various implementation languages are known as language mappings, and Ice provides a number of language mappings (for C++, C#, Java, JavaScript, Python and more).</p>
<p>Because Slice describes interfaces and types (but not implementations), it is a purely declarative language; there is no way to write executable statements in Slice.</p>
<p>Slice definitions focus on object interfaces, the operations supported by those interfaces, and exceptions that may be raised by operations. This requires quite a bit of supporting machinery; in particular, much of Slice is concerned with the definition of data types. This is because data can be exchanged between client and server only if their types are defined in Slice. You cannot exchange arbitrary C++ data between a client and a server because it would destroy the language independence of Ice. However, you can always create a Slice type definition that corresponds to the C++ data you want to send, and then you can transmit the Slice type.</p>
<p>We present the full syntax and semantics of Slice here. Because much of Slice is based on C++ and Java, we focus on those areas where Slice differs from C++ or Java or constrains the equivalent C++ or Java feature in some way. Slice features that are identical to C++ and Java are mentioned mostly by example.</p>
<p>Slice（Ice 规范语言）是将对象接口与其实现分离的基本抽象机制。 Slice 在客户端和服务器之间建立契约，描述应用程序使用的接口、操作和参数类型。 这种描述与实现语言无关，因此客户端是否与服务器使用相同的语言编写并不重要。</p>
<p>尽管 Slice 是一个缩写词，但它的发音是一个音节，就像一片面包一样。</p>
<p>Slice定义由编译器针对特定的实现语言进行编译。 特定于语言的 Slice 编译器将独立于语言的 Slice 定义转换为特定于语言的类型定义和 API。 开发人员使用这些类型和 API 来提供应用程序功能并与 Ice 进行交互。 各种实现语言的翻译算法称为语言映射，Ice 提供了多种语言映射（针对 C++、C#、Java、JavaScript、Python 等）。</p>
<p>因为 Slice 描述了接口和类型（但不描述实现），所以它是一种纯粹的声明性语言； 无法在 Slice 中编写可执行语句。</p>
<p>Slice定义重点关注对象接口、这些接口支持的操作以及操作可能引发的异常。 这需要相当多的配套机械； 特别是，Slice 的大部分内容都与数据类型的定义有关。 这是因为只有在 Slice 中定义了数据类型，客户端和服务器之间才能交换数据。 您不能在客户端和服务器之间交换任意 C++ 数据，因为这会破坏 Ice 的语言独立性。 但是，您始终可以创建与要发送的 C++ 数据相对应的 Slice 类型定义，然后就可以传输该 Slice 类型。</p>
<p>我们在这里展示 Slice 的完整语法和语义。 由于 Slice 的大部分内容都基于 C++ 和 Java，因此我们重点关注 Slice 与 C++ 或 Java 不同的领域，或者以某种方式限制等效的 C++ 或 Java 功能的领域。 与 C++ 和 Java 相同的 Slice 功能主要通过示例来提及。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://qianqians.github.io/2023/11/20/ice_Terminology/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="qianqians">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="qianqians'blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/11/20/ice_Terminology/" class="post-title-link" itemprop="url">Terminology</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-11-20 22:55:48" itemprop="dateCreated datePublished" datetime="2023-11-20T22:55:48+08:00">2023-11-20</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-11-21 22:33:29" itemprop="dateModified" datetime="2023-11-21T22:33:29+08:00">2023-11-21</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/ice/" itemprop="url" rel="index"><span itemprop="name">ice</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>Every computing technology creates its own vocabulary as it evolves. Ice is no exception. However, the amount of new jargon used by Ice is minimal. Rather than inventing new terms, we have used existing terminology as much as possible. If you have used another middleware technology in the past, you will be familiar with much of what follows. (However, we suggest you at least skim the material because a few terms used by Ice do differ from the corresponding terms used by other middleware.)</p>
<p>每种计算技术都会随着其发展而创建自己的词汇表。 Ice也不例外。 然而，Ice 使用的新术语数量很少。 我们没有发明新术语，而是尽可能多地使用现有术语。 如果您过去使用过另一种中间件技术，您将会熟悉接下来的大部分内容。 （但是，我们建议您至少浏览一下材料，因为 Ice 使用的一些术语确实与其他中间件使用的相应术语不同。）</p>
<p>Clients and Servers<br>The terms client and server are not firm designations for particular parts of an application; rather, they denote roles that are taken by parts of an application for the duration of a request:</p>
<p>Clients are active entities. They issue requests for service to servers.<br>Servers are passive entities. They provide services in response to client requests.<br>Frequently, servers are not “pure” servers, in the sense that they never issue requests and only respond to requests. Instead, servers often act as a server on behalf of some client but, in turn, act as a client to another server in order to satisfy their client’s request.</p>
<p>Similarly, clients often are not “pure” clients, in the sense that they only request service from an object. Instead, clients are frequently client-server hybrids. For example, a client might start a long-running operation on a server; as part of starting the operation, the client can provide a callback object to the server that is used by the server to notify the client when the operation is complete. In that case, the client acts as a client when it starts the operation, and as a server when it is notified that the operation is complete.</p>
<p>Such role reversal is common in many systems, so, frequently, client-server systems could be more accurately described as peer-to-peer systems.</p>
<p>客户端和服务器<br>术语“客户端”和“服务器”并不是应用程序特定部分的固定名称。 相反，它们表示请求期间应用程序的各个部分所扮演的角色：</p>
<p>客户是活跃的实体。 他们向服务器发出服务请求。<br>服务器是被动实体。 他们根据客户的要求提供服务。<br>通常，服务器不是“纯”服务器，因为它们并不是从不发出请求而仅响应请求。 相反，服务器通常充当代表某个客户端的服务器，但反过来又充当另一个服务器的客户端以满足其客户端的请求。</p>
<p>类似地，客户端通常不是“纯粹”客户端，因为它们仅向对象请求服务。 相反，客户端通常是客户端-服务器混合体。 例如，客户端可能在服务器上启动长时间运行的操作； 作为启动操作的一部分，客户端可以向服务器提供回调对象，服务器使用该对象在操作完成时通知客户端。 在这种情况下，客户端在开始操作时充当客户端，并在收到操作完成通知时充当服务器。</p>
<p>这种角色反转在许多系统中很常见，因此，客户端-服务器系统通常可以更准确地描述为对等系统。</p>
<p>Ice Objects<br>An Ice object is a conceptual entity, or abstraction. An Ice object can be characterized by the following points:</p>
<p>An Ice object is an entity in the local or a remote address space that can respond to client requests.<br>A single Ice object can be instantiated in a single server or, redundantly, in multiple servers. If an object has multiple simultaneous instantiations, it is still a single Ice object.<br>Each Ice object has one or more interfaces. An interface is a collection of named operations that are supported by an object. Clients issue requests by invoking operations.<br>An operation has zero or more parameters as well as a return value. Parameters and return values have a specific type. Parameters are named and have a direction: in-parameters are initialized by the client and passed to the server; out-parameters are initialized by the server and passed to the client. (The return value is simply a special out-parameter.)<br>An Ice object has a distinguished interface, known as its main interface. In addition, an Ice object can provide zero or more alternate interfaces, known as facets. Clients can select among the facets of an object to choose the interface they want to work with.<br>Each Ice object has a unique object identity. An object’s identity is an identifying value that distinguishes the object from all other objects. The Ice object model assumes that object identities are globally unique, that is, no two objects within an Ice communication domain can have the same object identity.</p>
<p>In practice, you need not use object identities that are globally unique, such as UUIDs, only identities that do not clash with any other identity within your domain of interest. However, there are architectural advantages to using globally unique identifiers, which we explore in our discussion of object life cycle.</p>
<p>Ice对象<br>Ice对象是一个概念实体或抽象。 Ice对象可以具有以下几点特征：</p>
<p>Ice对象是本地或远程地址空间中可以响应客户端请求的实体。<br>单个Ice对象可以在单个服务器中实例化，或者冗余地在多个服务器中实例化。 如果一个对象有多个同时实例化，它仍然是单个Ice对象。<br>每个Ice对象都有一个或多个接口。 接口是对象支持的命名操作的集合。 客户端通过调用操作来发出请求。<br>操作具有零个或多个参数以及返回值。 参数和返回值具有特定的类型。 参数有名字并且有方向：内参数由客户端初始化并传递给服务器； 输出参数由服务器初始化并传递给客户端。 （返回值只是一个特殊的输出参数。）<br>Ice对象有一个独特的接口，称为主接口。 此外，Ice对象可以提供零个或多个备用接口，称为构面。客户可以在对象的各个方面进行选择，以选择他们想要使用的界面。<br>每个Ice对象都有一个唯一的对象标识。 对象的标识是将该对象与所有其他对象区分开来的标识值。 Ice对象模型假设对象标识是全局唯一的，即Ice通信域内的两个对象不能具有相同的对象标识。</p>
<p>在实践中，您不需要使用全局唯一的对象标识，例如 UUID，只需使用不与您感兴趣的域内的任何其他标识冲突的标识即可。 然而，使用全局唯一标识符具有架构优势，我们在对象生命周期的讨论中对此进行了探讨。</p>
<p>Proxies<br>For a client to be able to contact an Ice object, the client must hold a proxy for the Ice object. A proxy is an artifact that is local to the client’s address space; it represents the (possibly remote) Ice object for the client. A proxy acts as the local ambassador for an Ice object: when the client invokes an operation on the proxy, the Ice run time:</p>
<p>Locates the Ice object<br>Activates the Ice object’s server if it is not running<br>Activates the Ice object within the server<br>Transmits any in-parameters to the Ice object<br>Waits for the operation to complete<br>Returns any out-parameters and the return value to the client (or throws an exception in case of an error)<br>A proxy encapsulates all the necessary information for this sequence of steps to take place. In particular, a proxy contains:</p>
<p>Addressing information that allows the client-side run time to contact the correct server<br>An object identity that identifies which particular object in the server is the target of a request<br>An optional facet identifier that determines which particular facet of an object the proxy refers to</p>
<p>代理<br>为了使客户端能够联系Ice对象，客户端必须持有Ice对象的代理。 代理是客户端地址空间本地的工件； 它代表客户端的（可能是远程的Ice对象。 代理充当Ice对象的本地大使：当客户端调用代理上的操作时，Ice 运行时间：</p>
<p>找到Ice对象<br>如果Ice对象的服务器未运行，则激活它<br>激活服务器内的Ice对象<br>将任何内参数传输到Ice对象<br>等待操作完成<br>将任何输出参数和返回值返回给客户端（或者在出现错误时抛出异常）<br>代理封装了执行这一系列步骤所需的所有必要信息。 特别是，代理包含：</p>
<p>允许客户端运行时联系正确服务器的寻址信息<br>对象标识，用于标识服务器中哪个特定对象是请求的目标<br>可选的方面标识符，用于确定代理引用对象的哪个特定方面</p>
<p>Stringified Proxies<br>The information in a proxy can be expressed as a string. For example, the string:</p>
<p>SimplePrinter:default -p 10000<br>is a human-readable representation of a proxy. The Ice run time provides API calls that allow you to convert a proxy to its stringified form and vice versa. This is useful, for example, to store proxies in database tables or text files.</p>
<p>Provided that a client knows the identity of an Ice object and its addressing information, it can create a proxy “out of thin air” by supplying that information. In other words, no part of the information inside a proxy is considered opaque; a client needs to know only an object’s identity, addressing information, and (to be able to invoke an operation) the object’s type in order to contact the object.</p>
<p>字符串化代理<br>代理中的信息可以表示为字符串。 例如，字符串：</p>
<p>SimplePrinter：default -p 10000<br>是代理的人类可读表示。 Ice运行时提供API调用，允许您将代理转换为其字符串化形式，反之亦然。 例如，这对于将代理存储在数据库表或文本文件中非常有用。</p>
<p>如果客户端知道 Ice 对象的身份及其寻址信息，它就可以通过提供该信息“凭空”创建代理。 换句话说，代理内部的信息没有任何部分被认为是不透明的； 客户端只需要知道对象的身份、寻址信息和（能够调用操作）对象的类型即可联系该对象。</p>
<p>Direct Proxies<br>A direct proxy is a proxy that embeds an object’s identity, together with the address at which its server runs. The address is completely specified by:</p>
<p>a protocol identifier (such TCP/IP or UDP)<br>a protocol-specific address (such as a host name and port number)<br>To contact the object denoted by a direct proxy, the Ice run time uses the addressing information in the proxy to contact the server; the identity of the object is sent to the server with each request made by the client.</p>
<p>直接代理<br>直接代理是嵌入对象身份及其服务器运行地址的代理。 地址完全由以下方式指定：</p>
<p>协议标识符（例如 TCP/IP 或 UDP）<br>特定于协议的地址（例如主机名和端口号）<br>为了联系直接代理所表示的对象，Ice runtime 使用代理中的寻址信息来联系服务器； 对象的身份随着客户端发出的每个请求发送到服务器。</p>
<p>Indirect Proxies<br>An indirect proxy has two forms. It may provide only an object’s identity, or it may specify an identity together with an object adapter identifier. An object that is accessible using only its identity is called a well-known object, and the corresponding proxy is a well-known proxy. For example, the string:</p>
<p>SimplePrinter<br>is a valid proxy for a well-known object with the identity SimplePrinter.</p>
<p>An indirect proxy that includes an object adapter identifier has the stringified form</p>
<p>SimplePrinter@PrinterAdapter<br>Any object of the object adapter can be accessed using such a proxy, regardless of whether that object is also a well-known object.</p>
<p>Notice that an indirect proxy contains no addressing information. To determine the correct server, the client-side run time passes the proxy information to a location service. In turn, the location service uses the object identity or the object adapter identifier as the key in a lookup table that contains the address of the server and returns the current server address to the client. The client-side run time now knows how to contact the server and dispatches the client request as usual.</p>
<p>The entire process is similar to the mapping from Internet domain names to IP address by the Domain Name Service (DNS): when we use a domain name, such as <a target="_blank" rel="noopener" href="http://www.zeroc.com/">www.zeroc.com</a>, to look up a web page, the host name is first resolved to an IP address behind the scenes and, once the correct IP address is known, the IP address is used to connect to the server. With Ice, the mapping is from an object identity or object adapter identifier to a protocol-address pair, but otherwise very similar. The client-side run time knows how to contact the location service via configuration (just as web browsers know which DNS server to use via configuration).</p>
<p>间接代理<br>间接代理有两种形式。 它可以仅提供对象的标识，或者它可以与对象适配器标识符一起指定标识。 仅使用其身份即可访问的对象称为众所周知的对象，相应的代理也是众所周知的代理。 例如，字符串：</p>
<p>SimplePrinter<br>是具有标识 SimplePrinter 的知名对象的有效代理。</p>
<p>包含对象适配器标识符的间接代理具有字符串化形式</p>
<p>SimplePrinter@PrinterAdapter<br>对象适配器的任何对象都可以使用这样的代理来访问，无论该对象是否也是众所周知的对象。</p>
<p>请注意，间接代理不包含寻址信息。 为了确定正确的服务器，客户端运行时将代理信息传递给位置服务。 反过来，位置服务使用对象标识或对象适配器标识符作为包含服务器地址的查找表中的键，并将当前服务器地址返回给客户端。 客户端运行时现在知道如何联系服务器并像往常一样分派客户端请求。</p>
<p>整个过程类似于域名服务（DNS）从互联网域名到IP地址的映射：当我们使用域名（例如<a target="_blank" rel="noopener" href="http://www.zeroc.com)来查找网页时,主机名是/">www.zeroc.com）来查找网页时，主机名是</a> 首先在后台解析为 IP 地址，一旦知道正确的 IP 地址，就会使用该 IP 地址连接到服务器。 对于 Ice，映射是从对象标识或对象适配器标识符到协议地址对，但在其他方面非常相似。 客户端运行时知道如何通过配置联系位置服务（就像 Web 浏览器通过配置知道要使用哪个 DNS 服务器一样）。</p>
<p>Direct Versus Indirect Binding<br>The process of resolving the information in a proxy to protocol-address pair is known as binding. Not surprisingly, direct binding is used for direct proxies, and indirect binding is used for indirect proxies.</p>
<p>The main advantage of indirect binding is that it allows us to move servers around (that is, change their address) without invalidating existing proxies that are held by clients. In other words, direct proxies avoid the extra lookup to locate the server but no longer work if a server is moved to a different machine. On the other hand, indirect proxies continue to work even if we move (or migrate) a server.</p>
<p>直接绑定与间接绑定<br>将代理中的信息解析为协议地址对的过程称为绑定。 毫不奇怪，直接绑定用于直接代理，间接绑定用于间接代理。</p>
<p>间接绑定的主要优点是它允许我们移动服务器（即更改其地址），而不会使客户端持有的现有代理失效。 换句话说，直接代理避免了定位服务器的额外查找，但如果服务器移动到另一台计算机，则直接代理不再起作用。 另一方面，即使我们移动（或迁移）服务器，间接代理仍然可以继续工作。</p>
<p>Fixed Proxies<br>A fixed proxy is a proxy that is bound to a particular connection: instead of containing addressing information or an adapter name, the proxy contains a connection handle. The connection handle stays valid only for as long as the connection stays open so, once the connection is closed, the proxy no longer works (and will never work again). Fixed proxies cannot be marshaled, that is, they cannot be passed as parameters on operation invocations. Fixed proxies are used to allow bidirectional communication, so a server can make callbacks to a client without having to open a new connection.</p>
<p>固定代理<br>固定代理是绑定到特定连接的代理：代理包含连接句柄，而不是包含寻址信息或适配器名称。 连接句柄仅在连接保持打开状态时保持有效，因此，一旦连接关闭，代理就不再工作（并且永远不会再工作）。 固定代理无法封送，即它们无法作为操作调用的参数传递。 固定代理用于允许双向通信，因此服务器可以对客户端进行回调，而无需打开新连接。</p>
<p>Routed Proxies<br>A routed proxy is a proxy that forwards all invocations to a specific target object, instead of sending invocations directly to the actual target. Routed proxies are useful for implementing services such as Glacier2, which enables clients to communicate with servers that are behind a firewall.</p>
<p>路由代理<br>路由代理是将所有调用转发到特定目标对象的代理，而不是将调用直接发送到实际目标。 路由代理对于实现 Glacier2 等服务非常有用，它使客户端能够与防火墙后面的服务器进行通信。</p>
<p>Replication<br>In Ice, replication involves making object adapters (and their objects) available at multiple addresses. The goal of replication is usually to provide redundancy by running the same server on several computers. If one of the computers should happen to fail, a server still remains available on the others.</p>
<p>The use of replication implies that applications are designed for it. In particular, it means a client can access an object via one address and obtain the same result as from any other address. Either these objects are stateless, or their implementations are designed to synchronize with a database (or each other) in order to maintain a consistent view of each object’s state.</p>
<p>Ice supports a limited form of replication when a proxy specifies multiple addresses for an object. The Ice run time selects one of the addresses at random for its initial connection attempt and tries all of them in the case of a failure. For example, consider this proxy:</p>
<p>SimplePrinter:tcp -h server1 -p 10001:tcp -h server2 -p 10002<br>The proxy states that the object with identity SimplePrinter is available using TCP at two addresses, one on the host server1 and another on the host server2. The burden falls to users or system administrators to ensure that the servers are actually running on these computers at the specified ports.</p>
<p>复制<br>在 Ice 中，复制涉及使对象适配器（及其对象）在多个地址可用。 复制的目标通常是通过在多台计算机上运行同一服务器来提供冗余。 如果其中一台计算机发生故障，其他计算机上的服务器仍然可用。</p>
<p>复制的使用意味着应用程序是为此设计的。 具体来说，这意味着客户端可以通过一个地址访问一个对象，并获得与从任何其他地址访问相同的结果。 这些对象要么是无状态的，要么它们的实现被设计为与数据库（或彼此）同步，以便维护每个对象状态的一致视图。</p>
<p>当代理为对象指定多个地址时，Ice 支持有限形式的复制。 Ice run time 随机选择一个地址进行初始连接尝试，并在失败时尝试所有地址。 例如，考虑这个代理：</p>
<p>SimplePrinter:tcp -h server1 -p 10001:tcp -h server2 -p 10002<br>代理声明具有身份 SimplePrinter 的对象可通过 TCP 在两个地址上使用，一个位于主机 server1 上，另一个位于主机 server2 上。 用户或系统管理员有责任确保服务器实际上在这些计算机上的指定端口上运行。</p>
<p>Replica Groups<br>In addition to the proxy-based replication described above, Ice supports a more useful form of replication known as replica groups that requires the use of a location service.</p>
<p>A replica group has a unique identifier and consists of any number of object adapters. An object adapter may be a member of at most one replica group; such an adapter is considered to be a replicated object adapter.</p>
<p>After a replica group has been established, its identifier can be used in an indirect proxy in place of an adapter identifier. For example, a replica group identified as PrinterAdapters can be used in a proxy as shown below:</p>
<p>SimplePrinter@PrinterAdapters</p>
<p>The replica group is treated by the location service as a “virtual object adapter.” The behavior of the location service when resolving an indirect proxy containing a replica group id is an implementation detail. For example, the location service could decide to return the addresses of all object adapters in the group, in which case the client’s Ice run time would select one of the addresses at random using the limited form of replication discussed earlier. Another possibility is for the location service to return only one address, which it decided upon using some heuristic.</p>
<p>Regardless of the way in which a location service resolves a replica group, the key benefit is indirection: the location service as a middleman can add more intelligence to the binding process.</p>
<p>副本组<br>除了上述基于代理的复制之外，Ice还支持一种更有用的复制形式，称为副本组，它需要使用位置服务。</p>
<p>副本组具有唯一标识符并由任意数量的对象适配器组成。 一个对象适配器最多可以是一个副本组的成员； 这样的适配器被认为是复制对象适配器。</p>
<p>建立副本组后，可以在间接代理中使用其标识符来代替适配器标识符。 例如，标识为 PrinterAdapters 的副本组可以在代理中使用，如下所示：</p>
<p>SimplePrinter@PrinterAdapters</p>
<p>位置服务将副本组视为“虚拟对象适配器”。 解析包含副本组 ID 的间接代理时位置服务的行为是一个实现细节。 例如，位置服务可以决定返回组中所有对象适配器的地址，在这种情况下，客户端的 Ice run time 将使用前面讨论的有限复制形式随机选择地址之一。 另一种可能性是定位服务仅返回一个地址，这是它使用某种启发式方法决定的。</p>
<p>无论位置服务以何种方式解析副本组，关键的好处是间接性：位置服务作为中间人可以为绑定过程添加更多智能。</p>
<p>Servants<br>As we mentioned, an Ice Object is a conceptual entity that has a type, identity, and addressing information. However, client requests ultimately must end up with a concrete server-side processing entity that can provide the behavior for an operation invocation. To put this differently, a client request must ultimately end up executing code inside the server, with that code written in a specific programming language and executing on a specific processor.</p>
<p>The server-side artifact that provides behavior for operation invocations is known as a servant. A servant provides substance for (or incarnates) one or more Ice objects. In practice, a servant is simply an instance of a class that is written by the server developer and that is registered with the server-side run time as the servant for one or more Ice objects. Methods on the class correspond to the operations on the Ice object’s interface and provide the behavior for the operations.</p>
<p>A single servant can incarnate a single Ice object at a time or several Ice objects simultaneously. If the former, the identity of the Ice object incarnated by the servant is implicit in the servant. If the latter, the servant is provided the identity of the Ice object with each request, so it can decide which object to incarnate for the duration of the request.</p>
<p>Conversely, a single Ice object can have multiple servants. For example, we might choose to create a proxy for an Ice object with two different addresses for different machines. In that case, we will have two servers, with each server containing a servant for the same Ice object. When a client invokes an operation on such an Ice object, the client-side run time sends the request to exactly one server. In other words, multiple servants for a single Ice object allow you to build redundant systems: the client-side run time attempts to send the request to one server and, if that attempt fails, sends the request to the second server. An error is reported back to the client-side application code only if that second attempt also fails.</p>
<p>servant<br>正如我们提到的，Ice 对象是一个概念实体，具有类型、标识和寻址信息。 然而，客户端请求最终必须以一个具体的服务器端处理实体结束，该实体可以提供操作调用的行为。 换句话说，客户端请求最终必须在服务器内部执行代码，该代码用特定的编程语言编写并在特定的处理器上执行。</p>
<p>为操作调用提供行为的服务器端工件称为servant。 servant为一个或多个Ice 对象提供实例。 实际上，servant 只是由服务器开发人员编写的类的一个实例，并且在服务器端运行时注册为一个或多个 Ice 对象的servant。 类上的方法对应于 Ice 对象接口上的操作，并提供操作的行为。</p>
<p>单个servant可以一次化身一个 Ice 对象，也可以同时化身多个 Ice 对象。 如果是前者，servant所化身的Ice对象的身份就隐含在servant中。 如果是后者，则每次请求时都会向servant提供Ice对象的标识，因此它可以决定在请求期间具体化哪个对象。</p>
<p>相反，单个 Ice 对象可以有多个servant。 例如，我们可能选择为 Ice 对象创建一个代理，为不同的机器提供两个不同的地址。 在这种情况下，我们将有两个服务器，每个服务器都包含同一个 Ice 对象的servant。 当客户端调用此类 Ice 对象上的操作时，客户端运行时会将请求发送到一台服务器。 换句话说，单个 Ice 对象的多个servant 允许您构建冗余系统：客户端运行时尝试将请求发送到一台服务器，如果该尝试失败，则将请求发送到第二台服务器。 仅当第二次尝试也失败时，才会向客户端应用程序代码报告错误。</p>
<p>At-Most-Once Semantics<br>Ice requests have at-most-once semantics: the Ice run time does its best to deliver a request to the correct destination and, depending on the exact circumstances, may retry a failed request. Ice guarantees that it will either deliver the request, or, if it cannot deliver the request, inform the client with an appropriate exception; under no circumstances is a request delivered twice, that is, retries are attempted only if it is known that a previous attempt definitely failed.</p>
<p>One exception to this rule are datagram invocations over UDP transports. For these, duplicated UDP packets can lead to a violation of at-most-once semantics.</p>
<p>At-most-once semantics are important because they guarantee that operations that are not idempotent can be used safely. An idempotent operation is an operation that, if executed twice, has the same effect as if executed once. For example, x = 1; is an idempotent operation: if we execute the operation twice, the end result is the same as if we had executed it once. On the other hand, x++; is not idempotent: if we execute the operation twice, the end result is not the same as if we had executed it once.</p>
<p>Without at-most-once semantics, we can build distributed systems that are more robust in the presence of network failures. However, realistic systems require non-idempotent operations, so at-most-once semantics are a necessity, even though they make the system less robust in the presence of network failures. Ice permits you to mark individual operations as idempotent. For such operations, the Ice run time uses a more aggressive error recovery mechanism than for non-idempotent operations.</p>
<p>至多一次语义<br>Ice 请求具有至多一次语义：Ice 运行时会尽力将请求传递到正确的目的地，并且根据具体情况，可能会重试失败的请求。 Ice 保证它将交付请求，或者如果无法交付请求，则通知客户端并提供适当的例外； 在任何情况下，请求都不会发送两次，也就是说，只有在知道前一次尝试肯定失败的情况下才会尝试重试。</p>
<p>此规则的一个例外是通过 UDP 传输的数据报调用。 对于这些，重复的 UDP 数据包可能会导致违反最多一次语义。</p>
<p>至多一次语义很重要，因为它们保证可以安全地使用非幂等的操作。 幂等操作是指执行两次具有与执行一次相同效果的操作。 例如，x=1； 是一个幂等操作：如果我们执行该操作两次，最终结果与执行一次相同。 另一方面，x++； 不是幂等的：如果我们执行该操作两次，最终结果与执行一次不同。</p>
<p>没有至多一次语义，我们可以构建在出现网络故障时更加健壮的分布式系统。 然而，现实系统需要非幂等操作，因此至多一次语义是必要的，即使它们使系统在出现网络故障时变得不那么健壮。 Ice 允许您将单个操作标记为幂等。 对于此类操作，Ice run time 使用比非幂等操作更积极的错误恢复机制。</p>
<p>Synchronous Method Invocation<br>By default, the request dispatch model used by Ice is a synchronous remote procedure call: an operation invocation behaves like a local procedure call, that is, the client thread is suspended for the duration of the call and resumes when the call completes (and all its results are available).</p>
<p>同步方法调用<br>默认情况下，Ice 使用的请求调度模型是同步远程过程调用：操作调用的行为类似于本地过程调用，即客户端线程在调用期间挂起，并在调用完成时恢复（并且所有 其结果是可用的）。</p>
<p>Asynchronous Method Invocation<br>Ice also supports asynchronous method invocation (AMI): a client can invoke operations asynchronously, which means the client’s calling thread does not block while waiting for the invocation to complete. The client passes the normal parameters and, depending on the language mapping, might also pass a callback that the client-side run time invokes upon completion, or the invocation might return a future that the client can eventually use to obtain the results.</p>
<p>The server cannot distinguish an asynchronous invocation from a synchronous one — either way, the server simply sees that a client has invoked an operation on an object.</p>
<p>异步方法调用<br>Ice还支持异步方法调用（AMI）：客户端可以异步调用操作，这意味着客户端的调用线程在等待调用完成时不会阻塞。 客户端传递普通参数，并且根据语言映射，还可能传递客户端运行时在完成时调用的回调，或者调用可能返回客户端最终可以用来获取结果的 future。</p>
<p>服务器无法区分异步调用和同步调用——无论哪种方式，服务器都只是看到客户端调用了对象上的操作。</p>
<p>Asynchronous Method Dispatch<br>Asynchronous method dispatch (AMD) is the server-side equivalent of AMI. For synchronous dispatch (the default), the server-side run time up-calls into the application code in the server in response to an operation invocation. While the operation is executing (or sleeping, for example, because it is waiting for data), a thread of execution is tied up in the server; that thread is released only when the operation completes.</p>
<p>With asynchronous method dispatch, the server-side application code is informed of the arrival of an operation invocation. However, instead of being forced to process the request immediately, the server-side application can choose to delay processing of the request and, in doing so, releases the execution thread for the request. The server-side application code is now free to do whatever it likes. Eventually, once the results of the operation are available, the server-side application code makes an API call to inform the server-side Ice run time that a request that was dispatched previously is now complete; at that point, the results of the operation are returned to the client.</p>
<p>Asynchronous method dispatch is useful if, for example, a server offers operations that block clients for an extended period of time. For example, the server may have an object with a get operation that returns data from an external, asynchronous data source and that blocks clients until the data becomes available. With synchronous dispatch, each client waiting for data to arrive ties up an execution thread in the server. Clearly, this approach does not scale beyond a few dozen clients. With asynchronous dispatch, hundreds or thousands of clients can be blocked in the same operation invocation without tying up any threads in the server.</p>
<p>Synchronous and asynchronous method dispatch are transparent to the client, that is, the client cannot tell whether a server chose to process a request synchronously or asynchronously.</p>
<p>异步方法分派<br>异步方法分派 (AMD) 是 AMI 的服务器端等效项。 对于同步调度（默认），服务器端运行时向上调用服务器中的应用程序代码以响应操作调用。 当操作正在执行时（或者休眠，例如，因为它正在等待数据），执行线程被绑定在服务器中； 仅当操作完成时该线程才会被释放。</p>
<p>通过异步方法分派，服务器端应用程序代码会收到操作调用到达的通知。 然而，服务器端应用程序可以选择延迟处理请求，并释放请求的执行线程，而不是被迫立即处理请求。 服务器端应用程序代码现在可以自由地执行任何操作。 最终，一旦操作结果可用，服务器端应用程序代码就会进行 API 调用，通知服务器端 Ice run time 之前分派的请求现已完成； 此时，操作结果将返回给客户端。</p>
<p>例如，如果服务器提供长时间阻塞客户端的操作，则异步方法分派非常有用。 例如，服务器可能有一个带有 get 操作的对象，该操作从外部异步数据源返回数据，并阻止客户端直到数据可用。 通过同步调度，每个等待数据到达的客户端都会占用服务器中的一个执行线程。 显然，这种方法的规模不能超过几十个客户。 通过异步分派，可以在同一个操作调用中阻止数百或数千个客户端，而不会占用服务器中的任何线程。</p>
<p>同步和异步方法分派对客户端来说是透明的，也就是说，客户端无法判断服务器选择同步还是异步处理请求。</p>
<p>Oneway Method Invocation<br>Clients can invoke an operation as a oneway operation. A oneway invocation has “best effort” semantics. For a oneway invocation, the client-side run time hands the invocation to the local transport, and the invocation completes on the client side as soon as the local transport has buffered the invocation. The actual invocation is then sent asynchronously by the operating system. The server does not reply to oneway invocations, that is, traffic flows only from client to server, but not vice versa.</p>
<p>Oneway invocations are unreliable. For example, the target object may not exist, in which case the invocation is simply lost. Similarly, the operation may be dispatched to a servant in the server, but the operation may fail (for example, because parameter values are invalid); if so, the client receives no notification that something has gone wrong.</p>
<p>Oneway invocations are possible only on operations that do not have a return value, do not have out-parameters, and do not throw user exceptions.</p>
<p>To the application code on the server-side, oneway invocations are transparent, that is, there is no way to distinguish a twoway invocation from a oneway invocation.</p>
<p>Oneway invocations are available only if the target object offers a stream-oriented transport, such as TCP/IP or SSL.</p>
<p>Note that, even though oneway operations are sent over a stream-oriented transport, they may be processed out of order in the server. This can happen because each invocation may be dispatched in its own thread: even though the invocations are initiated in the order in which the invocations arrive at the server, this does not mean that they will be processed in that order — the vagaries of thread scheduling can result in a oneway invocation completing before other oneway invocations that were received earlier.</p>
<p>单向方法调用<br>客户端可以将操作作为单向操作来调用。 单向调用具有“尽力而为”的语义。 对于单向调用，客户端运行时将调用交给本地传输，并且一旦本地传输缓冲了该调用，该调用就会在客户端完成。 然后，操作系统异步发送实际的调用。 服务器不回复单向调用，即流量仅从客户端流向服务器，反之则不然。</p>
<p>单向调用是不可靠的。 例如，目标对象可能不存在，在这种情况下，调用就会丢失。 类似地，操作可能会被调度到服务器中的servant，但操作可能会失败（例如，因为参数值无效）； 如果是这样，客户端不会收到出现问题的通知。</p>
<p>单向调用仅适用于没有返回值、没有输出参数并且不引发用户异常的操作。</p>
<p>对于服务器端的应用程序代码来说，单向调用是透明的，即无法区分双向调用和单向调用。</p>
<p>仅当目标对象提供面向流的传输（例如 TCP/IP 或 SSL）时，单向调用才可用。</p>
<p>请注意，即使单向操作是通过面向流的传输发送的，它们在服务器中的处理也可能是无序的。 发生这种情况是因为每个调用都可能在其自己的线程中分派：即使调用是按照调用到达服务器的顺序启动的，但这并不意味着它们将按照该顺序进行处理 - 线程调度的变幻莫测 可能会导致单向调用先于之前收到的其他单向调用完成。</p>
<p>Batched Oneway Method Invocation<br>Each oneway invocation sends a separate message to the server. For a series of short messages, the overhead of doing so is considerable: the client- and server-side run time each must switch between user mode and kernel mode for each message and, at the networking level, each message incurs the overheads of flow-control and acknowledgement.</p>
<p>Batched oneway invocations allow you to send a series of oneway invocations as a single message: every time you invoke a batched oneway operation, the invocation is buffered in the client-side run time. Once you have accumulated all the oneway invocations you want to send, you make a separate API call to send all the invocations at once. The client-side run time then sends all of the buffered invocations in a single message, and the server receives all of the invocations in a single message. This avoids the overhead of repeatedly trapping into the kernel for both client and server, and is much easier on the network between them because one large message can be transmitted more efficiently than many small ones.</p>
<p>The individual invocations in a batched oneway message are dispatched by a single thread in the order in which they were placed into the batch. This guarantees that the individual operations in a batched oneway message are processed in order in the server.</p>
<p>Batched oneway invocations are particularly useful for messaging services, such as IceStorm, and for fine-grained interfaces that offer set operations for small attributes.</p>
<p>批量单向方法调用<br>每个单向调用都会向服务器发送一条单独的消息。 对于一系列短消息来说，这样做的开销是相当大的：客户端和服务器端运行时都必须为每条消息在用户模式和内核模式之间切换，并且在网络层面，每条消息都会产生流的开销 -控制和确认。</p>
<p>批量单向调用允许您将一系列单向调用作为单个消息发送：每次调用批量单向操作时，该调用都会在客户端运行时进行缓冲。 一旦您积累了要发送的所有单向调用，您就可以进行单独的 API 调用来一次发送所有调用。 然后，客户端运行时在单个消息中发送所有缓冲的调用，并且服务器在单个消息中接收所有调用。 这避免了客户端和服务器重复陷入内核的开销，并且在它们之间的网络上更容易，因为一条大消息可以比许多小消息更有效地传输。</p>
<p>批处理单向消息中的各个调用由单个线程按照它们放入批处理的顺序进行调度。 这保证了批量单向消息中的各个操作在服务器中按顺序处理。</p>
<p>批量单向调用对于消息服务（例如 IceStorm）以及为小属性提供设置操作的细粒度接口特别有用。</p>
<p>Datagram Invocations<br>Datagram invocations have “best effort” semantics similar to oneway invocations. However, datagram invocations require the object to offer UDP as a transport (whereas oneway invocations require TCP/IP).</p>
<p>Like a oneway invocation, a datagram invocation can be made only if the operation does not have a return value, out-parameters, or user exceptions. A datagram invocation uses UDP to invoke the operation. The operation returns as soon as the local UDP stack has accepted the message; the actual operation invocation is sent asynchronously by the network stack behind the scenes.</p>
<p>Datagrams, like oneway invocations, are unreliable: the target object may not exist in the server, the server may not be running, or the operation may be invoked in the server but fail due to invalid parameters sent by the client. As for oneway invocations, the client receives no notification of such errors.</p>
<p>However, unlike oneway invocations, datagram invocations have a number of additional error scenarios:</p>
<p>Individual invocations may simply be lost in the network.<br>This is due to the unreliable delivery of UDP packets. For example, if you invoke three operations in sequence, the middle invocation may be lost. (The same thing cannot happen for oneway invocations — because they are delivered over a connection-oriented transport, individual invocations cannot be lost.)<br>Individual invocations may arrive out of order.<br>Again, this is due to the nature of UDP datagrams. Because each invocation is sent as a separate datagram, and individual datagrams can take different paths through the network, it can happen that invocations arrive in an order that differs from the order in which they were sent.<br>Datagram invocations are well suited for small messages on LANs, where the likelihood of loss is small. They are also suited to situations in which low latency is more important than reliability, such as for fast, interactive internet applications. Finally, datagram invocations can be used to multicast messages to multiple servers simultaneously.</p>
<p>数据报调用<br>数据报调用具有与单向调用类似的“尽力而为”语义。 然而，数据报调用要求对象提供 UDP 作为传输（而单向调用则需要 TCP/IP）。</p>
<p>与单向调用一样，仅当操作没有返回值、输出参数或用户异常时才能进行数据报调用。 数据报调用使用 UDP 来调用操作。 一旦本地 UDP 堆栈接受了消息，操作就会返回； 实际的操作调用由幕后的网络堆栈异步发送。</p>
<p>数据报与单向调用一样，是不可靠的：目标对象可能不存在于服务器中，服务器可能未运行，或者操作可能在服务器中调用但由于客户端发送的无效参数而失败。 对于单向调用，客户端不会收到此类错误的通知。</p>
<p>然而，与单向调用不同，数据报调用有许多额外的错误场景：</p>
<p>单独的调用可能会在网络中丢失。<br>这是由于 UDP 数据包的传送不可靠造成的。 例如，如果您依次调用三个操作，则中间的调用可能会丢失。 （对于单向调用，不会发生同样的情况 - 因为它们是通过面向连接的传输传递的，单个调用不会丢失。）<br>个别调用可能会无序到达。<br>同样，这是由 UDP 数据报的性质决定的。 由于每个调用都作为单独的数据报发送，并且各个数据报可以采用不同的网络路径，因此调用到达的顺序可能与其发送的顺序不同。<br>数据报调用非常适合 LAN 上的小消息，因为丢失的可能性很小。 它们还适合低延迟比可靠性更重要的情况，例如快速、交互式互联网应用程序。 最后，数据报调用可用于同时将消息多播到多个服务器。</p>
<p>Batched Datagram Invocations<br>As for batched oneway invocations, batched datagram invocations allow you to accumulate a number of invocations in a buffer and then send the entire buffer as a single datagram by making an API call to flush the buffer. Batched datagrams reduce the overhead of repeated system calls and allow the underlying network to operate more efficiently. However, batched datagram invocations are useful only for batched messages whose total size does not substantially exceed the PDU limit of the network: if the size of a batched datagram gets too large, UDP fragmentation makes it more likely that one or more fragments are lost, which results in the loss of the entire batched message. However, you are guaranteed that either all invocations in a batch will be delivered, or none will be delivered. It is impossible for individual invocations within a batch to be lost.</p>
<p>Batched datagrams use a single thread in the server to dispatch the individual invocations in a batch. This guarantees that the invocations are made in the order in which they were queued — invocations cannot appear to be reordered in the server.</p>
<p>批量数据报调用<br>对于批量单向调用，批量数据报调用允许您在缓冲区中累积多个调用，然后通过调用 API 来刷新缓冲区，将整个缓冲区作为单个数据报发送。 批量数据报减少了重复系统调用的开销，并允许底层网络更有效地运行。 但是，批处理数据报调用仅适用于总大小未大幅超出网络 PDU 限制的批处理消息：如果批处理数据报的大小变得太大，则 UDP 碎片更有可能丢失一个或多个碎片， 这会导致整个批量消息丢失。 但是，您可以保证批次中的所有调用都将被传递，或者不会被传递。 批次内的各个调用不可能丢失。</p>
<p>批量数据报使用服务器中的单个线程来批量分派各个调用。 这保证了调用按照它们排队的顺序进行——调用在服务器中不会被重新排序。</p>
<p>Run-Time Exceptions<br>Any operation invocation can raise a run-time exception. Run-time exceptions are pre-defined by the Ice run time and cover common error conditions, such as connection failure, connection timeout, or resource allocation failure. Run-time exceptions are presented to the application as native exceptions and so integrate neatly with the native exception handling capabilities of languages that support exception handling.</p>
<p>运行时异常<br>任何操作调用都可能引发运行时异常。 运行时异常是由 Ice run time 预先定义的，涵盖常见的错误情况，例如连接失败、连接超时或资源分配失败。 运行时异常作为本机异常呈现给应用程序，因此与支持异常处理的语言的本机异常处理功能巧妙地集成。</p>
<p>User Exceptions<br>A server indicates application-specific error conditions by raising user exceptions to clients. User exceptions can carry an arbitrary amount of complex data and can be arranged into inheritance hierarchies, which makes it easy for clients to handle categories of errors generically, by catching an exception that is further up the inheritance hierarchy. Like run-time exceptions, user exceptions map to native exceptions.</p>
<p>用户异常<br>服务器通过向客户端引发用户异常来指示特定于应用程序的错误情况。 用户异常可以携带任意数量的复杂数据，并且可以排列成继承层次结构，这使得客户端可以通过捕获继承层次结构中更高的异常来轻松地一般处理错误类别。 与运行时异常一样，用户异常映射到本机异常。</p>
<p>Properties<br>Much of the Ice run time is configurable via properties. Properties are name-value pairs, such as Ice.Default.Protocol=tcp. Properties are typically stored in text files and parsed by the Ice run time to configure various options, such as the thread pool size, the level of tracing, and various other configuration parameters.</p>
<p>属性<br>Ice 的大部分运行时间都可以通过属性进行配置。 属性是名称-值对，例如 Ice.Default.Protocol=tcp。 属性通常存储在文本文件中，并由 Ice 运行时解析以配置各种选项，例如线程池大小、跟踪级别以及各种其他配置参数。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://qianqians.github.io/2023/10/11/ubuntu_mongodb/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="qianqians">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="qianqians'blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/10/11/ubuntu_mongodb/" class="post-title-link" itemprop="url">ubuntu_mongodb</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-10-11 21:15:35" itemprop="dateCreated datePublished" datetime="2023-10-11T21:15:35+08:00">2023-10-11</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-11-24 15:26:57" itemprop="dateModified" datetime="2023-11-24T15:26:57+08:00">2023-11-24</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/ubuntu/" itemprop="url" rel="index"><span itemprop="name">ubuntu</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/mongodb/" itemprop="url" rel="index"><span itemprop="name">mongodb</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><a target="_blank" rel="noopener" href="https://askubuntu.com/questions/823288/mongodb-loads-but-breaks-returning-status-14">https://askubuntu.com/questions/823288/mongodb-loads-but-breaks-returning-status-14</a></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sudo <span class="built_in">chown</span> -R mongodb:mongodb /var/lib/mongodb</span><br><span class="line">sudo <span class="built_in">chown</span> mongodb:mongodb /tmp/mongodb-27017.sock</span><br><span class="line"></span><br><span class="line">sudo service mongod restart</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://qianqians.github.io/2023/07/23/unity%E5%BE%AE%E4%BF%A1%E5%B0%8F%E6%B8%B8%E6%88%8F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="qianqians">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="qianqians'blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/07/23/unity%E5%BE%AE%E4%BF%A1%E5%B0%8F%E6%B8%B8%E6%88%8F/" class="post-title-link" itemprop="url">微信小游戏 unity websocket</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2023-07-23 15:20:31 / 修改时间：15:25:21" itemprop="dateCreated datePublished" datetime="2023-07-23T15:20:31+08:00">2023-07-23</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E6%B8%B8%E6%88%8F/" itemprop="url" rel="index"><span itemprop="name">微信小游戏</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <ol>
<li><a target="_blank" rel="noopener" href="https://github.com/wechat-miniprogram/minigame-unity-webgl-transform">https://github.com/wechat-miniprogram/minigame-unity-webgl-transform</a></li>
<li>websocket使用<a target="_blank" rel="noopener" href="https://github.com/psygames/UnityWebSocket">https://github.com/psygames/UnityWebSocket</a></li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://qianqians.github.io/2023/07/06/Rust%E5%BC%80%E5%8F%91%E5%B0%8F%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="qianqians">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="qianqians'blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/07/06/Rust%E5%BC%80%E5%8F%91%E5%B0%8F%E8%AE%B0/" class="post-title-link" itemprop="url">Rust开发小记</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-07-06 20:05:45" itemprop="dateCreated datePublished" datetime="2023-07-06T20:05:45+08:00">2023-07-06</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-11-20 11:23:32" itemprop="dateModified" datetime="2023-11-20T11:23:32+08:00">2023-11-20</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Rust/" itemprop="url" rel="index"><span itemprop="name">Rust</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <ol>
<li><p>多线程共享trait</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">trait</span> <span class="title class_">T</span> &#123;&#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">B</span> &#123;&#125;</span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">T</span> <span class="keyword">for</span> <span class="title class_">B</span> &#123;&#125;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">p</span>: Arc&lt;Mutex&lt;<span class="type">Box</span>&lt;<span class="keyword">dyn</span> T&gt;&gt;&gt; = Arc::<span class="title function_ invoke__">new</span>(Mutex::<span class="title function_ invoke__">new</span>(<span class="type">Box</span>::<span class="title function_ invoke__">new</span>(B&#123;&#125;)))</span><br></pre></td></tr></table></figure>
<p>需要注意struct类型的对象和trait之间不能互转,比如:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">trait</span> <span class="title class_">T</span> &#123;&#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">B</span> &#123;&#125;</span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">T</span> <span class="keyword">for</span> <span class="title class_">B</span> &#123;&#125;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">p</span>: Arc&lt;Mutex&lt;<span class="type">Box</span>&lt;B&gt;&gt;&gt; = Arc::<span class="title function_ invoke__">new</span>(Mutex::<span class="title function_ invoke__">new</span>(<span class="type">Box</span>::<span class="title function_ invoke__">new</span>(B&#123;&#125;)))</span><br><span class="line"><span class="keyword">let</span> <span class="variable">p_trait</span>: Arc&lt;Mutex&lt;<span class="type">Box</span>&lt;<span class="keyword">dyn</span> T&gt;&gt;&gt; = p <span class="comment">//会编译不过</span></span><br></pre></td></tr></table></figure></li>
<li><p>trait中声明async函数</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[async_trait]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">trait</span> <span class="title class_">T</span> &#123;</span><br><span class="line">    <span class="keyword">async</span> <span class="keyword">fn</span> <span class="title function_">send</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, buf: &amp;[<span class="type">u8</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>生命周期标注</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::fs;</span><br><span class="line"><span class="keyword">use</span> std::io;</span><br><span class="line"><span class="keyword">use</span> serde::&#123;Deserialize, Serialize&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">load_data_from_file</span>(cfg_file: <span class="type">String</span>) <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;<span class="type">String</span>, io::Error&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">data</span> = fs::<span class="title function_ invoke__">read_to_string</span>(cfg_file)?;</span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(data)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">load_cfg_from_data</span>&lt;<span class="symbol">&#x27;a</span>, C: Deserialize&lt;<span class="symbol">&#x27;a</span>&gt; + Serialize&gt;(data: &amp;<span class="symbol">&#x27;a</span> <span class="type">String</span>) <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;C, io::Error&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">cfg</span>: C = serde_json::from_str::&lt;C&gt;(&amp;data)?;</span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(cfg)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>data在外部调用load_data_from_file获取,然后调用load_cfg_from_data时传入<br>如在load_cfg_from_data中读取写做:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::fs;</span><br><span class="line"><span class="keyword">use</span> std::io;</span><br><span class="line"><span class="keyword">use</span> serde::&#123;Deserialize, Serialize&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">load_data_from_file</span>(cfg_file: <span class="type">String</span>) <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;<span class="type">String</span>, io::Error&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">data</span> = fs::<span class="title function_ invoke__">read_to_string</span>(cfg_file)?;</span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(data)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">load_cfg_from_data</span>&lt;<span class="symbol">&#x27;a</span>, C: Deserialize&lt;<span class="symbol">&#x27;a</span>&gt; + Serialize&gt;(cfg_file: <span class="type">String</span>) <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;C, io::Error&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">data</span> = <span class="title function_ invoke__">load_data_from_file</span>(cfg_file)?;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">cfg</span>: C = serde_json::from_str::&lt;C&gt;(&amp;data)?;</span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(cfg)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>会编译不过</p>
</li>
<li><p>tokio::spawn拉起线程,传入的变量使用Arc&lt;Mutex<H>&gt;,clone后传入</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">async</span> <span class="keyword">fn</span> <span class="title function_">f</span>(_handle: Arc&lt;Mutex&lt;H&gt;&gt;) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">_clone_h</span> = _handle.<span class="title function_ invoke__">clone</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">_join</span> = tokio::<span class="title function_ invoke__">spawn</span>(<span class="keyword">async</span> <span class="keyword">move</span> &#123;</span><br><span class="line">        <span class="keyword">loop</span> &#123;</span><br><span class="line">            <span class="comment">//...</span></span><br><span class="line">            </span><br><span class="line">            <span class="keyword">let</span> <span class="variable">_clone_handle</span> = _clone_h.<span class="title function_ invoke__">clone</span>();</span><br><span class="line">            <span class="comment">//...              </span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>Future:<a target="_blank" rel="noopener" href="https://juejin.cn/post/6844903973950849031">https://juejin.cn/post/6844903973950849031</a></p>
</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://qianqians.github.io/2023/05/31/%E9%A3%9E%E8%A1%8C%E6%A3%8B%E5%BC%80%E5%8F%91%E6%89%8B%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="qianqians">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="qianqians'blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/05/31/%E9%A3%9E%E8%A1%8C%E6%A3%8B%E5%BC%80%E5%8F%91%E6%89%8B%E8%AE%B0/" class="post-title-link" itemprop="url">飞行棋开发手记</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2023-05-31 14:12:19 / 修改时间：14:37:41" itemprop="dateCreated datePublished" datetime="2023-05-31T14:12:19+08:00">2023-05-31</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E6%B8%B8%E6%88%8F/" itemprop="url" rel="index"><span itemprop="name">微信小游戏</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <ol>
<li><p>Cosos Creator Asset Bundle <a target="_blank" rel="noopener" href="https://docs.cocos.com/creator/manual/zh/asset/bundle.html">https://docs.cocos.com/creator/manual/zh/asset/bundle.html</a><br>因为前期没用合理的划分管理资源，不同scene之间共用资源较多，按资源打bundle远程加载比较麻烦，所以飞行棋选择了直接按scene打bundle，实际操作效果不错，加载scene的时候远程加载既可</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">assetManager.loadBundle(<span class="string">&#x27;main_scene&#x27;</span>, <span class="keyword">async</span> (err, bundle) =&gt; &#123;</span><br><span class="line">    bundle.loadScene(sceneName, <span class="function"><span class="keyword">function</span> (<span class="params">err, scene</span>) </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;);</span><br><span class="line">    ...</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li>
<li><p>微信小游戏iphone不支持.m4a格式的音频，改为mp3格式运行正常</p>
</li>
<li><p>Cosos Creator ScrollView组件 </p>
<ol>
<li>滚动后会弹回初始位置，将Bounce Duration属性设置为最大值10，可以模拟不弹回的状态</li>
<li>默认状态可以滚动到无限远，需要在程序中响应ScrollView.EventType.SCROLLING事件控制<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">this</span>.view.node.on(ScrollView.EventType.SCROLLING, <span class="built_in">this</span>.scrolling_callback, <span class="built_in">this</span>);</span><br><span class="line"><span class="function"><span class="title">scrolling_callback</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> pos = <span class="built_in">this</span>.view.getScrollOffset().y;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pos &lt; - <span class="number">200</span>) &#123;</span><br><span class="line">        <span class="built_in">this</span>.view.scrollToOffset(<span class="keyword">new</span> Vec2(<span class="number">0</span>, pos), <span class="number">10</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (pos &gt; <span class="built_in">this</span>.bottom + <span class="number">200</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> maxScrollOffset = <span class="built_in">this</span>.view.getMaxScrollOffset();</span><br><span class="line">        <span class="built_in">this</span>.view.scrollToOffset(<span class="keyword">new</span> Vec2(<span class="number">0</span>, maxScrollOffset.y), <span class="number">10</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li><p>切换scene，会导致上一次的scene失效，需要重新加载scene(bundle不会失效)</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">singleton.netSingleton.bundle.loadScene(<span class="string">&#x27;main&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">err, scene</span>) </span>&#123;</span><br><span class="line">    director.runScene(scene);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li>
<li><p>director.addPersistRootNode(this.node)</p>
</li>
<li><p>tilemap坐标转cocos creator场景坐标</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">target_x = pos.x * <span class="number">64</span> + <span class="number">32</span> - game_data.layout_half_width;</span><br><span class="line">target_y=  pos.y * <span class="number">64</span> + <span class="number">32</span> - game_data.layout_half_height;</span><br><span class="line">...</span><br></pre></td></tr></table></figure></li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://qianqians.github.io/2023/05/22/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E6%B8%B8%E6%88%8F%E7%99%BB%E5%BD%95%E6%B5%81%E7%A8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="qianqians">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="qianqians'blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/05/22/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E6%B8%B8%E6%88%8F%E7%99%BB%E5%BD%95%E6%B5%81%E7%A8%8B/" class="post-title-link" itemprop="url">微信小游戏登录流程</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2023-05-22 14:24:07 / 修改时间：14:48:09" itemprop="dateCreated datePublished" datetime="2023-05-22T14:24:07+08:00">2023-05-22</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E6%B8%B8%E6%88%8F/" itemprop="url" rel="index"><span itemprop="name">微信小游戏</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>cocos creator 登录流程</p>
<ol>
<li><p>安装minigame-api-typings </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install minigame-api-typings</span><br></pre></td></tr></table></figure></li>
<li><p>代码中引用import ‘minigame-api-typings’;</p>
</li>
<li><p>调用wx登录接口</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">wx.login(&#123;</span><br><span class="line">    <span class="attr">complete</span>: <span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;login complete:&quot;</span> + <span class="built_in">JSON</span>.stringify(res));</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">fail</span>: <span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">         <span class="built_in">console</span>.log(<span class="string">&quot;login fail:&quot;</span> + <span class="built_in">JSON</span>.stringify(res));</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">success</span>: <span class="function">(<span class="params">login_res</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;login success:&quot;</span> + <span class="built_in">JSON</span>.stringify(login_res));</span><br><span class="line">        wx.getSetting(&#123;</span><br><span class="line">            <span class="attr">complete</span>: <span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">                <span class="built_in">console</span>.log(<span class="string">&quot;authSetting complete:&quot;</span>, <span class="built_in">JSON</span>.stringify(res));</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">fail</span>: <span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">                <span class="built_in">console</span>.log(<span class="string">&quot;authSetting fail:&quot;</span>, <span class="built_in">JSON</span>.stringify(res));</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">success</span>: <span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">                <span class="built_in">console</span>.log(<span class="string">&quot;authSetting:&quot;</span>, <span class="built_in">JSON</span>.stringify(res));</span><br><span class="line">                <span class="keyword">if</span> (res.authSetting[<span class="string">&#x27;scope.userInfo&#x27;</span>]) &#123;</span><br><span class="line">                    <span class="built_in">this</span>.get_user_info_login(login_res.code)</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">let</span> wxSize = wx.getSystemInfoSync();</span><br><span class="line">                    <span class="keyword">let</span> btn = wx.createUserInfoButton(&#123;</span><br><span class="line">                        <span class="attr">type</span>: <span class="string">&#x27;text&#x27;</span>,</span><br><span class="line">                        <span class="attr">text</span>: <span class="string">&#x27;微信登录&#x27;</span>,</span><br><span class="line">                        <span class="attr">style</span>: &#123;</span><br><span class="line">                            <span class="attr">left</span>: wxSize.screenWidth / <span class="number">2</span> - <span class="number">100</span>,</span><br><span class="line">                            <span class="attr">top</span>: wxSize.screenHeight / <span class="number">2</span> - <span class="number">40</span>,</span><br><span class="line">                            <span class="attr">width</span>: <span class="number">200</span>,</span><br><span class="line">                            <span class="attr">height</span>: <span class="number">40</span>,</span><br><span class="line">                            <span class="attr">lineHeight</span>: <span class="number">40</span>,</span><br><span class="line">                            <span class="attr">backgroundColor</span>: <span class="string">&#x27;#ffffff&#x27;</span>,</span><br><span class="line">                            <span class="attr">borderColor</span>: <span class="string">&#x27;#ffffff&#x27;</span>,</span><br><span class="line">                            <span class="attr">borderWidth</span>: <span class="number">1</span>,</span><br><span class="line">                            <span class="attr">color</span>: <span class="string">&#x27;#000000&#x27;</span>,</span><br><span class="line">                            <span class="attr">textAlign</span>: <span class="string">&#x27;center&#x27;</span>,</span><br><span class="line">                            <span class="attr">fontSize</span>: <span class="number">16</span>,</span><br><span class="line">                            <span class="attr">borderRadius</span>: <span class="number">4</span></span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line">                    btn.onTap(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">                        <span class="built_in">console</span>.log(<span class="string">&quot;createUserInfoButton:&quot;</span> + <span class="built_in">JSON</span>.stringify(res));</span><br><span class="line">                        <span class="built_in">this</span>.get_user_info_login(login_res.code)</span><br><span class="line">                         btn.destroy();</span><br><span class="line">                    &#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">get_user_info_login</span>(<span class="params">code:string</span>)</span> &#123;</span><br><span class="line">    wx.getUserInfo(&#123; </span><br><span class="line">        <span class="attr">withCredentials</span>:<span class="literal">false</span>,</span><br><span class="line">        <span class="attr">success</span>: <span class="function">(<span class="params">result</span>) =&gt;</span> &#123;</span><br><span class="line">            login.login_player_no_author(code, result.userInfo.nickName, result.userInfo.avatarUrl);</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">fail</span>: <span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">&quot;fail:&quot;</span> + <span class="built_in">JSON</span>.stringify(res));</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">complete</span>: <span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">&quot;complete:&quot;</span> + <span class="built_in">JSON</span>.stringify(res));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>login_player_no_author接口上传code到服务器端,服务器端收到code之后通过http请求到微信后台验证(AppID,Secret从微信小游戏管理后台获取):</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> url = <span class="string">$&quot;https://api.weixin.qq.com/sns/jscode2session?appid=<span class="subst">&#123;AppID&#125;</span>&amp;secret=<span class="subst">&#123;Secret&#125;</span>&amp;js_code=<span class="subst">&#123;code&#125;</span>&amp;grant_type=authorization_code&quot;</span>;</span><br><span class="line"><span class="keyword">var</span> result = <span class="keyword">await</span> HttpClientWrapper.GetRspAsync(url);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (result != <span class="literal">null</span> &amp;&amp; result.StatusCode == System.Net.HttpStatusCode.OK)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">var</span> ret = <span class="keyword">await</span> result.Content.ReadAsStringAsync();</span><br><span class="line">    <span class="keyword">var</span> ret_obj = Newtonsoft.Json.JsonConvert.DeserializeObject&lt;Hashtable&gt;(ret);</span><br><span class="line">    <span class="keyword">var</span> token = <span class="keyword">await</span> player.client_Mng.token_player_login(ret_obj[<span class="string">&quot;openid&quot;</span>] <span class="keyword">as</span> <span class="built_in">string</span>);</span><br><span class="line">    rsp.rsp(token);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://qianqians.github.io/2021/09/15/Wgpu%20Working%20with%20Lights/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="qianqians">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="qianqians'blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/09/15/Wgpu%20Working%20with%20Lights/" class="post-title-link" itemprop="url">Wgpu Working with Lights</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-09-15 15:18:49" itemprop="dateCreated datePublished" datetime="2021-09-15T15:18:49+08:00">2021-09-15</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-09-16 12:00:10" itemprop="dateModified" datetime="2021-09-16T12:00:10+08:00">2021-09-16</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Wgpu/" itemprop="url" rel="index"><span itemprop="name">Wgpu</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>While we can tell that our scene is 3d because of our camera, it still feels very flat. That’s because our model stays the same color regardless of how it’s oriented. If we want to change that we need to add lighting to our scene.</p>
<p>虽然我们可以看出，我们的场景是3d的，因为我们的相机，它仍然感觉非常平坦。这是因为我们的模型保持相同的颜色，无论它是如何定向的。如果我们想改变这一点，我们需要向场景中添加照明。</p>
<p>In the real world, a light source emits photons which bounce around until they enter into our eyes. The color we see is the light’s original color minus whatever energy it lost while it was bouncing around.</p>
<p>在现实世界中，光源发射光子，这些光子在周围反弹，直到它们进入我们的眼睛。我们看到的颜色是光的原始颜色减去它在反弹时损失的能量。</p>
<p>In the computer graphics world, modeling individual photons would be hilariously computationally expensive. A single 100 Watt light bulb emits about 3.27 x 10^20 photons per second. Just imagine that for the sun! To get around this, we’re gonna use math to cheat.</p>
<p>在计算机图形学领域，对单个光子进行建模在计算上会非常昂贵。一个100瓦的灯泡每秒发射大约3.27 x 10^20个光子。想象一下，为了太阳！为了避开这个问题，我们要用数学来作弊。</p>
<p>Let’s discuss a few options.</p>
<p>让我们讨论几个选项。</p>
<h1 id="Ray-Path-Tracing"><a href="#Ray-Path-Tracing" class="headerlink" title="Ray/Path Tracing"></a>Ray/Path Tracing</h1><p>This is an advanced topic, and we won’t be covering it in depth here. It’s the closest model to the way light really works so I felt I had to mention it. Check out the ray tracing tutorial if you want to learn more.</p>
<h1 id="The-Blinn-Phong-Model"><a href="#The-Blinn-Phong-Model" class="headerlink" title="The Blinn-Phong Model"></a>The Blinn-Phong Model</h1><p>Ray/path tracing is often too computationally expensive for most realtime applications (though that is starting to change), so a more efficient, if less accurate method based on the <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Phong_shading">Phong reflection model</a> is often used. It splits up the lighting calculation into three (3) parts: ambient lighting, diffuse lighting, and specular lighting. We’re going to be learning the <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Blinn%E2%80%93Phong_reflection_model">Blinn-Phong model</a>, which cheats a bit at the specular calculation to speed things up.</p>
<p>对于大多数实时应用程序来说，光线/路径跟踪在计算上往往过于昂贵(尽管这一点已经开始改变)，因此通常会使用一种基于<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Phong_shading">Phong reflection model</a>的效率更高但精度更低的方法。它将照明计算分为三部分：环境照明、漫反射照明和镜面反射照明。我们将学习<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Blinn%E2%80%93Phong_reflection_model">Blinn-Phong model</a>，它在镜面反射计算中有点作弊，以加快速度。</p>
<p>Before we can get into that though, we need to add a light to our scene.</p>
<p>在我们开始之前，需要在场景中添加灯光。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main.rs</span></span><br><span class="line"><span class="meta">#[repr(C)]</span></span><br><span class="line"><span class="meta">#[derive(Debug, Copy, Clone, bytemuck::Pod, bytemuck::Zeroable)]</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">LightUniform</span></span> &#123;</span><br><span class="line">    position: [<span class="built_in">f32</span>; <span class="number">3</span>],</span><br><span class="line">    <span class="comment">// Due to uniforms requiring 16 byte (4 float) spacing, we need to use a padding field here</span></span><br><span class="line">    _padding: <span class="built_in">u32</span>,</span><br><span class="line">    color: [<span class="built_in">f32</span>; <span class="number">3</span>],</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Our LightUniform represents a colored point in space. We’re just going to use pure white light, but it’s good to allow different colors of light.</p>
<p>我们的LightUniform代表空间中的一个彩色点。我们将使用纯白光，但允许不同颜色的光是很好的。</p>
<p>We’re going to create another buffer to store our light in.</p>
<p>我们将创建另一个缓冲区来存储光线。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> light_uniform = LightUniform &#123;</span><br><span class="line">    position: [<span class="number">2.0</span>, <span class="number">2.0</span>, <span class="number">2.0</span>],</span><br><span class="line">    _padding: <span class="number">0</span>,</span><br><span class="line">    color: [<span class="number">1.0</span>, <span class="number">1.0</span>, <span class="number">1.0</span>],</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// We&#x27;ll want to update our lights position, so we use COPY_DST</span></span><br><span class="line"><span class="keyword">let</span> light_buffer = device.create_buffer_init(</span><br><span class="line">    &amp;wgpu::util::BufferInitDescriptor &#123;</span><br><span class="line">        label: <span class="literal">Some</span>(<span class="string">&quot;Light VB&quot;</span>),</span><br><span class="line">        contents: bytemuck::cast_slice(&amp;[light_uniform]),</span><br><span class="line">        usage: wgpu::BufferUsage::UNIFORM | wgpu::BufferUsage::COPY_DST,</span><br><span class="line">    &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>Don’t forget to add the light_uniform and light_buffer to State. After that we need to create a bind group layout and bind group for our light.</p>
<p>别忘了将light_uniform和light_buffer添加到State。之后，我们需要为灯光创建bind group layout和bind group。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> light_bind_group_layout =</span><br><span class="line">    device.create_bind_group_layout(&amp;wgpu::BindGroupLayoutDescriptor &#123;</span><br><span class="line">        entries: &amp;[wgpu::BindGroupLayoutEntry &#123;</span><br><span class="line">            binding: <span class="number">0</span>,</span><br><span class="line">            visibility: wgpu::ShaderStage::VERTEX | wgpu::ShaderStage::FRAGMENT,</span><br><span class="line">            ty: wgpu::BindingType::Buffer &#123;</span><br><span class="line">                ty: wgpu::BufferBindingType::Uniform,</span><br><span class="line">                has_dynamic_offset: <span class="literal">false</span>,</span><br><span class="line">                min_binding_size: <span class="literal">None</span>,</span><br><span class="line">            &#125;,</span><br><span class="line">            count: <span class="literal">None</span>,</span><br><span class="line">        &#125;],</span><br><span class="line">        label: <span class="literal">None</span>,</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> light_bind_group = device.create_bind_group(&amp;wgpu::BindGroupDescriptor &#123;</span><br><span class="line">    layout: &amp;light_bind_group_layout,</span><br><span class="line">    entries: &amp;[wgpu::BindGroupEntry &#123;</span><br><span class="line">        binding: <span class="number">0</span>,</span><br><span class="line">        resource: light_buffer.as_entire_binding(),</span><br><span class="line">    &#125;],</span><br><span class="line">    label: <span class="literal">None</span>,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>Add those to State, and also update the render_pipeline_layout.</p>
<p>将这些添加到State，并更新render_pipeline_layout。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> render_pipeline_layout = device.create_pipeline_layout(&amp;wgpu::PipelineLayoutDescriptor &#123;</span><br><span class="line">    bind_group_layouts: &amp;[</span><br><span class="line">        &amp;texture_bind_group_layout, </span><br><span class="line">        &amp;camera_bind_group_layout,</span><br><span class="line">        &amp;light_bind_group_layout,</span><br><span class="line">    ],</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>Let’s also update the lights position in the update() method, so we can see what our objects look like from different angles.</p>
<p>我们还将更新update()方法中的灯光位置，以便从不同角度查看对象的外观。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Update the light</span></span><br><span class="line"><span class="keyword">let</span> old_position: cgmath::Vector3&lt;_&gt; = <span class="keyword">self</span>.light_uniform.position.into();</span><br><span class="line"><span class="keyword">self</span>.light_uniform.position =</span><br><span class="line">    cgmath::Quaternion::from_axis_angle((<span class="number">0.0</span>, <span class="number">1.0</span>, <span class="number">0.0</span>).into(), cgmath::Deg(<span class="number">1.0</span>))</span><br><span class="line">        * old_position;</span><br><span class="line"><span class="keyword">self</span>.queue.write_buffer(&amp;<span class="keyword">self</span>.light_buffer, <span class="number">0</span>, bytemuck::cast_slice(&amp;[<span class="keyword">self</span>.light_uniform]));</span><br></pre></td></tr></table></figure>

<p>This will have the light rotate around the origin one degree every frame.</p>
<p>这将使灯光每帧围绕原点旋转一度。</p>
<h1 id="Seeing-the-light"><a href="#Seeing-the-light" class="headerlink" title="Seeing the light"></a>Seeing the light</h1><p>For debugging purposes, it would be nice if we could see where the light is to make sure that the scene looks correct. We could adapt our existing render pipeline to draw the light, but it will likely get in the way. Instead we are going to extract our render pipeline creation code into a new function called create_render_pipeline().</p>
<p>出于调试目的，如果我们能够看到灯光的位置，以确保场景看起来正确，那就太好了。我们可以调整现有的渲染管道来绘制灯光，但这可能会造成阻碍。相反，我们将把渲染管道创建代码提取到一个名为create_render_pipeline()的新函数中。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">create_render_pipeline</span></span>(</span><br><span class="line">    device: &amp;wgpu::Device,</span><br><span class="line">    layout: &amp;wgpu::PipelineLayout,</span><br><span class="line">    color_format: wgpu::TextureFormat,</span><br><span class="line">    depth_format: <span class="built_in">Option</span>&lt;wgpu::TextureFormat&gt;,</span><br><span class="line">    vertex_layouts: &amp;[wgpu::VertexBufferLayout],</span><br><span class="line">    shader: wgpu::ShaderModuleDescriptor,</span><br><span class="line">) -&gt; wgpu::RenderPipeline &#123;</span><br><span class="line">    <span class="keyword">let</span> shader = device.create_shader_module(&amp;shader);</span><br><span class="line"></span><br><span class="line">    device.create_render_pipeline(&amp;wgpu::RenderPipelineDescriptor &#123;</span><br><span class="line">        label: <span class="literal">Some</span>(<span class="string">&quot;Render Pipeline&quot;</span>),</span><br><span class="line">        layout: <span class="literal">Some</span>(layout),</span><br><span class="line">        vertex: wgpu::VertexState &#123;</span><br><span class="line">            module: &amp;shader,</span><br><span class="line">            entry_point: <span class="string">&quot;main&quot;</span>,</span><br><span class="line">            buffers: vertex_layouts,</span><br><span class="line">        &#125;,</span><br><span class="line">        fragment: <span class="literal">Some</span>(wgpu::FragmentState &#123;</span><br><span class="line">            module: &amp;shader,</span><br><span class="line">            entry_point: <span class="string">&quot;main&quot;</span>,</span><br><span class="line">            targets: &amp;[wgpu::ColorTargetState &#123;</span><br><span class="line">                format: color_format,</span><br><span class="line">                blend: <span class="literal">Some</span>(wgpu::BlendState &#123;</span><br><span class="line">                    alpha: wgpu::BlendComponent::REPLACE,</span><br><span class="line">                    color: wgpu::BlendComponent::REPLACE,</span><br><span class="line">                &#125;),</span><br><span class="line">                write_mask: wgpu::ColorWrite::ALL,</span><br><span class="line">            &#125;],</span><br><span class="line">        &#125;),</span><br><span class="line">        primitive: wgpu::PrimitiveState &#123;</span><br><span class="line">            topology: wgpu::PrimitiveTopology::TriangleList,</span><br><span class="line">            strip_index_format: <span class="literal">None</span>,</span><br><span class="line">            front_face: wgpu::FrontFace::Ccw,</span><br><span class="line">            cull_mode: <span class="literal">Some</span>(wgpu::Face::Back),</span><br><span class="line">            <span class="comment">// Setting this to anything other than Fill requires Features::NON_FILL_POLYGON_MODE</span></span><br><span class="line">            polygon_mode: wgpu::PolygonMode::Fill,</span><br><span class="line">            <span class="comment">// Requires Features::DEPTH_CLAMPING</span></span><br><span class="line">            clamp_depth: <span class="literal">false</span>,</span><br><span class="line">            <span class="comment">// Requires Features::CONSERVATIVE_RASTERIZATION</span></span><br><span class="line">            conservative: <span class="literal">false</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">        depth_stencil: depth_format.map(|format| wgpu::DepthStencilState &#123;</span><br><span class="line">            format,</span><br><span class="line">            depth_write_enabled: <span class="literal">true</span>,</span><br><span class="line">            depth_compare: wgpu::CompareFunction::Less,</span><br><span class="line">            stencil: wgpu::StencilState::default(),</span><br><span class="line">            bias: wgpu::DepthBiasState::default(),</span><br><span class="line">        &#125;),</span><br><span class="line">        multisample: wgpu::MultisampleState &#123;</span><br><span class="line">            count: <span class="number">1</span>,</span><br><span class="line">            mask: !<span class="number">0</span>,</span><br><span class="line">            alpha_to_coverage_enabled: <span class="literal">false</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>We also need to change State::new() to use this function.</p>
<p>我们还需要更改State::new()以使用此函数。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> render_pipeline = &#123;</span><br><span class="line">    <span class="keyword">let</span> shader = wgpu::ShaderModuleDescriptor &#123;</span><br><span class="line">        label: <span class="literal">Some</span>(<span class="string">&quot;Normal Shader&quot;</span>),</span><br><span class="line">        flags: wgpu::ShaderFlags::all(),</span><br><span class="line">        source: wgpu::ShaderSource::Wgsl(<span class="built_in">include_str!</span>(<span class="string">&quot;shader.wgsl&quot;</span>).into()),</span><br><span class="line">    &#125;;</span><br><span class="line">    create_render_pipeline(</span><br><span class="line">        &amp;device,</span><br><span class="line">        &amp;render_pipeline_layout,</span><br><span class="line">        sc_desc.format,</span><br><span class="line">        <span class="literal">Some</span>(texture::Texture::DEPTH_FORMAT),</span><br><span class="line">        &amp;[model::ModelVertex::desc(), InstanceRaw::desc()],</span><br><span class="line">        shader,</span><br><span class="line">    )</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>We’re going to need to modify model::DrawModel to use our light_bind_group.</p>
<p>我们需要修改model::DrawModel以使用我们的light_bind_group。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">trait</span> <span class="title">DrawModel</span></span>&lt;<span class="symbol">&#x27;a</span>&gt; &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">draw_mesh</span></span>(</span><br><span class="line">        &amp;<span class="keyword">mut</span> <span class="keyword">self</span>,</span><br><span class="line">        mesh: &amp;<span class="symbol">&#x27;a</span> Mesh,</span><br><span class="line">        material: &amp;<span class="symbol">&#x27;a</span> Material,</span><br><span class="line">        camera: &amp;<span class="symbol">&#x27;a</span> wgpu::BindGroup,</span><br><span class="line">        light: &amp;<span class="symbol">&#x27;a</span> wgpu::BindGroup,</span><br><span class="line">    );</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">draw_mesh_instanced</span></span>(</span><br><span class="line">        &amp;<span class="keyword">mut</span> <span class="keyword">self</span>,</span><br><span class="line">        mesh: &amp;<span class="symbol">&#x27;a</span> Mesh,</span><br><span class="line">        material: &amp;<span class="symbol">&#x27;a</span> Material,</span><br><span class="line">        instances: Range&lt;<span class="built_in">u32</span>&gt;,</span><br><span class="line">        camera: &amp;<span class="symbol">&#x27;a</span> wgpu::BindGroup,</span><br><span class="line">        light: &amp;<span class="symbol">&#x27;a</span> wgpu::BindGroup,</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">draw_model</span></span>(</span><br><span class="line">        &amp;<span class="keyword">mut</span> <span class="keyword">self</span>,</span><br><span class="line">        model: &amp;<span class="symbol">&#x27;a</span> Model,</span><br><span class="line">        camera: &amp;<span class="symbol">&#x27;a</span> wgpu::BindGroup,</span><br><span class="line">        light: &amp;<span class="symbol">&#x27;a</span> wgpu::BindGroup,</span><br><span class="line">    );</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">draw_model_instanced</span></span>(</span><br><span class="line">        &amp;<span class="keyword">mut</span> <span class="keyword">self</span>,</span><br><span class="line">        model: &amp;<span class="symbol">&#x27;a</span> Model,</span><br><span class="line">        instances: Range&lt;<span class="built_in">u32</span>&gt;,</span><br><span class="line">        camera: &amp;<span class="symbol">&#x27;a</span> wgpu::BindGroup,</span><br><span class="line">        light: &amp;<span class="symbol">&#x27;a</span> wgpu::BindGroup,</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;<span class="symbol">&#x27;a</span>, <span class="symbol">&#x27;b</span>&gt; DrawModel&lt;<span class="symbol">&#x27;b</span>&gt; <span class="keyword">for</span> wgpu::RenderPass&lt;<span class="symbol">&#x27;a</span>&gt;</span><br><span class="line"><span class="keyword">where</span></span><br><span class="line">    <span class="symbol">&#x27;b</span>: <span class="symbol">&#x27;a</span>,</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">draw_mesh</span></span>(</span><br><span class="line">        &amp;<span class="keyword">mut</span> <span class="keyword">self</span>,</span><br><span class="line">        mesh: &amp;<span class="symbol">&#x27;b</span> Mesh,</span><br><span class="line">        material: &amp;<span class="symbol">&#x27;b</span> Material,</span><br><span class="line">        camera: &amp;<span class="symbol">&#x27;b</span> wgpu::BindGroup,</span><br><span class="line">        light: &amp;<span class="symbol">&#x27;b</span> wgpu::BindGroup,</span><br><span class="line">    ) &#123;</span><br><span class="line">        <span class="keyword">self</span>.draw_mesh_instanced(mesh, material, <span class="number">0</span>..<span class="number">1</span>, camera, light);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">draw_mesh_instanced</span></span>(</span><br><span class="line">        &amp;<span class="keyword">mut</span> <span class="keyword">self</span>,</span><br><span class="line">        mesh: &amp;<span class="symbol">&#x27;b</span> Mesh,</span><br><span class="line">        material: &amp;<span class="symbol">&#x27;b</span> Material,</span><br><span class="line">        instances: Range&lt;<span class="built_in">u32</span>&gt;,</span><br><span class="line">        camera: &amp;<span class="symbol">&#x27;b</span> wgpu::BindGroup,</span><br><span class="line">        light: &amp;<span class="symbol">&#x27;b</span> wgpu::BindGroup,</span><br><span class="line">    ) &#123;</span><br><span class="line">        <span class="keyword">self</span>.set_vertex_buffer(<span class="number">0</span>, &amp;mesh.vertex_buffer, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">self</span>.set_index_buffer(&amp;mesh.index_buffer, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">self</span>.set_bind_group(<span class="number">0</span>, &amp;material.bind_group, &amp;[]);</span><br><span class="line">        <span class="keyword">self</span>.set_bind_group(<span class="number">1</span>, camera, &amp;[]);</span><br><span class="line">        <span class="keyword">self</span>.set_bind_group(<span class="number">2</span>, light, &amp;[]);</span><br><span class="line">        <span class="keyword">self</span>.draw_indexed(<span class="number">0</span>..mesh.num_elements, <span class="number">0</span>, instances);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">draw_model</span></span>(</span><br><span class="line">        &amp;<span class="keyword">mut</span> <span class="keyword">self</span>,</span><br><span class="line">        model: &amp;<span class="symbol">&#x27;b</span> Model,</span><br><span class="line">        camera: &amp;<span class="symbol">&#x27;b</span> wgpu::BindGroup,</span><br><span class="line">        light: &amp;<span class="symbol">&#x27;b</span> wgpu::BindGroup,</span><br><span class="line">    ) &#123;</span><br><span class="line">        <span class="keyword">self</span>.draw_model_instanced(model, <span class="number">0</span>..<span class="number">1</span>, camera, light);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">draw_model_instanced</span></span>(</span><br><span class="line">        &amp;<span class="keyword">mut</span> <span class="keyword">self</span>,</span><br><span class="line">        model: &amp;<span class="symbol">&#x27;b</span> Model,</span><br><span class="line">        instances: Range&lt;<span class="built_in">u32</span>&gt;,</span><br><span class="line">        camera: &amp;<span class="symbol">&#x27;b</span> wgpu::BindGroup,</span><br><span class="line">        light: &amp;<span class="symbol">&#x27;b</span> wgpu::BindGroup,</span><br><span class="line">    ) &#123;</span><br><span class="line">        <span class="keyword">for</span> mesh <span class="keyword">in</span> &amp;model.meshes &#123;</span><br><span class="line">            <span class="keyword">let</span> material = &amp;model.materials[mesh.material];</span><br><span class="line">            <span class="keyword">self</span>.draw_mesh_instanced(mesh, material, instances.clone(), camera, light);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>With that done we can create another render pipeline for our light.</p>
<p>完成后，我们可以为灯光创建另一个渲染管道。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> light_render_pipeline = &#123;</span><br><span class="line">    <span class="keyword">let</span> layout = device.create_pipeline_layout(&amp;wgpu::PipelineLayoutDescriptor &#123;</span><br><span class="line">        label: <span class="literal">Some</span>(<span class="string">&quot;Light Pipeline Layout&quot;</span>),</span><br><span class="line">        bind_group_layouts: &amp;[&amp;camera_bind_group_layout, &amp;light_bind_group_layout],</span><br><span class="line">        push_constant_ranges: &amp;[],</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">let</span> shader = wgpu::ShaderModuleDescriptor &#123;</span><br><span class="line">        label: <span class="literal">Some</span>(<span class="string">&quot;Light Shader&quot;</span>),</span><br><span class="line">        flags: wgpu::ShaderFlags::all(),</span><br><span class="line">        source: wgpu::ShaderSource::Wgsl(<span class="built_in">include_str!</span>(<span class="string">&quot;light.wgsl&quot;</span>).into()),</span><br><span class="line">    &#125;;</span><br><span class="line">    create_render_pipeline(</span><br><span class="line">        &amp;device,</span><br><span class="line">        &amp;layout,</span><br><span class="line">        sc_desc.format,</span><br><span class="line">        <span class="literal">Some</span>(texture::Texture::DEPTH_FORMAT),</span><br><span class="line">        &amp;[model::ModelVertex::desc()],</span><br><span class="line">        shader,</span><br><span class="line">    )</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>I chose to create a seperate layout for the light_render_pipeline, as it doesn’t need all the resources that the regular render_pipeline needs (main just the textures).</p>
<p>我选择为light_render_pipeline创建一个单独的layout，因为它不需要常规render_pipeline需要的所有资源(纹理)。</p>
<p>With that in place we need to write the actual shaders.</p>
<p>接着我们需要编写实际的着色器。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Vertex shader</span></span><br><span class="line"></span><br><span class="line">[[block]]</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Camera</span></span> &#123;</span><br><span class="line">    view_proj: mat4x4&lt;<span class="built_in">f32</span>&gt;;</span><br><span class="line">&#125;;</span><br><span class="line">[[group(<span class="number">0</span>), binding(<span class="number">0</span>)]]</span><br><span class="line">var&lt;uniform&gt; camera: Camera;</span><br><span class="line"></span><br><span class="line">[[block]]</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Light</span></span> &#123;</span><br><span class="line">    position: vec3&lt;<span class="built_in">f32</span>&gt;;</span><br><span class="line">    color: vec3&lt;<span class="built_in">f32</span>&gt;;</span><br><span class="line">&#125;;</span><br><span class="line">[[group(<span class="number">1</span>), binding(<span class="number">0</span>)]]</span><br><span class="line">var&lt;uniform&gt; light: Light;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">VertexInput</span></span> &#123;</span><br><span class="line">    [[location(<span class="number">0</span>)]] position: vec3&lt;<span class="built_in">f32</span>&gt;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">VertexOutput</span></span> &#123;</span><br><span class="line">    [[builtin(position)]] clip_position: vec4&lt;<span class="built_in">f32</span>&gt;;</span><br><span class="line">    [[location(<span class="number">0</span>)]] color: vec3&lt;<span class="built_in">f32</span>&gt;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">[[stage(vertex)]]</span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>(</span><br><span class="line">    model: VertexInput,</span><br><span class="line">) -&gt; VertexOutput &#123;</span><br><span class="line">    <span class="keyword">let</span> scale = <span class="number">0.25</span>;</span><br><span class="line">    var out: VertexOutput;</span><br><span class="line">    out.clip_position = camera.view_proj * vec4&lt;<span class="built_in">f32</span>&gt;(model.position * scale + light.position, <span class="number">1.0</span>);</span><br><span class="line">    out.color = light.color;</span><br><span class="line">    <span class="keyword">return</span> out;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Fragment shader</span></span><br><span class="line"></span><br><span class="line">[[stage(fragment)]]</span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>(<span class="keyword">in</span>: VertexOutput) -&gt; [[location(<span class="number">0</span>)]] vec4&lt;<span class="built_in">f32</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> vec4&lt;<span class="built_in">f32</span>&gt;(<span class="keyword">in</span>.color, <span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Now we could manually implement the draw code for the light in render(), but to keep with the pattern we developed, let’s create a new trait called DrawLight.</p>
<p>现在我们可以在render()中手动实现灯光的绘制代码，但是为了保持我们开发的模式，让我们创建一个名为DrawLight的新trait。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">trait</span> <span class="title">DrawLight</span></span>&lt;<span class="symbol">&#x27;a</span>&gt; &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">draw_light_mesh</span></span>(</span><br><span class="line">        &amp;<span class="keyword">mut</span> <span class="keyword">self</span>,</span><br><span class="line">        mesh: &amp;<span class="symbol">&#x27;a</span> Mesh,</span><br><span class="line">        camera: &amp;<span class="symbol">&#x27;a</span> wgpu::BindGroup,</span><br><span class="line">        light: &amp;<span class="symbol">&#x27;a</span> wgpu::BindGroup,</span><br><span class="line">    );</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">draw_light_mesh_instanced</span></span>(</span><br><span class="line">        &amp;<span class="keyword">mut</span> <span class="keyword">self</span>,</span><br><span class="line">        mesh: &amp;<span class="symbol">&#x27;a</span> Mesh,</span><br><span class="line">        instances: Range&lt;<span class="built_in">u32</span>&gt;,</span><br><span class="line">        camera: &amp;<span class="symbol">&#x27;a</span> wgpu::BindGroup,</span><br><span class="line">        light: &amp;<span class="symbol">&#x27;a</span> wgpu::BindGroup,</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">draw_light_model</span></span>(</span><br><span class="line">        &amp;<span class="keyword">mut</span> <span class="keyword">self</span>,</span><br><span class="line">        model: &amp;<span class="symbol">&#x27;a</span> Model,</span><br><span class="line">        camera: &amp;<span class="symbol">&#x27;a</span> wgpu::BindGroup,</span><br><span class="line">        light: &amp;<span class="symbol">&#x27;a</span> wgpu::BindGroup,</span><br><span class="line">    );</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">draw_light_model_instanced</span></span>(</span><br><span class="line">        &amp;<span class="keyword">mut</span> <span class="keyword">self</span>,</span><br><span class="line">        model: &amp;<span class="symbol">&#x27;a</span> Model,</span><br><span class="line">        instances: Range&lt;<span class="built_in">u32</span>&gt;,</span><br><span class="line">        camera: &amp;<span class="symbol">&#x27;a</span> wgpu::BindGroup,</span><br><span class="line">        light: &amp;<span class="symbol">&#x27;a</span> wgpu::BindGroup,</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;<span class="symbol">&#x27;a</span>, <span class="symbol">&#x27;b</span>&gt; DrawLight&lt;<span class="symbol">&#x27;b</span>&gt; <span class="keyword">for</span> wgpu::RenderPass&lt;<span class="symbol">&#x27;a</span>&gt;</span><br><span class="line"><span class="keyword">where</span></span><br><span class="line">    <span class="symbol">&#x27;b</span>: <span class="symbol">&#x27;a</span>,</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">draw_light_mesh</span></span>(</span><br><span class="line">        &amp;<span class="keyword">mut</span> <span class="keyword">self</span>,</span><br><span class="line">        mesh: &amp;<span class="symbol">&#x27;b</span> Mesh,</span><br><span class="line">        camera: &amp;<span class="symbol">&#x27;b</span> wgpu::BindGroup,</span><br><span class="line">        light: &amp;<span class="symbol">&#x27;b</span> wgpu::BindGroup,</span><br><span class="line">    ) &#123;</span><br><span class="line">        <span class="keyword">self</span>.draw_light_mesh_instanced(mesh, <span class="number">0</span>..<span class="number">1</span>, camera, light);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">draw_light_mesh_instanced</span></span>(</span><br><span class="line">        &amp;<span class="keyword">mut</span> <span class="keyword">self</span>,</span><br><span class="line">        mesh: &amp;<span class="symbol">&#x27;b</span> Mesh,</span><br><span class="line">        instances: Range&lt;<span class="built_in">u32</span>&gt;,</span><br><span class="line">        camera: &amp;<span class="symbol">&#x27;b</span> wgpu::BindGroup,</span><br><span class="line">        light: &amp;<span class="symbol">&#x27;b</span> wgpu::BindGroup,</span><br><span class="line">    ) &#123;</span><br><span class="line">        <span class="keyword">self</span>.set_vertex_buffer(<span class="number">0</span>, mesh.vertex_buffer.slice(..));</span><br><span class="line">        <span class="keyword">self</span>.set_index_buffer(mesh.index_buffer.slice(..), wgpu::IndexFormat::Uint32);</span><br><span class="line">        <span class="keyword">self</span>.set_bind_group(<span class="number">0</span>, camera, &amp;[]);</span><br><span class="line">        <span class="keyword">self</span>.set_bind_group(<span class="number">1</span>, light, &amp;[]);</span><br><span class="line">        <span class="keyword">self</span>.draw_indexed(<span class="number">0</span>..mesh.num_elements, <span class="number">0</span>, instances);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">draw_light_model</span></span>(</span><br><span class="line">        &amp;<span class="keyword">mut</span> <span class="keyword">self</span>,</span><br><span class="line">        model: &amp;<span class="symbol">&#x27;b</span> Model,</span><br><span class="line">        camera: &amp;<span class="symbol">&#x27;b</span> wgpu::BindGroup,</span><br><span class="line">        light: &amp;<span class="symbol">&#x27;b</span> wgpu::BindGroup,</span><br><span class="line">    ) &#123;</span><br><span class="line">        <span class="keyword">self</span>.draw_light_model_instanced(model, <span class="number">0</span>..<span class="number">1</span>, camera, light);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">draw_light_model_instanced</span></span>(</span><br><span class="line">        &amp;<span class="keyword">mut</span> <span class="keyword">self</span>,</span><br><span class="line">        model: &amp;<span class="symbol">&#x27;b</span> Model,</span><br><span class="line">        instances: Range&lt;<span class="built_in">u32</span>&gt;,</span><br><span class="line">        camera: &amp;<span class="symbol">&#x27;b</span> wgpu::BindGroup,</span><br><span class="line">        light: &amp;<span class="symbol">&#x27;b</span> wgpu::BindGroup,</span><br><span class="line">    ) &#123;</span><br><span class="line">        <span class="keyword">for</span> mesh <span class="keyword">in</span> &amp;model.meshes &#123;</span><br><span class="line">            <span class="keyword">self</span>.draw_light_mesh_instanced(mesh, instances.clone(), camera, light);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Finally we want to add Light rendering to our render passes.</p>
<p>最后，我们希望将灯光渲染添加到渲染过程中。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span> State &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">   <span class="function"><span class="keyword">fn</span> <span class="title">render</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) -&gt; <span class="built_in">Result</span>&lt;(), wgpu::SwapChainError&gt; &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        render_pass.set_vertex_buffer(<span class="number">1</span>, <span class="keyword">self</span>.instance_buffer.slice(..));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">use</span> crate::model::DrawLight; <span class="comment">// NEW!</span></span><br><span class="line">        render_pass.set_pipeline(&amp;<span class="keyword">self</span>.light_render_pipeline); <span class="comment">// NEW!</span></span><br><span class="line">        render_pass.draw_light_model(</span><br><span class="line">            &amp;<span class="keyword">self</span>.obj_model,</span><br><span class="line">            &amp;<span class="keyword">self</span>.camera_bind_group,</span><br><span class="line">            &amp;<span class="keyword">self</span>.light_bind_group,</span><br><span class="line">        ); <span class="comment">// NEW!</span></span><br><span class="line"></span><br><span class="line">        render_pass.set_pipeline(&amp;<span class="keyword">self</span>.render_pipeline);</span><br><span class="line">        render_pass.draw_model_instanced(</span><br><span class="line">            &amp;<span class="keyword">self</span>.obj_model,</span><br><span class="line">            <span class="number">0</span>..<span class="keyword">self</span>.instances.len() <span class="keyword">as</span> <span class="built_in">u32</span>,</span><br><span class="line">            &amp;<span class="keyword">self</span>.camera_bind_group,</span><br><span class="line">            &amp;<span class="keyword">self</span>.light_bind_group,</span><br><span class="line">        );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>With all that we’ll end up with something like this.</p>
<p>有了这些，我们最终会得到这样的结果。</p>
<p><img src="https://sotrh.github.io/learn-wgpu/assets/img/light-in-scene.7c329d72.png" alt="light-in-scene"></p>
<h1 id="Ambient-Lighting"><a href="#Ambient-Lighting" class="headerlink" title="Ambient Lighting"></a>Ambient Lighting</h1><p>Light has a tendency to bounce around before entering our eyes. That’s why you can see in areas that are in shadow. Actually modeling this interaction is computationally expensive, so we cheat. We define an ambient lighting value that stands in for the light bouncing of other parts of the scene to light our objects.</p>
<p>光线在进入我们的眼睛之前有一种反弹的趋势。这就是为什么你可以在阴影中看到。实际上，对这种交互进行建模在计算上很昂贵，所以我们作弊。我们定义一个环境光照明值，该值代表场景其他部分的光反弹，以照亮我们的对象。</p>
<p>The ambient part is based on the light color as well as the object color. We’ve already added our light_bind_group, so we just need to use it in our shader. In shader.wgsl, add the following below the texture uniforms.</p>
<p>环境光部分基于灯光颜色和对象颜色。我们已经添加了灯光组，所以我们只需要在着色器中使用它。在shader.wgsl中，在纹理下方添加以下内容。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[[block]]</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Light</span></span> &#123;</span><br><span class="line">    position: vec3&lt;<span class="built_in">f32</span>&gt;;</span><br><span class="line">    color: vec3&lt;<span class="built_in">f32</span>&gt;;</span><br><span class="line">&#125;;</span><br><span class="line">[[group(<span class="number">2</span>), binding(<span class="number">0</span>)]]</span><br><span class="line">var&lt;uniform&gt; light: Light;</span><br></pre></td></tr></table></figure>

<p>Then we need to update our main shader code to calculate and use the ambient color value.</p>
<p>然后我们需要更新我们的主着色器代码来计算和使用环境光颜色值。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[[stage(fragment)]]</span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>(<span class="keyword">in</span>: VertexOutput) -&gt; [[location(<span class="number">0</span>)]] vec4&lt;<span class="built_in">f32</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> object_color: vec4&lt;<span class="built_in">f32</span>&gt; = textureSample(t_diffuse, s_diffuse, <span class="keyword">in</span>.tex_coords);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// We don&#x27;t need (or want) much ambient light, so 0.1 is fine</span></span><br><span class="line">    <span class="keyword">let</span> ambient_strength = <span class="number">0.1</span>;</span><br><span class="line">    <span class="keyword">let</span> ambient_color = light.color * ambient_strength;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> result = ambient_color * object_color.xyz;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> vec4&lt;<span class="built_in">f32</span>&gt;(result, object_color.a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>With that we should get something like the this.</p>
<p>这样我们就可以得到类似这样的东西。</p>
<p><img src="https://sotrh.github.io/learn-wgpu/assets/img/ambient_lighting.8bece8d1.png" alt="ambient_lighting"></p>
<h1 id="Diffuse-Lighting"><a href="#Diffuse-Lighting" class="headerlink" title="Diffuse Lighting"></a>Diffuse Lighting</h1><p>Remember the normal vectors that were included with our model? We’re finally going to use them. Normals represent the direction a surface is facing. By comparing the normal of a fragment with a vector pointing to a light source, we get a value of how light/dark that fragment should be. We compare the vector using the dot product to get the cosine of the angle between them.</p>
<p>还记得我们模型中包含的法向量吗？我们终于要使用它们了。法线表示曲面面对的方向。通过将碎片的法线与指向光源的向量进行比较，我们可以得到该碎片的亮/暗程度。我们使用点积比较矢量，得到它们之间的夹角的余弦。</p>
<p><img src="https://sotrh.github.io/learn-wgpu/assets/img/normal_diagram.dfa577f7.png" alt="normal_diagram"></p>
<p>If the dot product of the normal and light vector is 1.0, that means that the current fragment is directly inline with the light source and will receive the lights full intensity. A value of 0.0 or lower means that the surface is perpendicular or facing away from the light, and therefore will be dark.</p>
<p>如果法线和光向量的点积为1.0，则表示当前片段直接与光源对齐，并将接收全强度的光。值为0.0或更低表示曲面垂直或背向灯光，因此将变暗。</p>
<p>We’re going to need to pull in the normal vector into our shader.wgsl.</p>
<p>我们需要将法线向量拉入shader.wgsl。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">VertexInput</span></span> &#123;</span><br><span class="line">    [[location(<span class="number">0</span>)]] position: vec3&lt;<span class="built_in">f32</span>&gt;;</span><br><span class="line">    [[location(<span class="number">1</span>)]] tex_coords: vec2&lt;<span class="built_in">f32</span>&gt;;</span><br><span class="line">    [[location(<span class="number">2</span>)]] normal: vec3&lt;<span class="built_in">f32</span>&gt;; <span class="comment">// NEW!</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>We’re also going to want to pass that value, as well as the vertex’s position to the fragment shader.</p>
<p>我们还要将该值以及顶点的位置传递给片段着色器。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">VertexOutput</span></span> &#123;</span><br><span class="line">    [[builtin(position)]] clip_position: vec4&lt;<span class="built_in">f32</span>&gt;;</span><br><span class="line">    [[location(<span class="number">0</span>)]] tex_coords: vec2&lt;<span class="built_in">f32</span>&gt;;</span><br><span class="line">    [[location(<span class="number">1</span>)]] world_normal: vec3&lt;<span class="built_in">f32</span>&gt;;</span><br><span class="line">    [[location(<span class="number">2</span>)]] world_position: vec3&lt;<span class="built_in">f32</span>&gt;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>For now let’s just pass the normal directly as is. This is wrong, but we’ll fix it later.</p>
<p>现在让我们直接按原样传递法线。这是错误的，但我们稍后会解决它。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">[[stage(vertex)]]</span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>(</span><br><span class="line">    model: VertexInput,</span><br><span class="line">    instance: InstanceInput,</span><br><span class="line">) -&gt; VertexOutput &#123;</span><br><span class="line">    <span class="keyword">let</span> model_matrix = mat4x4&lt;<span class="built_in">f32</span>&gt;(</span><br><span class="line">        instance.model_matrix_0,</span><br><span class="line">        instance.model_matrix_1,</span><br><span class="line">        instance.model_matrix_2,</span><br><span class="line">        instance.model_matrix_3,</span><br><span class="line">    );</span><br><span class="line">    var out: VertexOutput;</span><br><span class="line">    out.tex_coords = model.tex_coords;</span><br><span class="line">    out.world_normal = model.normal;</span><br><span class="line">    var world_position: vec4&lt;<span class="built_in">f32</span>&gt; = model_matrix * vec4&lt;<span class="built_in">f32</span>&gt;(model.position, <span class="number">1.0</span>);</span><br><span class="line">    out.world_position = world_position.xyz;</span><br><span class="line">    out.clip_position = camera.view_proj * world_position;</span><br><span class="line">    <span class="keyword">return</span> out;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>With that we can do the actual calculation. Below the ambient_color calculation, but above result, add the following.</p>
<p>这样我们就可以进行实际计算了。在ambient_color计算下方，但在结果上方，添加以下内容。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> light_dir = normalize(light.position - <span class="keyword">in</span>.world_position);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> diffuse_strength = max(dot(<span class="keyword">in</span>.world_normal, light_dir), <span class="number">0.0</span>);</span><br><span class="line"><span class="keyword">let</span> diffuse_color = light.color * diffuse_strength;</span><br></pre></td></tr></table></figure>

<p>Now we can include the diffuse_color in the result.</p>
<p>现在我们可以在结果中包含漫反射颜色。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> result = (ambient_color + diffuse_color) * object_color.xyz;</span><br></pre></td></tr></table></figure>

<p>With that we get something like this.</p>
<p>这样我们就得到了这样的东西。</p>
<p><img src="https://sotrh.github.io/learn-wgpu/assets/img/ambient_diffuse_wrong.dab00d9a.png" alt="ambient_diffuse_wrong"></p>
<h1 id="The-normal-matrix"><a href="#The-normal-matrix" class="headerlink" title="The normal matrix"></a>The normal matrix</h1><p>Remember when I said passing the vertex normal directly to the fragment shader was wrong? Let’s explore that by removing all the cubes from the scene except one that will be rotated 180 degrees on the y-axis.</p>
<p>还记得我说过将顶点法线直接传递给片段着色器是错误的吗？让我们通过移除场景中的所有立方体来探索这一点，其中一个立方体将在y轴上旋转180度。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> NUM_INSTANCES_PER_ROW: <span class="built_in">u32</span> = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// In the loop we create the instances in</span></span><br><span class="line"><span class="keyword">let</span> rotation = cgmath::Quaternion::from_axis_angle((<span class="number">0.0</span>, <span class="number">1.0</span>, <span class="number">0.0</span>).into(), cgmath::Deg(<span class="number">180.0</span>));</span><br></pre></td></tr></table></figure>

<p>We’ll also remove the ambient_color from our lighting result.</p>
<p>我们还将从照明结果中删除环境光颜色。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> result = (diffuse_color) * object_color.xyz;</span><br></pre></td></tr></table></figure>

<p>That should give us something that looks like this.</p>
<p>这应该给我们一些如下图所示的东西。</p>
<p><img src="https://sotrh.github.io/learn-wgpu/assets/img/diffuse_wrong.ce856a2c.png" alt="diffuse_wrong"></p>
<p>This is clearly wrong as the light is illuminating the wrong side of the cube. This is because we aren’t rotating our normals with our object, so no matter what direction the object faces, the normals will always face the same way.</p>
<p>这显然是错误的，因为光线照亮了立方体的错误一侧。这是因为我们没有随对象旋转法线，所以无论对象朝向哪个方向，法线都将始终朝向相同的方向。</p>
<p><img src="data:image/png;base64,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AAACBABAgAAACBAAAAECACBAAAAgQAAABAgAgAABABAgAAACBAAAAgQAQIAAAAgQAAABAgAgQAAAIEAAAAQIAIAAAQAQIAAAAgQAAAIEAECAAAAIEAAAAQIAIEAAACBAAAAECACAAAEAECAAABAgAAACBABAgAAACBAAAAECAAABAgAgQAAABAgAgAABABAgAAAQIAAAAgQAQIAAAAgQAAABAgAAAQIAIEAAAAQIAIAAAQAQIAAAECAAAAIEAECAAAAIEAAAAQIAAAECACBAAAAECACAAAEAECAAABAgAAACBABAgAAACBAAAAHCFAAACBAAAAECACBAAAAECAAABAgAgAABABAgAAACBABAgAAAQIAAAAgQAAABAgAgQAAABAgAAAQIAIAAAQAQIAAAAgQAQIAAAECAAAAIEAAAAQIAIEAAAAQIAAAECACAAAEAECAAAAIEAECAAABAgAAACBAAAAECACBAAAAECAAABAgAgAABABAgAAACBAAAAgQAQIAAAAgQAAABAgAgQAAAIEAAAAQIAIAAAQAQIAAAAgQAAAIEAECAAAAIEAAAAQIAIEAAACBAAAAECACAAAEAECAAAAIEAAACBABAgAAACBAAAAECACBAAAAgQAAABAgAgAABABAgAAACBAAAAgQAQIAAAAgQAAABAgAgQAAAIEAAAAQIAIAAAQAQIAAAECAAAAIEAECAAAAIEAAAAQIAAAECACBAAACe8f8Iph1tvtY2iAAAAABJRU5ErkJggg==" alt="image"></p>
<p>We need to use the model matrix to transform the normals to be in the right direction. We only want the rotation data though. A normal represents a direction, and should be a unit vector throughout the calculation. We can get our normals into the right direction using what is called a normal matrix.</p>
<p>我们需要使用模型矩阵将法线变换为正确的方向。我们只需要旋转数据。法线表示方向，在整个计算过程中应为单位向量。我们可以使用所谓的法线矩阵使法线指向正确的方向。</p>
<p>We could compute the normal matrix in the vertex shader, but that would involve inverting the model_matrix, and WGSL doesn’t actually have an inverse function. We would have to code our own. On top of that computing the inverse of a matrix is actually really expensive, especially doing that compututation for every vertex.</p>
<p>我们可以在顶点着色器中计算法线矩阵，但这需要反转模型_矩阵，WGSL实际上没有反函数。我们必须自己编写代码。除此之外，计算矩阵的逆实际上非常昂贵，尤其是对每个顶点进行计算。</p>
<p>Instead we’re going to create add a normal matrix field to InstanceRaw. Instead of inverting the model matrix, we’ll just using the the instances rotation to create a Matrix3.</p>
<p>相反，我们将创建一个法线矩阵字段，并将其添加到InstanceRaw。我们将使用实例旋转来创建Matrix3，而不是反转模型矩阵。</p>
<div class="note">

<p>We using Matrix3 instead of Matrix4 as we only really need the rotation component of the matrix.</p>
<p>我们使用Matrix3代替Matrix4，因为我们只需要矩阵的旋转分量。</p>
</div>

<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[repr(C)]</span></span><br><span class="line"><span class="meta">#[derive(Debug, Copy, Clone, bytemuck::Pod, bytemuck::Zeroable)]</span></span><br><span class="line"><span class="meta">#[allow(dead_code)]</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">InstanceRaw</span></span> &#123;</span><br><span class="line">    model: [[<span class="built_in">f32</span>; <span class="number">4</span>]; <span class="number">4</span>],</span><br><span class="line">    normal: [[<span class="built_in">f32</span>; <span class="number">3</span>]; <span class="number">3</span>],</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> model::Vertex <span class="keyword">for</span> InstanceRaw &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">desc</span></span>&lt;<span class="symbol">&#x27;a</span>&gt;() -&gt; wgpu::VertexBufferLayout&lt;<span class="symbol">&#x27;a</span>&gt; &#123;</span><br><span class="line">        <span class="keyword">use</span> std::mem;</span><br><span class="line">        wgpu::VertexBufferLayout &#123;</span><br><span class="line">            array_stride: mem::size_of::&lt;InstanceRaw&gt;() <span class="keyword">as</span> wgpu::BufferAddress,</span><br><span class="line">            <span class="comment">// We need to switch from using a step mode of Vertex to Instance</span></span><br><span class="line">            <span class="comment">// This means that our shaders will only change to use the next</span></span><br><span class="line">            <span class="comment">// instance when the shader starts processing a new instance</span></span><br><span class="line">            step_mode: wgpu::VertexStepMode::Instance,</span><br><span class="line">            attributes: &amp;[</span><br><span class="line">                wgpu::VertexAttribute &#123;</span><br><span class="line">                    offset: <span class="number">0</span>,</span><br><span class="line">                    <span class="comment">// While our vertex shader only uses locations 0, and 1 now, in later tutorials we&#x27;ll</span></span><br><span class="line">                    <span class="comment">// be using 2, 3, and 4, for Vertex. We&#x27;ll start at slot 5 not conflict with them later</span></span><br><span class="line">                    shader_location: <span class="number">5</span>,</span><br><span class="line">                    format: wgpu::VertexFormat::Float32x4,</span><br><span class="line">                &#125;,</span><br><span class="line">                <span class="comment">// A mat4 takes up 4 vertex slots as it is technically 4 vec4s. We need to define a slot</span></span><br><span class="line">                <span class="comment">// for each vec4. We don&#x27;t have to do this in code though.</span></span><br><span class="line">                wgpu::VertexAttribute &#123;</span><br><span class="line">                    offset: mem::size_of::&lt;[<span class="built_in">f32</span>; <span class="number">4</span>]&gt;() <span class="keyword">as</span> wgpu::BufferAddress,</span><br><span class="line">                    shader_location: <span class="number">6</span>,</span><br><span class="line">                    format: wgpu::VertexFormat::Float32x4,</span><br><span class="line">                &#125;,</span><br><span class="line">                wgpu::VertexAttribute &#123;</span><br><span class="line">                    offset: mem::size_of::&lt;[<span class="built_in">f32</span>; <span class="number">8</span>]&gt;() <span class="keyword">as</span> wgpu::BufferAddress,</span><br><span class="line">                    shader_location: <span class="number">7</span>,</span><br><span class="line">                    format: wgpu::VertexFormat::Float32x4,</span><br><span class="line">                &#125;,</span><br><span class="line">                wgpu::VertexAttribute &#123;</span><br><span class="line">                    offset: mem::size_of::&lt;[<span class="built_in">f32</span>; <span class="number">12</span>]&gt;() <span class="keyword">as</span> wgpu::BufferAddress,</span><br><span class="line">                    shader_location: <span class="number">8</span>,</span><br><span class="line">                    format: wgpu::VertexFormat::Float32x4,</span><br><span class="line">                &#125;,</span><br><span class="line">                <span class="comment">// NEW!</span></span><br><span class="line">                wgpu::VertexAttribute &#123;</span><br><span class="line">                    offset: mem::size_of::&lt;[<span class="built_in">f32</span>; <span class="number">16</span>]&gt;() <span class="keyword">as</span> wgpu::BufferAddress,</span><br><span class="line">                    shader_location: <span class="number">9</span>,</span><br><span class="line">                    format: wgpu::VertexFormat::Float32x3,</span><br><span class="line">                &#125;,</span><br><span class="line">                wgpu::VertexAttribute &#123;</span><br><span class="line">                    offset: mem::size_of::&lt;[<span class="built_in">f32</span>; <span class="number">19</span>]&gt;() <span class="keyword">as</span> wgpu::BufferAddress,</span><br><span class="line">                    shader_location: <span class="number">10</span>,</span><br><span class="line">                    format: wgpu::VertexFormat::Float32x3,</span><br><span class="line">                &#125;,</span><br><span class="line">                wgpu::VertexAttribute &#123;</span><br><span class="line">                    offset: mem::size_of::&lt;[<span class="built_in">f32</span>; <span class="number">22</span>]&gt;() <span class="keyword">as</span> wgpu::BufferAddress,</span><br><span class="line">                    shader_location: <span class="number">11</span>,</span><br><span class="line">                    format: wgpu::VertexFormat::Float32x3,</span><br><span class="line">                &#125;,</span><br><span class="line">            ],</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>We need to modify Instance to create the normal matrix.</p>
<p>我们需要修改实例来创建法线矩阵。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Instance</span></span> &#123;</span><br><span class="line">    position: cgmath::Vector3&lt;<span class="built_in">f32</span>&gt;,</span><br><span class="line">    rotation: cgmath::Quaternion&lt;<span class="built_in">f32</span>&gt;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> Instance &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">to_raw</span></span>(&amp;<span class="keyword">self</span>) -&gt; InstanceRaw &#123;</span><br><span class="line">        <span class="keyword">let</span> model =</span><br><span class="line">            cgmath::Matrix4::from_translation(<span class="keyword">self</span>.position) * cgmath::Matrix4::from(<span class="keyword">self</span>.rotation);</span><br><span class="line">        InstanceRaw &#123;</span><br><span class="line">            model: model.into(),</span><br><span class="line">            <span class="comment">// NEW!</span></span><br><span class="line">            normal: cgmath::Matrix3::from(<span class="keyword">self</span>.rotation).into(),</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Now we need to reconstruct the normal matrix in the vertex shader.</p>
<p>现在我们需要在顶点着色器中重建法线矩阵。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">InstanceInput</span></span> &#123;</span><br><span class="line">    [[location(<span class="number">5</span>)]] model_matrix_0: vec4&lt;<span class="built_in">f32</span>&gt;;</span><br><span class="line">    [[location(<span class="number">6</span>)]] model_matrix_1: vec4&lt;<span class="built_in">f32</span>&gt;;</span><br><span class="line">    [[location(<span class="number">7</span>)]] model_matrix_2: vec4&lt;<span class="built_in">f32</span>&gt;;</span><br><span class="line">    [[location(<span class="number">8</span>)]] model_matrix_3: vec4&lt;<span class="built_in">f32</span>&gt;;</span><br><span class="line">    <span class="comment">// NEW!</span></span><br><span class="line">    [[location(<span class="number">9</span>)]] normal_matrix_0: vec3&lt;<span class="built_in">f32</span>&gt;;</span><br><span class="line">    [[location(<span class="number">10</span>)]] normal_matrix_1: vec3&lt;<span class="built_in">f32</span>&gt;;</span><br><span class="line">    [[location(<span class="number">11</span>)]] normal_matrix_2: vec3&lt;<span class="built_in">f32</span>&gt;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">VertexOutput</span></span> &#123;</span><br><span class="line">    [[builtin(position)]] clip_position: vec4&lt;<span class="built_in">f32</span>&gt;;</span><br><span class="line">    [[location(<span class="number">0</span>)]] tex_coords: vec2&lt;<span class="built_in">f32</span>&gt;;</span><br><span class="line">    [[location(<span class="number">1</span>)]] world_normal: vec3&lt;<span class="built_in">f32</span>&gt;;</span><br><span class="line">    [[location(<span class="number">2</span>)]] world_position: vec3&lt;<span class="built_in">f32</span>&gt;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">[[stage(vertex)]]</span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>(</span><br><span class="line">    model: VertexInput,</span><br><span class="line">    instance: InstanceInput,</span><br><span class="line">) -&gt; VertexOutput &#123;</span><br><span class="line">    <span class="keyword">let</span> model_matrix = mat4x4&lt;<span class="built_in">f32</span>&gt;(</span><br><span class="line">        instance.model_matrix_0,</span><br><span class="line">        instance.model_matrix_1,</span><br><span class="line">        instance.model_matrix_2,</span><br><span class="line">        instance.model_matrix_3,</span><br><span class="line">    );</span><br><span class="line">    <span class="comment">// NEW!</span></span><br><span class="line">    <span class="keyword">let</span> normal_matrix = mat3x3&lt;<span class="built_in">f32</span>&gt;(</span><br><span class="line">        instance.normal_matrix_0,</span><br><span class="line">        instance.normal_matrix_1,</span><br><span class="line">        instance.normal_matrix_2,</span><br><span class="line">    );</span><br><span class="line">    var out: VertexOutput;</span><br><span class="line">    out.tex_coords = model.tex_coords;</span><br><span class="line">    out.world_normal = normal_matrix * model.normal;</span><br><span class="line">    var world_position: vec4&lt;<span class="built_in">f32</span>&gt; = model_matrix * vec4&lt;<span class="built_in">f32</span>&gt;(model.position, <span class="number">1.0</span>);</span><br><span class="line">    out.world_position = world_position.xyz;</span><br><span class="line">    out.clip_position = camera.view_proj * world_position;</span><br><span class="line">    <span class="keyword">return</span> out;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<div class="note">

<p>I’m currently doing things in world space. Doing things in view-space also known as eye-space, is more standard as objects can have lighting issues when they are further away from the origin. If we wanted to use view-space, we would have include the rotation due to the view matrix as well. We’d also have to transform our light’s position using something like view_matrix * model_matrix * light_position to keep the calculation from getting messed up when the camera moves.</p>
<p>我现在在世界空间里做事。在视图空间(也称为eye-space)中进行操作更为标准，因为当对象离原点较远时，可能会出现照明问题。如果我们想使用视图空间，我们还应该包括由于视图矩阵而产生的旋转。我们还必须使用视图矩阵<em>模型矩阵</em>灯光位置之类的东西来变换灯光的位置，以防止相机移动时计算出错。</p>
<p>There are advantages to using view space. The main one is when you have massive worlds doing lighting and other calculations in model spacing can cause issues as floating point precision degrades when numbers get really large. View space keeps the camera at the origin meaning all calculations will be using smaller numbers. The actual lighting math ends up the same, but it does require a bit more setup.</p>
<p>使用视图空间有很多优点。最主要的一个问题是，当有大量的世界在进行照明和其他模型间距计算时，可能会导致问题，因为当数字变得非常大时，浮点精度会下降。视图空间将相机保持在原点，这意味着所有计算都将使用较小的数字。实际的照明数学结果是一样的，但它确实需要更多的设置。</p>
</div>

<p>With that change our lighting now looks correct.</p>
<p>通过这一更改，我们的照明现在看起来是正确的。</p>
<p><img src="https://sotrh.github.io/learn-wgpu/assets/img/diffuse_right.e3a6b793.png" alt="diffuse_right"></p>
<p>Bringing back our other objects, and adding the ambient lighting gives us this.</p>
<p>带回其他对象，并添加环境照明，我们就可以做到这一点。</p>
<p><img src="https://sotrh.github.io/learn-wgpu/assets/img/ambient_diffuse_lighting.98735034.png" alt="ambient_diffuse_lighting"></p>
<h1 id="Specular-Lighting"><a href="#Specular-Lighting" class="headerlink" title="Specular Lighting"></a>Specular Lighting</h1><p>Specular lighting describes the highlights that appear on objects when viewed from certain angles. If you’ve ever looked at a car, it’s the super bright parts. Basically, some of the light can reflect of the surface like a mirror. The location of the hightlight shifts depending on what angle you view it at.</p>
<p>镜面反射照明描述从特定角度查看时在对象上显示的高光。如果你看过一辆车，那就是超亮的部分。基本上，一些光可以像镜子一样反射表面。强光的位置会根据您的观察角度发生变化。</p>
<p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAZAAAAGQCAYAAACAvzbMAAABhGlDQ1BJQ0MgcHJvZmlsZQAAKJF9kT1Iw0AcxV/TSkUqgnYQcchQnSyIVnHUKhShQqgVWnUwufQLmjQkKS6OgmvBwY/FqoOLs64OroIg+AHi5Oik6CIl/q8ptIjx4Lgf7+497t4BQr3MNCswDmi6baYScTGTXRWDrwigHwKmEJOZZcxJUhKe4+sePr7eRXmW97k/R6+asxjgE4lnmWHaxBvE05u2wXmfOMyKskp8Tjxm0gWJH7muuPzGudBkgWeGzXRqnjhMLBY6WOlgVjQ14hhxRNV0yhcyLquctzhr5Spr3ZO/MJTTV5a5TnMYCSxiCRJEKKiihDJsRGnVSbGQov24h3+o6ZfIpZCrBEaOBVSgQW76wf/gd7dWfnLCTQrFga4Xx/kYAYK7QKPmON/HjtM4AfzPwJXe9lfqwMwn6bW2FjkC+raBi+u2puwBlzvA4JMhm3JT8tMU8nng/Yy+KQsM3AI9a25vrX2cPgBp6ip5AxwcAqMFyl73eHd3Z2//nmn19wOsGnK+VYnm+gAAAAZiS0dEAAAAkgD/KtY4bAAAAAlwSFlzAAAuIwAALiMBeKU/dgAAAAd0SU1FB+QEEgI7HGWmrfkAAAAZdEVYdENvbW1lbnQAQ3JlYXRlZCB3aXRoIEdJTVBXgQ4XAAAgAElEQVR42u3deXhU5eG38e9MlskGSQwEggQEZBUDURAtsii4Ly1aUFyKtrX+3ABFq6i4UQuKtBp3alX01VC19VLbagVZSkFbRRQ1LCqKLAFCSAhJyDLJvH9EZjLZmGSWs8z9uS4vk1nPDJPnPs85c2YcyvN4BABAOzl5CgAABAQAQEAAAAQEAEBAAAAgIAAAAgIAICAAAAICACAgAAAQEAAAAQEAEBAAAAEBABAQAAAICACAgAAACAgAgIAAAAgIAAAEBABAQAAABAQAQEAAAFEmlqcAQEdlOqT7h0hj+0s9M6Qkl+TxSOVV0u5S6dNt0h2fSTvqea4ICAD8aHJnaeG5UnbX5uelpzT8N7in9PImaUclzxcBAQBJI+OlJ34qZaY1/F5dK73zqbRko/RDtTT6KGl4d2nsAKnew/NFQADgR/ed5IuHxyMtfF+6a6vv/I93S9ot6TPfaS/lSlee6n87tXVSabn05Xbp3g+l1VW+85aNlyYc3/DzV9ulZ9ZKs05r2FR28JD03gbpsnXSVUdJd4yX+nSTatzSt7ulOSukd8r97+uEOOmBk6QT+kgZnaQYp1RWKRXskBZ8KL3V6PL/GiudOcx330+skW4ZJ/XuKpVWSN1eav/jISAAIOmkfr6ft+7xj0d7xMVIXVOl01KlIT2lM/OlDe7ml0t2SfN/KiUnNPyeniJN/YmUECdNHCp1Smw4PT5WGnaM9Ni50juv+a5/TrL0wkVStzT/201PkUYPknJ6SzPflJ4vbvm+F/xMSvnxvh0heDx2wbuwALRLTqzUpbPv9693B3a9X6yXHI/7/hv2tDT7TanoQMP53dKk24e1fN1jMqWVG6UJz0mrN/pOnzRSKimXpr4k/f4fvtP7dJOuz/T9Pu90Xzy2F0nXL5HOfE5au7nhtE6J0pyJrd/3tr3Sr19tWO7Ml4J/PAQEQFQamOT/+8Hqjt3OBrc0f4f0v0azl+N6tHzZ0grp/P9Iyw9Jq771P2/xR9KSAw2zoNIK3+mDjmr4/2iXNLSX7/Q/rJSeLpKWHpKu/EBy1/lC8auM5vddWS394p/Sn4tD93jsIuo3YRXm+iakWevZ2wccyeYm76hKcQV2vdEu6b6TpaHZDZuO4mMlR5PtQYc3EzVVVOb7uaxJsJY2mgEdjoEkJcb9eL9dGvZ3HPbHydIfW1nG3ExJTUJRWCJ9Whvax0NAbBSOpqcREqDtNe19Zb7NWP27BXa9/Iuk7C5tXyamlW0iNY32IzQ9pCSUO6qT4pufVlUb+sdDQGwWj6bnExGgdf/7Vjo3t+Hnft2luX2kOd+1fvkbM/0H26c/kJ77umHNful4aeLx4VvWNfukunrfYH5tvrRoX3C3aeTjMRP2gXQwMkA0u+9/0t7Shp8dDum2s6TXRkqTOjW8Xfb6TOnPOdLWKdIZiVJ1k2lDaZXk9kgPHyuNHhDeZV1TLRVs9/1+z5nSndkNyzkltSF+y0+Xvrsk8Ns08vEwAyEMgKV9XCPd9Lb0yDkNR6K74qTJJzf812wt1SH9aZ90b7F09I87qWefJ82WVF/fcBxG453c4XDXcunPFzW8xfboDOnBn0kPNrlMWTuOljf68TADITaApb12QBrxF+nZ5dLGHQ0DsLuu4WC6knJp0w7p1bXSVz/uo7jpHenTrQ2fk+Wuk3btlxa8J23dG/5lfadcOjtfemedtLO44cj5uvqGZf6hSHp3vXTrW+27TSMfj1k4lOeJqo397Y0C+0IAgBlIh4LALAQACAgAgIBEdhYCACAgAAACEjnsBwEAAgIAICDBYT8IABAQAAABMS/2gwCAv7B8FhbfsQEABCTotXQzxyRrvYeZBQAYHZBABmKrf2GTWb4npOlzzSwPgOVnIB0ZAK02+BkZkdYizTcpArBsQILZDMTadGhneDx/ACLFdO/CKsx1eP+LhI4MuGbeb8I+HaB1npt8/8EkM5BwD4bRvlZNFIDgw9HaaY7HeX4MnYGEe4AP9wBqt0ARHKDteLTnfIQ5IHbAvgOAyMCggFh9FtKex0BsAPuFgYgYPANhYLVmOAEQEcMDcjgiVg7JkZY9ko+NeAAwM4fyPGEfEUMxEBoRJSMPeAzmOWMmCAQ3q+CdWYGJyNt4Dw9oVlujNtsR5wBgJhF9F9bhzVvtHZijaY062Hgw+wCYTdhqBhLIQNfSwBltgyHxAMIXEXaQ2yggDH6hiwfhABDVAQHxQHRqPDNgcxMBQYRmH8QDdglH09OsGpKmj8nuQeSjTJh5AKaIR3vON+PjaS2Idt73QkCIB2CpQdlqMbRiEAPFJiziAZhuwG3t8uwjMZeIHImOIwtkPwjxQDQGJOKD4uPheyx2C2DUzEDau6OawRqAlUPIDCTC0TA6JG0tL0EDg695Zh8dXX67zUBsGZBwfJaUUSEhHCAg5goJ8bBxQPj6W4CIhDMmBMQnoH0gVlkjjsSn2B6+D0ICRFfogvk8Lbu+e6zNGciRBmSzDKJGfvy5GUNilX83IFp2REddQNozKPO9GeYYlHmnGQgJ8YikkByJHumBvDDXYbovXTJ6mTpy33xxFYgH8Qh5QMw6GJkxHAzKAPGIViH9LKxwDZ5WCIeRyxvMfRE8EA9mHx1l+iPRrTzAFeY62M8AmGSQjmSwouUzu0KyE72pUA2a4YpHW8tntYMQrXa0PRDsQB6qwTlcQYmmD3w07QzEqIE8a73HMrMeNj+BcAR/e6EOidW/FCskM5BgBqhQrNGaYSYQymUI5Vq+WZcLsEo8IjkrsXNIYkO9Nm6XeDS9jlnW9pl1INpEcgBufF+hiomdZyRHfBdW1noPa6kheB5CMfCHOh78u8Lsa/VGDrqhvm87fr1twG/jDWQANeuAFMrlCiYkZpk9sFIAGBcwO0Wkw5/GG84PWLTKNv5I7iPi3VaIthmI2Tb5hHrgt8MmLVN+nHuoAhKJATNSETHD26qBSA6+Zh1gQxkSq0fEadcXrNkHzUhtziIeiLaZS1u3F4r9EKEc9K2+X8R0AbHaphqjd6y3tVzEA2Zh5Jp2S4N0sAN3OHawExCD42HUoBlsRAJ53O25D8IBZiGBXd+q7xAjIGGIh5GCvX8r7fcBGHB9j8nsH61i+4AEu4PYLINmuJfDqm+jBoKJSEcH1kCvF4qB+3BIom1WYumd6GYcMMO9T6SlYLK/A8xE7DkrISBhmn2YecCM1D4RwoFoiYgVN+9EQ0QMDYgd4xGqZeQzr4DIDODhHOij8ittiYc5IgIwwBMyAhKF8QjFMjMLAXw6cuzGkQZl3oobZBwj/VEm0fqRHNEUTaA9UYjULKbxfRkRjrYeq1VDFtGARPvnORERILQBsdoA3PTxWn0GFMtLGIBha7CPhyYiZh+YW3uMnpusHZGIzUD4NFlmIUA4ZyFmnKUE+tisGhHTz0DsNnAefjzsIAeMHczDOWjb7ZsHLTkDsetaN88FEJ0Drt1mIaacgdh5sGTmAcAunDwFxANg7RsEhHgAlo5ItIaEnegIWzzY/4FoHUzZN8IMJGrX1gP9ZF1El/zNK1Q43aHC6Q6tXPsCT0gAsxI7z0ys/NjYhGXyCNpl9vHorq+8g2bhdIfWrHqy2WU+f3uO9/xF2z7mRQTbx8TqjyViAYmmzTDE48j6/vVG3VGyg1ERQcWEeBiLfSAmDkfj27NjTCZ/+KLmn3s3LxyEbBC2wj4TO82gTBuQwlyHpQbNUMSjraPUD59mp5D0eG+O5p84RXd0G3DEy+bWuXXb1jU6buMypX+9SjEVxao45mRtGzRBrw85S4tSMryXzd+8QuOfPF2StPnS5/X88Em69uNXlL3uDZX2GaWcSfP12qZlGvPUGd7LvDD8Z7ph7fPKWveGKnrlavmp1+j67FxNqSrT9I/z1evjJapJ66Hvh56r+bkXaVlcovf+8nZu0OSHhvktrzt7tA70G61NgyZowcDT9N+YOEZ7gwZnM0XFbvtyTD0DscqgGe542C0k5SdcKTmcSlm3WOf/Z5H+cNEC7XW0/rgn1h7So2/PUcaqhX6nd9pXoKGfPK/BmTnqe83rLYYoqXK/7llyg5I/e1WS5DxmZPPLVBTrnvzrlfT5EklS6s6PNOnDp+W6+SONXfWkUj59WZIUJ+m4z17V78oWatnEW9r+w9q+Rhnb12j0yoc14PTZ+vmFc7XFGcMIH6WzFLu+CSCiAcla7+nQYGvm2Ugo4xHM/VopKHXxyVo+5jeatG6xMlYt1D2jrtSNPYe1evm71r3ujcf+sbco7+zZ+taVrBkF/9KIP09SzN4Nmpp/nd6/4R9aHpfgd93st2/VpqkvaNHUp5SfmNri7We/c5uWTf+3Fk1brFmblmrUovMlSef+8WTtPG++frugXAMrSzRj7hDJfVC9356lq39ytV5ISpckTT86R9PzfM//gPo6nVFRrOuWPqKMlQvUdfk8zThxim7IHs5ozizAVizzLiwzvh021PEI5vYOv2XYKm8d/n3P4do/5mZJ0lnLH9WA+roWLzeirlYD3n/I+/ub467TsyldtCwuUbNyLtShoRdLkuK3LtclhQXNrn/o+Mm6YdQVrcZDkspG/UZXHjtGq2Pj9WFP/0H+tVFX6E1Xsuan99SBEZd7T+9bsb/V29vijNGTnTK1PucC72kDC79itAEBMWJt24wRMWrm0d6gmNUOh0N/H3utJCnlkxd153f/bfFyoypL5dznC8O6zlm+gdrhVHGfUd7fu5fubHb9PceOUYGz7Yn2vp45vpjExvudt6pTpvdntyvZ+3Oiu8Yvcn/ZtFyfv32Ptj12pnbd1k2F0x2amDfWe5nk8mJGG9iO5d6FZfTmLLOHo7XlNeMmrtu7DdTEs+eqx3tzNO79h1WVnh3y+6h2pRzxMrVxSd6fPfL/922889vRygdXP7v0EfX4551t3kdMfS2jDZiBNN1U0pHNJsEOZkatWYc7HtE4I3n9lKskSQkb31La2ieanf/fpDTVdxni/f3EskLvzwM89cr43nfAYWFaj4gv/7TKEr94LL5rsyY8WqusPI/+ff0yRhgQkEAHoPYMUlaLiNVmHmaLb2vmp/fU1oufaPX8T2LitOXM272//2z1Iv2mvFin11Zp4Rd/V+IXr0uSavqerjeyhkR8+d2ORn9CsZ1UGp8otxyas3+bRrZwtD0QVQHpyJqrXSMSTDgCfazR+MGJL594iTyuzFbPf/DEydo/tuFtsxkrF+j+O7volVmJGvHcTyVJdZk5yp/6tN+xGZHySmKqdp0998eaHNSMe3tp1cxY/d9jZ+r7nAsZYRC9AYnEAG2FiET6+9zDHRGzhfeZlC4qmLyw1fOXxSVq2qT5WnHjShVNuFPu7NGqTx+g8hFX6asr/p/mzvwgoIMRw+XuibP0+S+WqGL4ZXL3GKndZ92vp2Ys1TYDlwmIhDa/0jbSH0Nuxo89N3KZwjnQ8xHxAMIWELMcIGeH2Y0ZZ1kEBECwTPc23o4erR7owGvEwBnsW49DdbAh8QBgiRmIlXaQt7SsVlnr78hyEhAAYQ1IsINoKAYpO36bX7iP9SAeACIlLJuwGKSOPMiH4zlq6xN9+TcBENEZSHtnAWZ8F1S0zkYAwPCAtDWQR2oAJCIAYOGAGI2IAGg6FvC3Q0AsHZJAv0mQiCBaBnVWwggIL9gOvGiJCAgHs/lo4rTqgrfnAwoj9UKNlg+HBMz6euVvKLJirf4AInUQYKChCPZIejN//zsANGbZTVhGrpkEMsCzOQv8PZlrxRLMQAyfqbT3ez06+odm5q+iBYCoCkiwUenoQM4mLQB2ZbpNWHZ9jzebtGA3Zt2Mxd9K5DjN9GJs+oLsyNfpWmm2Y4c/VgAExNRrMkSEiIA1fWYfBIQ/OiICm72eGbSjl+H7QIz+tF8rPG7WtGBnZvoaazADYSYCEA8QECJCREA8YFaxPAXmiAgHHIJwgIBY8IXUdDmMGIw54NAkg9v0Rsch5fF8Eg+0xdCd6O19MYV6gDzS/RsxILNz3fhwNHtOCYkl4sFrP/KcvJjNtbbEfhFzxSOQ88HrkoBE2ezDzIiIeeIB4gFmIB1+QRv14ici5ooHoeF1CJMEhBcVEbHizIOItO+1x/48AmKLgZSIIFQhICKRec0RDwJCkIiIreJBRIgHDA6I1Xaem+XFHOyH1tnpo/HNMPATkdDHo+lrnBUfAsIshNmI7eJBRMITDxAQWw3GZn1RExHzDPTRHhGz7CwnQATEkBdFS5uGrPAdB0TEPAN8tEaE/R1wWu0FF+6QWOkFTUTMM7BHW0SIB0w/AwERsdKAHi0RIR4gIETEthFh57Z548FX4BIQEBFEWbw4shyGB6Q9LyBebESEAdwesw7+ngkILBQRDjiEHeIR6PWIUxQFJJB/bF4QzEYs+7zb6MunmHnAlDOQ1taS2cFGRCI5gPNNg+H7tw/V37JVD/aNFoZ+Jzr/+JF5jvmu9dDEIyvPExVffWu2neWHb6/xcjF2mIOh34mO6B0Uwv54Axzo27PTvbXrEQ5WCgkIiIgNB4cjDfQdDQivDeIBgzdhIbKicXMW+zmIB8KHt/FGYUSMHmxgr1kp8SAgICJEhHgw6wABQfjXHImItcNBPEBAYOhshKPWo2/WQTxAQBDSAYGIEA8QEBARIkI8iAcICIgIQvPvwjutgpPfY4V3c+/KPi/Y6rFxHAiaDRZ89AnxCNesI8fp1uzuq3V86vtKjV8tp6NI1fXHqcrdW/urB2tT+XD9es9J/MMREBARWDUc4YjHEKdbLw94QJmJc/1OT4zZosQYKd0lJcfdJxEQAgIiQkSIR2Ozuq7zxqOw8gE9u/06rTiUruPiqjQwYb9O7rxBRyUU8g9IQEBEiAjx8Nc3eaP353UlZ+vZyi6SpC01yVJNslSW3ew6+T1WaHy30yVJm0uf1xM7f66Z2a+qV8oS1XsStbX8Ej2x42L9rSal2Wznjm4fKafzUh2V8G/FOPbqYM04bT54jp4snKj33Yl+lx/gqNftmR9reNpyZbhWK9a5R6U1p2lD6Xl6Ys9ora2LlyS91/t1DTtqiiTp0/1/1XnbLvLexsbjpist/nFJ0ovfb9Hskv5tPh95GRs0udcwv9Pc9aN1oGa0NpVN0ILdp+m/dXGtPhfPF07StT1fUXbyGyqtGaWcjfMJCIgIjIlHuP+d6j2+4ebUri9rfm2q3izr4zdItiUhrkTzBkxXStyL3tMGp76reUlrVLopT8vdCZKkcbFVenzAA+rqmud3/VRXgU5yPa0hqdN099d5+kt154bLx1Trsf7z1C3xfr/LZ7g+1WndFkpaqbW7xjVfIE/o3zQS61yjjIQ1Gp3wsAakztbPN87VFk9Ms8slxe3XPf1vUHLsq5Ikp2OkIa853oWFgAYWDjgkHsHaWjHQ+3Na/OOadsxAvZnTV18Ovl3/6P033dF5R5vX7508SxtKp+jSLw7poa8LVV57lSSpc9yfNLPHv7yXm5P9hjceOyvnafam/bp0Q5U+2feWJCklbrFmHbPIe/m7s//mjUd13Xla8sOXmrKhSrcUlOrvO/+ng7WdWg6ignvOpxfneP+2stZ7NO4zt363ZY+Kq2+TJHV1zdOMjC9avG528q3aXnGGbikoVdZ6j4YWPExAYP6QGL15BaGPc6RmiPOKTtSuygf9TnNohzISHtYJR12sGf2ytaLPS61ev7x2mq7bebZWuRP0aHl3rSi63nvekNTXJEkjnLUanOqbeTzzwzV68VC6VtW5NGPH+XJ7GtbUs5Nu01TXAeXGuDU4zbfp593Cubq5+DitrnMpvzpV1+wdqWuLTmhliWJC+vxs8cToyYpMrd9/gfe0gSlftXjZQ+7JuuH7K5RfnWro649NWGj3YMMmLXvMOiIZD0na6nFq6pY7dEuXszQifZmykl6S01Hgd5lBadP0x4wTdXPxcc2uX1Q1QnsbbTb6prKH9+fk2FeVG7NYo1ylfrc5d1AXzW1leYYmFimtpkYxjg3e01aU9Qv48dQHuQlrhLNWt3VfrUGdVyot4SPFOT6XQ3v9LpMcV9zidfdUjVFBvfHDNwEBESEeEbPF49T/FZ0oFZ2oIc5Zuihlp0albdAJR82U07FVktQ/5WuphYDI4f+YHUEuflJMdVCbYJxNFiDeWdSu6z/b/xH1SLqzzcvEOGpbPL3anWKK1yEBAREhHoYoqI9VQVlvqay3/h23W/07/+bHgbmuxct3dX2iTIfHOwvpl7zLe16l+1Ktr4tVTFWa6j1DvLOQ324s0ctVaa0uQ26MW3WeHO8sZHznb/VaUW6rl6/1JHh/djkrvD9PcpUrMXZ5wI99WmKJXzwWf79ZLx3oq4L6WP3l6A80NnOiJV6LBAREJIriYeTz/Wb2P5Uet1ufl43UpsruKqjppJL6WF2Qsks9k5Z6L7e1/NgWr58S96KePnqqHi0cpxMSSnRa16d8MTpwiSTpk/o4bTlwuwalTZMkzez9hNJ3XKNlhzLUP6Zag1ylOintK2Unb9BJm2/V+rpYbTxwu4amXS5JOifrfj1SN0/vHOirbrHVOit9o9yeGF27Z4QkaU91N+999uv0lq5Nmqgid4Ju7bW42eantrjrG899Oqm0LlFuj0NzUrdpZMaTlnk9EhAQEWYdEZHorNDA1F9pYBv7fXcful95xce3eN62ioXKScvXa13P8jv9YO0v9Vih77QHd0zWowlfKSPhYfVImqPZA+ZodpPbOlj7S+/PD/xwsZ5I2KjMhN8pIeYtXd77LV3e6LIr9qz0/rxk//E6o9tZio/5l5Jil+i+gUsalq38DzpQfZ1SXU8H9Fy8Up2qWyrnqkfSHEkHNaNfL82QVO8ZoM1lszU49U0CAiJCRIjHYe8UjVep+wMdk/SF0uI2KyH2e8XHfKFaz2DtrxqtL0tP14K9p2iLp+U9E1W16bpr22Oa3vNk9UpZIo8jTt+WXabHd/5cy2p9BwYuq03UlM0P6reZFyondbkyElcrVjtV6T5JB2oGadPBU/Tuft8BfKvrXJq0+T7N6XqehqV9oAzXasU4C1Vac4a+PHCunt57it9tL/x2sa7o+bK6uZapTkn6ouRqzd55jv46+JZ2PR93b52lGT3769iUt+WK+Vr7qs7XG7uu0rFJOzQ41RqvTYfyPPzlImo3rxROD3yZs/I8lntOzRKPjmp69PX4767mD81EOA4EIZ2JcMAh8QABAQwbtIgI3+EBAgIiQkQMigcQCexER1gjws71yEbTbs/X1F2nSbsIIjMQMBNhJkI8QEAAIkI8AAICImLheLCzHAQERCQKI8LO8sDl91jhfZv3yj4vRPy2WruO0ctFQEBEoiwiVvoOj1B6NOMr72MvzHVoiNPd7DI7hg/znr+o28f8wRzBzJTd3udr+7BTCQiiIyLResAh+ztgJ7yNF4aGJJre5ks8Os6sb+eN9rcZMwOB4RExelAmHubX1v6BqxNKtPrYZ/TDsLH6PudcLT0mX+NiqvX54Dne6zzZ5bNWb/u8uEot7/uitg2boK3HT9HKvs/rovhy0y/XpwMf1O39s3yzAecav02ENyTvDfu/CzMQMBMxeTzYZNW6y10HdM+Aq5UQ85b3tKHp7+qxhHsV46g+4vUTYku1sP+tvo9hd0oDU1/XfQnf6D8bH/T7Cl07LBczEDATschMJFp3lgfqg2FxfmvMhbkOv+8nD8S1PV/zDtIl1TN176Z9+vWXFSqpOUYZrgVHvH7vlFu0pfwsXfllpf703Teq9wyQJHV1zdNVKbs6/NgisVwnbL5LD31d6L2Ou360d/9i1nqPnqzIJCAgIlaMCJuswm+I061+nR7x/v524XVadChD/6hN0twfLlW9Z8gRb6PCfZlmbr9Ay2oTdU9pPxVXT/Ke19NVbKvlIiAgIhaICPEIzITPa/3WmLPWe1TnyQn4+qNcZXI6tnh//6TCtz9guTtBZbXjj3gbew+doq2NvsCqtt73TU4JMdUdelxmXS4CAiJi8ogQjwgOXk2e6voO3EZNXbLf7x6P07bLRUBAREwcET6WJLI+rOrstznohOQ93p9Pj61S57iVtl8u/++TrSMgQKgG1EgecMjO8sgrqI/Vt+U3e3+/sPtzmpZYonPiDmlOryVyOgpsv1wH6l3en2OdH+nGpD3qFMF1JwICZiNB3jbxMM6z2yeryn2BJKlrwkOaP+goPT80Selx36m4epZvTd3hsOVy/bMqTQdrf+n9/a6B3bVluEPfHX8hAQHMHBH2dxjvlepU3ffNYn1b9pRq68eouu4cfVnyqm765k65nL4D6SrrXLZcrr0eh/K2/l47Kh5Sbf2YiD//DuV5eAXDMkK9tl84PfDby8rzEA+L+EVCqeYPHiiHGgbrOzfu1wtV6SxXiHEkOiw3EzH6qHU2WZnLJwPna2XRT7W2vKd+cCdoQtJeXZb9jHeQ3lX5e0MGabMuFzMQMBMJ0SDe3hkI8TCfXbnZcmhHi+cddP9K925ZqPzqVJaLgAChjUjAAVkdmtkTQu/mlEKd3/UDHZ24Vp3iV8mto1VS9RNtPDBeTxX9RKvd8SwXAQFCHxEFst+ReAAt4l1YsLSgB+bVQZ5PPBDFmIGA2UhrsxHiATADAbORds9GVge/LMQDzECAaJuJMOsAmIGAmQjxAAgIYPqBnHiAgABEhHgABARExBP22yceICAAEWHWARAQILyDPfEA+DTesPDcxHNg0n8ZSdLu/wT3Nt/up3rkOZVn0yocj/MchO255TgQwhGNOhqR7qfy50JIcBibsIhHVGpvCLqf6iEe/I2CgADtjMgYniuAgLBmg/ZGZIzUna28/K2iRexEBxE5tYWd64fDQTsAAgK0azZCOIAjYhNWCPDuDoC/VQICAAABYc0GAH+j4cQ+kDC8QHmnB0A4CAh4wQJAK9iEBQAgIAAAAgIAICAAAAICAAABAQAQEAAAAQEAEBAAAAEBAICAAAAICMNszhAAAAIZSURBVACAgAAACAgAgIAAAEBAAAAEBABAQAAABAQAQEAAACAgAAACAgAgIAAAAgIAICAAABAQAAABAQAQEAAAAQEAEBAAAAgIAICAAAAICACAgAAACAgAAAQEAEBAAAAEBABAQAAAICAAAAICACAgAAACAgAgIAAAEBAAAAEBABAQAAABAQAQEAAACAgAgIAAAAgIAICAAAAICAAABAQAQEAAAAQEAEBAAAAEBAAAAgIAICAAAAICACAgAAACAgAAAQEAEBAAAAEBABAQAAABAQCAgAAACAgAgIAAAAgIAICA8BQAAAgIAICAAAAICACAgAAAQEAAAAQEAEBAAAAEBABAQAAAICAAAAICACAgAAACAgAgIAAAEBAAAAEBABAQAAABAQAQEAAACAgAgIAAAAgIAICAAAAICAAABAQAQEAAAAQEAEBAAAAEBAAAAgIAICAAAAICACAgAAACAgAAAQEAEBAAAAEBABAQAAAICACAgAAACAgAgIAAAAgIAAAEBABAQAAABAQAQEAAAAQEAAACAgAgIAAAAgIAICAAAAICAAABAQAQEAAAAQEAEBAAAAEBAICAAAAICACAgAAACAgAgIAAAEBAAAAEBABAQAAABAQAQEAAACAgAAACAgAgIAAAAgIAICAAABAQAAABAQAQEAAAAQEAgIAAAAgIAICAAAAICACAgAAAQEAAAAQEAEBAAAAW8v8BQR2HRzqeBAEAAAAASUVORK5CYII=" alt="image"></p>
<p>Because this is relative to the view angle, we are going to need to pass in the camera’s position both into the fragment shader and into the vertex shader.</p>
<p>因为这是相对于视图角度的，所以我们需要将摄影机的位置传递到片段着色器和顶点着色器中。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[[block]]</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Camera</span></span> &#123;</span><br><span class="line">    view_pos: vec4&lt;<span class="built_in">f32</span>&gt;;</span><br><span class="line">    view_proj: mat4x4&lt;<span class="built_in">f32</span>&gt;;</span><br><span class="line">&#125;;</span><br><span class="line">[[group(<span class="number">1</span>), binding(<span class="number">0</span>)]]</span><br><span class="line">var&lt;uniform&gt; camera: Camera;</span><br></pre></td></tr></table></figure>

<div class="note">

<p>Don’t forget to update the Camera struct in light.wgsl as well, as if it doesn’t match the CameraUniform struct in rust, the light will render wrong.</p>
<p>不要忘记更新light.wgsl中的Camera结构，因为如果它与rust中的CameraUniform结构不匹配，灯光将渲染错误。</p>
</div>

<p>We’re going to need to update the CameraUniform struct as well.</p>
<p>们还需要更新CameraUniform结构。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main.rs</span></span><br><span class="line"><span class="meta">#[repr(C)]</span></span><br><span class="line"><span class="meta">#[derive(Copy, Clone, bytemuck::Pod, bytemuck::Zeroable)]</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">CameraUniform</span></span> &#123;</span><br><span class="line">    view_position: [<span class="built_in">f32</span>; <span class="number">4</span>],</span><br><span class="line">    view_proj: [[<span class="built_in">f32</span>; <span class="number">4</span>]; <span class="number">4</span>],</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> CameraUniform &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">new</span></span>() -&gt; <span class="keyword">Self</span> &#123;</span><br><span class="line">        <span class="keyword">Self</span> &#123;</span><br><span class="line">            view_position: [<span class="number">0.0</span>; <span class="number">4</span>],</span><br><span class="line">            view_proj: cgmath::Matrix4::identity().into(),</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">update_view_proj</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, camera: &amp;Camera) &#123;</span><br><span class="line">        <span class="comment">// We&#x27;re using Vector4 because of the uniforms 16 byte spacing requirement</span></span><br><span class="line">        <span class="keyword">self</span>.view_position = camera.eye.to_homogeneous();</span><br><span class="line">        <span class="keyword">self</span>.view_proj = OPENGL_TO_WGPU_MATRIX * camera.build_view_projection_matrix();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Since we want to use our uniforms in the fragment shader now, we need to change it’s visibility.</p>
<p>因为我们现在想在片段着色器中使用制服，所以需要更改其可见性。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main.rs</span></span><br><span class="line"><span class="keyword">let</span> camera_bind_group_layout = device.create_bind_group_layout(&amp;wgpu::BindGroupLayoutDescriptor &#123;</span><br><span class="line">    entries: &amp;[</span><br><span class="line">        wgpu::BindGroupLayoutBinding &#123;</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">            visibility: wgpu::ShaderStages::VERTEX | wgpu::ShaderStages::FRAGMENT, <span class="comment">// Updated!</span></span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    ],</span><br><span class="line">    label: <span class="literal">None</span>,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>We’re going to get the direction from the fragment’s position to the camera, and use that with the normal to calculate the reflect_dir.</p>
<p>我们将得到从碎片的位置到摄像机的方向，并将其与法线一起计算反射方向。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// In the fragment shader...</span></span><br><span class="line"><span class="keyword">let</span> view_dir = normalize(camera.view_pos.xyz - <span class="keyword">in</span>.world_position);</span><br><span class="line"><span class="keyword">let</span> reflect_dir = reflect(-light_dir, <span class="keyword">in</span>.world_normal);</span><br></pre></td></tr></table></figure>

<p>Then we use the dot product to calculate the specular_strength and use that to compute the specular_color.</p>
<p>然后我们使用点积来计算镜面反射强度，并使用它来计算镜面反射颜色。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> specular_strength = pow(max(dot(view_dir, reflect_dir), <span class="number">0.0</span>), <span class="number">32.0</span>);</span><br><span class="line"><span class="keyword">let</span> specular_color = specular_strength * light.color;</span><br></pre></td></tr></table></figure>

<p>Finally we add that to the result.</p>
<p>最后，我们将其添加到结果中。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> result = (ambient_color + diffuse_color + specular_color) * object_color.xyz;</span><br></pre></td></tr></table></figure>

<p>With that you should have something like this.</p>
<p>这样你就应该有这样的东西。</p>
<p><img src="https://sotrh.github.io/learn-wgpu/assets/img/ambient_diffuse_specular_lighting.76386148.png" alt="ambient_diffuse_specular_lighting"></p>
<p>如果我们只看镜面反射的颜色会如下所示。</p>
<p><img src="https://sotrh.github.io/learn-wgpu/assets/img/specular_lighting.b3869eb1.png" alt="specular_lighting"></p>
<h1 id="The-half-direction"><a href="#The-half-direction" class="headerlink" title="The half direction"></a>The half direction</h1><p>Up to this point we’ve actually only implemented the Phong part of Blinn-Phong. The Phong reflection model works well, but it can break down under <a target="_blank" rel="noopener" href="https://learnopengl.com/Advanced-Lighting/Advanced-Lighting">certain circumstances</a>. The Blinn part of Blinn-Phong comes from the realization that if you add the view_dir, and light_dir together, normalize the result and use the dot product of that and the normal, you get roughly the same results without the issues that using reflect_dir had.</p>
<p>到目前为止，我们实际上只实现了Blinn Phong的Phong部分。Phong反射模型运行良好，但在<a target="_blank" rel="noopener" href="https://learnopengl.com/Advanced-Lighting/Advanced-Lighting">某些情况</a>下可能会崩溃。Blinn Phong的Blinn部分源于这样一种认识，即如果将view_dir和light_dir添加在一起，对结果进行规格化，并使用其与法线的点积，则得到的结果与使用reflect_dir得到的结果大致相同，而不存在使用reflect_dir的问题。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> view_dir = normalize(camera.view_pos.xyz - <span class="keyword">in</span>.world_position);</span><br><span class="line"><span class="keyword">let</span> half_dir = normalize(view_dir + light_dir);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> specular_strength = pow(max(dot(<span class="keyword">in</span>.world_normal, half_dir), <span class="number">0.0</span>), <span class="number">32.0</span>);</span><br></pre></td></tr></table></figure>

<p>It’s hard to tell the difference, but here’s the results.</p>
<p>很难区分两者之间的区别，但结果如下。</p>
<p><img src="https://sotrh.github.io/learn-wgpu/assets/img/half_dir.bbcc23b8.png" alt="half_dir"></p>
<p><a target="_blank" rel="noopener" href="https://github.com/sotrh/learn-wgpu/tree/master/code/intermediate/tutorial10-lighting/">Check out the code!</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">qianqians</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>

<script src="/js/bookmark.js"></script>




  















  

  

</body>
</html>
