<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#222"><meta name="generator" content="Hexo 5.4.0"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png"><link rel="mask-icon" href="/images/logo.svg" color="#222"><link rel="manifest" href="/images/manifest.json"><meta name="msapplication-config" content="/images/browserconfig.xml"><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext"><link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css"><script id="hexo-configurations">var NexT=window.NexT||{},CONFIG={hostname:"qianqians.github.io",root:"/",scheme:"Pisces",version:"7.8.0",exturl:!1,sidebar:{position:"left",display:"remove",padding:18,offset:12,onmobile:!0},copycode:{enable:!1,show_result:!1,style:null},back2top:{enable:!0,sidebar:!0,scrollpercent:!0},bookmark:{enable:!0,color:"#222",save:"auto"},fancybox:!1,mediumzoom:!1,lazyload:!1,pangu:!1,comments:{style:"tabs",active:null,storage:!0,lazyload:!1,nav:null},algolia:{hits:{per_page:10},labels:{input_placeholder:"Search for Posts",hits_empty:"We didn't find any results for the search: ${query}",hits_stats:"${hits} results found in ${time} ms"}},localsearch:{enable:!1,trigger:"auto",top_n_per_article:1,unescape:!1,preload:!1},motion:{enable:!0,async:!1,transition:{post_block:"fadeIn",post_header:"slideDownIn",post_body:"slideDownIn",coll_header:"slideLeftIn",sidebar:"slideUpIn"}}}</script><meta property="og:type" content="website"><meta property="og:title" content="qianqians&#39;blog"><meta property="og:url" content="https://qianqians.github.io/index.html"><meta property="og:site_name" content="qianqians&#39;blog"><meta property="og:locale" content="zh_CN"><meta property="article:author" content="qianqians"><meta name="twitter:card" content="summary"><link rel="canonical" href="https://qianqians.github.io/"><script id="page-configurations">CONFIG.page={sidebar:"",isHome:!0,isPost:!1,lang:"zh-CN"}</script><title>qianqians'blog</title><noscript><style>.sidebar-inner,.use-motion .brand,.use-motion .collection-header,.use-motion .comments,.use-motion .menu-item,.use-motion .pagination,.use-motion .post-block,.use-motion .post-body,.use-motion .post-header{opacity:initial}.use-motion .site-subtitle,.use-motion .site-title{opacity:initial;top:initial}.use-motion .logo-line-before i{left:initial}.use-motion .logo-line-after i{right:initial}</style></noscript></head><body itemscope itemtype="http://schema.org/WebPage"><div class="container use-motion"><div class="headband"></div><header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-container"><div class="site-nav-toggle"><div class="toggle" aria-label="切换导航栏"><span class="toggle-line toggle-line-first"></span><span class="toggle-line toggle-line-middle"></span><span class="toggle-line toggle-line-last"></span></div></div><div class="site-meta"><a href="/" class="brand" rel="start"><span class="logo-line-before"><i></i></span><h1 class="site-title">qianqians'blog</h1><span class="logo-line-after"><i></i></span></a></div><div class="site-nav-right"><div class="toggle popup-trigger"></div></div></div><nav class="site-nav"><ul id="menu" class="menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-fw fa-home"></i> 首页</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i> 归档<span class="badge">16</span></a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i> 分类<span class="badge">2</span></a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-fw fa-user"></i> 关于</a></li></ul></nav></div></header><a role="button" class="book-mark-link book-mark-link-fixed"></a> <a href="https://github.com/qianqians" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0 0 115 115 130 115 142 142 250 250 250 0Z"></path><path d="M128.3 109C113.8 99.7 119 89.6 119 89.6 122 82.7 120.5 78.6 120.5 78.6 119.2 72 123.4 76.3 123.4 76.3 127.3 80.9 125.5 87.3 125.5 87.3 122.9 97.6 130.6 101.9 134.4 103.2" fill="currentColor" style="transform-origin:130px 106px" class="octo-arm"></path><path d="M115 115C114.9 115.1 118.7 116.5 119.8 115.4L133.7 101.6C136.9 99.2 139.9 98.4 142.2 98.6 133.8 88 127.5 74.4 143.8 58 148.5 53.4 154 51.2 159.7 51 160.3 49.4 163.2 43.6 171.4 40.1 171.4 40.1 176.1 42.5 178.8 56.2 183.1 58.6 187.2 61.8 190.9 65.4 194.5 69 197.7 73.2 200.1 77.6 213.8 80.2 216.3 84.9 216.3 84.9 212.7 93.1 206.9 96 205.4 96.6 205.1 102.4 203 107.8 198.3 112.5 181.9 128.9 168.3 122.5 157.7 114.1 157.9 116.9 156.7 120.9 152.7 124.9L141 136.5C139.8 137.7 141.6 141.9 141.8 141.8Z" fill="currentColor" class="octo-body"></path></svg></a><main class="main"><div class="main-inner"><div class="content-wrap"><div class="content index posts-expand"><article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://qianqians.github.io/2021/08/20/Wgpu%20The%20Pipeline/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.gif"><meta itemprop="name" content="qianqians"><meta itemprop="description" content=""></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="qianqians'blog"></span><header class="post-header"><h2 class="post-title" itemprop="name headline"> <a href="/2021/08/20/Wgpu%20The%20Pipeline/" class="post-title-link" itemprop="url">Wgpu The Pipeline</a></h2><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i></span> <span class="post-meta-item-text">发表于</span> <time title="创建时间：2021-08-20 15:17:03" itemprop="dateCreated datePublished" datetime="2021-08-20T15:17:03+08:00">2021-08-20</time></span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-calendar-check-o"></i></span> <span class="post-meta-item-text">更新于</span> <time title="修改时间：2021-08-23 10:54:40" itemprop="dateModified" datetime="2021-08-23T10:54:40+08:00">2021-08-23</time></span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-folder-o"></i></span> <span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Wgpu/" itemprop="url" rel="index"><span itemprop="name">Wgpu</span></a></span></span></div></header><div class="post-body" itemprop="articleBody"><h1 id="What’s-a-pipeline"><a href="#What’s-a-pipeline" class="headerlink" title="What’s a pipeline?"></a>What’s a pipeline?</h1><p>If you’re familiar with OpenGL, you may remember using shader programs. You can think of a pipeline as a more robust version of that. A pipeline describes all the actions the gpu will perform when acting on a set of data. In this section, we will be creating a RenderPipeline specifically.</p><p>如果您熟悉OpenGL，可能还记得使用着色器程序。您可以将管道视为更健壮的版本。管道描述了gpu在处理一组数据时将执行的所有操作。在本节中，我们将专门创建渲染管线。</p><h1 id="Wait-shaders"><a href="#Wait-shaders" class="headerlink" title="Wait shaders?"></a>Wait shaders?</h1><p>Shaders are mini programs that you send to the gpu to perform operations on your data. There are 3 main types of shader: vertex, fragment, and compute. There are others such as geometry shaders, but they’re more of an advanced topic. For now we’re just going to use vertex, and fragment shaders.</p><p>着色器是发送到gpu以对数据执行操作的小型程序。着色器有3种主要类型：顶点、片段和计算。还有其他一些，如几何体着色器，但它们更像是一个高级主题。现在我们将使用顶点和片段着色器。</p><h1 id="Vertex-fragment-what-are-those"><a href="#Vertex-fragment-what-are-those" class="headerlink" title="Vertex, fragment.. what are those?"></a>Vertex, fragment.. what are those?</h1><p>A vertex is a point in 3d space (can also be 2d). These vertices are then bundled in groups of 2s to form lines and/or 3s to form triangles.</p><p>顶点是三维空间中的一个点（也可以是二维的）。然后将这些顶点捆绑成2个一组，形成直线或3个一组，形成三角形。</p><p><img src="https://sotrh.github.io/learn-wgpu/assets/img/tutorial3-pipeline-vertices.5e39e8fc.png" alt="vertices"></p><p>Most modern rendering uses triangles to make all shapes, from simple shapes (such as cubes), to complex ones (such as people). These triangles are stored as vertices which are the points that make up the corners of the triangles.</p><p>大多数现代渲染使用三角形生成所有形状，从简单形状（如立方体）到复杂形状（如人）。这些三角形存储为顶点，这些顶点是构成三角形角的点。</p><p>We use a vertex shader to manipulate the vertices, in order to transform the shape to look the way we want it.</p><p>我们使用顶点着色器来操纵顶点，以便将形状变换为我们想要的样子。</p><p>The vertices are then converted into fragments. Every pixel in the result image gets at least one fragment. Each fragment has a color that will be copied to its corresponding pixel. The fragment shader decides what color the fragment will be.</p><p>然后将顶点转换为片段。结果图像中的每个像素至少获得一个片段。每个片段都有一个将被复制到其相应像素的颜色。片段着色器决定片段的颜色。</p><h1 id="WGSL"><a href="#WGSL" class="headerlink" title="WGSL"></a>WGSL</h1><p>WebGPU supports two shader languages natively: SPIR-V, and WGSL. SPIR-V is actually a binary format developed by Kronos to be a compilation target for other languages such as GLSL and HLSL. It allows for easy porting of code. The only problem is that it’s not human readable as it’s a binary language. WGSL is meant to fix that. WGSL’s development focuses on getting it to easily convert into SPIR-V. WGPU even allows us to supply WGSL for our shaders.</p><p>WebGPU本机支持两种着色器语言：SPIR-V和WGSL。SPIR-V实际上是Kronos开发的二进制格式，用于其他语言（如GLSL和HLSL）的编译目标。它允许轻松移植代码。唯一的问题是它不是人类可读的，因为它是一种二进制语言。WGSL旨在解决这一问题。WGSL的开发重点是使其能够轻松转换为SPIR-V。WGPU同样允许我们为着色器提供WGSL。</p><p>If you’ve gone through this tutorial before you’ll likely notice that I’ve switched from using GLSL to using WGSL. Given that GLSL support is a secondary concern and that WGSL is the first class language of WGPU, I’ve elected to convert all the tutorials to use WGSL. Some of the showcase examples still use GLSL, but the main tutorial and all examples going forward will be using WGSL.</p><p>如果您之前阅读过本教程，您可能会注意到我已从使用GLSL切换到使用WGSL。考虑到GLSL支持是第二个问题，而WGSL是WGPU的第一类语言，我选择将所有教程转换为使用WGSL。一些showcase示例仍然使用GLSL，但主教程和所有后续示例将使用WGSL。</p><p>The WGSL spec and it’s inclusion in WGPU is still in development. If you run into trouble using it, you may want the folks at <a target="_blank" rel="noopener" href="https://app.element.io/#/room/#wgpu:matrix.org">https://app.element.io/#/room/#wgpu:matrix.org</a> to take a look at your code.</p><p>WGSL规范及其包含在WGPU中的内容仍在开发中。如果你在使用它时遇到麻烦，你可能想让人们在<a target="_blank" rel="noopener" href="https://app.element.io/#/room/#wgpu:matrix.org">https://app.element.io/#/room/#wgpu:matrix.org</a> 来看看你的代码。</p><h1 id="Writing-the-shaders"><a href="#Writing-the-shaders" class="headerlink" title="Writing the shaders"></a>Writing the shaders</h1><p>In the same folder as main.rs, create a file shader.wgsl. Write the following code in shader.wgsl.</p><p>在与main.rs相同的文件夹中，创建文件shader.wgsl。在shader.wgsl中编写以下代码。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Vertex shader</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">VertexOutput</span></span> &#123;</span><br><span class="line">    [[builtin(position)]] clip_position: vec4&lt;<span class="built_in">f32</span>&gt;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">[[stage(vertex)]]</span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>(</span><br><span class="line">    [[builtin(vertex_index)]] in_vertex_index: <span class="built_in">u32</span>,</span><br><span class="line">) -&gt; VertexOutput &#123;</span><br><span class="line">    var out: VertexOutput;</span><br><span class="line">    <span class="keyword">let</span> x = <span class="built_in">f32</span>(<span class="number">1</span> - <span class="built_in">i32</span>(in_vertex_index)) * <span class="number">0.5</span>;</span><br><span class="line">    <span class="keyword">let</span> y = <span class="built_in">f32</span>(<span class="built_in">i32</span>(in_vertex_index &amp; <span class="number">1</span>u) * <span class="number">2</span> - <span class="number">1</span>) * <span class="number">0.5</span>;</span><br><span class="line">    out.clip_position = vec4&lt;<span class="built_in">f32</span>&gt;(x, y, <span class="number">0.0</span>, <span class="number">1.0</span>);</span><br><span class="line">    <span class="keyword">return</span> out;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>First we declare struct to store the output of our vertex shader. This consists of only one field currently which is our vertex’s clip_position. The [[builtin(position)]] bit tells WGPU that this is the value we want to use as the vertex’s clip coordinates. This is analogous to GLSL’s gl_Position variable.</p><p>首先，我们声明struct来存储顶点着色器的输出。这当前只包含一个字段，它是顶点的剪辑位置。[[builtin（position）]位告诉WGPU这是我们要用作顶点剪辑坐标的值。这类似于GLSL的gl_位置变量。</p><blockquote><p>Vector types such as vec4 are generic. Currently you must specify the type of value the vector will contain. Thus a 3D vector using 32bit floats would be vec3<f32>.</f32></p></blockquote><blockquote><p>向量类型（如vec4）是泛型的。当前必须指定向量将包含的值的类型。因此，使用32位浮点的3D向量将是vec3<f32>。</f32></p></blockquote><p>The next part of the shader code is the main function. We are using [[stage(vertex)]] to mark this function as a valid entry point for a vertex shader. We expect a u32 called in_vertex_index which gets its value from [[builtin(vertex_index)]].</p><p>着色器代码的下一部分是主函数。我们使用[[stage(vertex)]]将此函数标记为顶点着色器的有效入口点。我们期望一个名为in_vertex_index的u32，它的值来自[[builtin(vertex_index)]]。</p><p>We then declare a variable called out using our VertexOutput struct. We create two other variables for the x, and y, of a triangle.</p><p>然后，我们声明一个使用VertexOutput结构调用的变量。我们为三角形创建x和y及另外两个变量。</p><div class="note"><p>The f32() and i32() bits are examples of casts.</p><p>f32()和i32()位是强制转换的示例。</p></div><div class="note"><p>Variables defined with <code>var</code> can be modified, but must specify their type. Variables created with <code>let</code> can have their types inferred, but their value cannot be changed during the shader.</p><p>可以修改用’var’定义的变量，但必须指定其类型。使用’let’创建的变量可以推断其类型，但在着色器期间不能更改其值。</p></div><p>Now we can save our clip_position to out. We then just return out and we’re done with the vertex shader!</p><p>现在我们可以将clip_position保存为out。然后我们返回，顶点着色器就完成了！</p><div class="note"><p>We technically didn’t need a struct for this example, and could have just done something like the following:</p><p>从技术上讲，本例不需要结构，只需执行以下操作即可：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[[stage(vertex)]]</span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>(</span><br><span class="line">    [[builtin(vertex_index)]] in_vertex_index: <span class="built_in">u32</span></span><br><span class="line">) -&gt; [[builtin(position)]] vec4&lt;<span class="built_in">f32</span>&gt; &#123;</span><br><span class="line">    <span class="comment">// Vertex shader code...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>We’ll be adding more fields to VertexOutput later, so we might as well start using it now.</p><p>稍后，我们将向VertexOutput添加更多字段，因此我们不妨现在就开始使用它。</p></div><p>Next up the fragment shader. Still in shader.wgsl add the follow:</p><p>接下来是片段着色器。仍在shader.wgsl中添加以下内容：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Fragment shader</span></span><br><span class="line"></span><br><span class="line">[[stage(fragment)]]</span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>(<span class="keyword">in</span>: VertexOutput) -&gt; [[location(<span class="number">0</span>)]] vec4&lt;<span class="built_in">f32</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> vec4&lt;<span class="built_in">f32</span>&gt;(<span class="number">0.3</span>, <span class="number">0.2</span>, <span class="number">0.1</span>, <span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>All this does is set the color of the current fragment to brown color.</p><p>所有这些操作都是将当前片段的颜色设置为棕色。</p><div class="note"><p>Notice that this function is also called main. Because this function is marked as a fragment shader entry point, this is ok. You can change the names around if you like, but I’ve opted to keep them the same.</p><p>请注意，此函数也称为main。因为此函数被标记为片段着色器入口点，所以这是确定的。如果你愿意的话，你可以改变名字，但我还是选择了保持不变。</p></div><p>The [[location(0)]] bit tells WGPU to store the value the vec4 returned by this function in the first color target. We’ll get into what this is later.</p><p>[[location(0)]]位告诉WGPU将此函数返回的vec4值存储在第一个颜色目标中。我们以后再谈这件事。</p><h1 id="How-do-we-use-the-shaders"><a href="#How-do-we-use-the-shaders" class="headerlink" title="How do we use the shaders?"></a>How do we use the shaders?</h1><p>This is the part where we finally make the thing in the title: the pipeline. First let’s modify State to include the following.</p><p>接着我们最终制作标题中的东西的部分：pipeline。首先，让我们修改State以包括以下内容。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main.rs</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">State</span></span> &#123;</span><br><span class="line">    surface: wgpu::Surface,</span><br><span class="line">    device: wgpu::Device,</span><br><span class="line">    queue: wgpu::Queue,</span><br><span class="line">    sc_desc: wgpu::SwapChainDescriptor,</span><br><span class="line">    swap_chain: wgpu::SwapChain,</span><br><span class="line">    size: winit::dpi::PhysicalSize&lt;<span class="built_in">u32</span>&gt;,</span><br><span class="line">    <span class="comment">// NEW!</span></span><br><span class="line">    render_pipeline: wgpu::RenderPipeline,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Now let’s move to the new() method, and start making the pipeline. We’ll have to load in those shaders we made earlier, as the render_pipeline requires those.</p><p>现在让我们转到new()方法，开始制作pipeline。我们必须加载之前制作的着色器，因为render_pipeline需要这些着色器。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> shader = device.create_shader_module(&amp;wgpu::ShaderModuleDescriptor &#123;</span><br><span class="line">    label: <span class="literal">Some</span>(<span class="string">&quot;Shader&quot;</span>),</span><br><span class="line">    flags: wgpu::ShaderFlags::all(),</span><br><span class="line">    source: wgpu::ShaderSource::Wgsl(<span class="built_in">include_str!</span>(<span class="string">&quot;shader.wgsl&quot;</span>).into()),</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>One more thing, we need to create a PipelineLayout. We’ll get more into this after we cover Buffers.</p><p>还有一件事，我们需要创建一个PipelineLayout。在我们讨论缓冲区之后，我们将进一步讨论这个问题。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> render_pipeline_layout =</span><br><span class="line">    device.create_pipeline_layout(&amp;wgpu::PipelineLayoutDescriptor &#123;</span><br><span class="line">        label: <span class="literal">Some</span>(<span class="string">&quot;Render Pipeline Layout&quot;</span>),</span><br><span class="line">        bind_group_layouts: &amp;[],</span><br><span class="line">        push_constant_ranges: &amp;[],</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure><p>Finally we have all we need to create the render_pipeline.</p><p>最后，我们有了创建render_pipeline所需的一切。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> render_pipeline = device.create_render_pipeline(&amp;wgpu::RenderPipelineDescriptor &#123;</span><br><span class="line">    label: <span class="literal">Some</span>(<span class="string">&quot;Render Pipeline&quot;</span>),</span><br><span class="line">    layout: <span class="literal">Some</span>(&amp;render_pipeline_layout),</span><br><span class="line">    vertex: wgpu::VertexState &#123;</span><br><span class="line">        module: &amp;shader,</span><br><span class="line">        entry_point: <span class="string">&quot;main&quot;</span>, <span class="comment">// 1.</span></span><br><span class="line">        buffers: &amp;[], <span class="comment">// 2.</span></span><br><span class="line">    &#125;,</span><br><span class="line">    fragment: <span class="literal">Some</span>(wgpu::FragmentState &#123; <span class="comment">// 3.</span></span><br><span class="line">        module: &amp;shader,</span><br><span class="line">        entry_point: <span class="string">&quot;main&quot;</span>,</span><br><span class="line">        targets: &amp;[wgpu::ColorTargetState &#123; <span class="comment">// 4.</span></span><br><span class="line">            format: sc_desc.format,</span><br><span class="line">            blend: <span class="literal">Some</span>(wgpu::BlendState::REPLACE),</span><br><span class="line">            write_mask: wgpu::ColorWrite::ALL,</span><br><span class="line">        &#125;],</span><br><span class="line">    &#125;),</span><br><span class="line">    <span class="comment">// continued ...</span></span><br></pre></td></tr></table></figure><p>Two things to note here:<br>这里需要注意两件事：</p><ol><li>Here you can specify which function inside of the shader should be called, which is known as the entry_point. These are the functions we marked with [[stage(vertex)]] and [[stage(fragment)]]</li><li>The buffers field tells wgpu what type of vertices we want to pass to the vertex shader. We’re specifying the vertices in the vertex shader itself so we’ll leave this empty. We’ll put something there in the next tutorial.</li><li>The fragment is technically optional, so you have to wrap it in Some(). We need it if we want to store color data to the swap_chain.</li><li>The targets field tells wgpu what color outputs it should set up.Currently we only need one for the swap_chain. We use the swap_chain’s format so that copying to it is easy, and we specify that the blending should just replace old pixel data with new data. We also tell wgpu to write to all colors: red, blue, green, and alpha. We’ll talk more aboutcolor_state when we talk about textures.</li></ol><div></div><ol><li>在这里，您可以指定应该调用着色器内部的哪个函数，该函数称为入口点。这些是我们用[[stage(vertex)]]和[[stage(fragment)]标记的函数</li><li>buffers字段告诉wgpu要传递给顶点着色器的顶点类型。我们将在顶点着色器本身中指定顶点，因此将此项留空。我们将在下一个教程中介绍一些内容。</li><li>片段着色器在技术上是可选的，因此您必须将其包装在Some()中。如果我们想将颜色数据存储到交换链，就需要它。</li><li>targets字段告诉wgpu应该设置什么颜色输出。目前，我们只需要一个用于交换链。我们使用swap_chain的格式，以便复制到它是很容易的，并且我们指定混合应该只是用新数据替换旧的像素数据。我们还告诉wgpu写入所有颜色：红色、蓝色、绿色和alpha。在讨论纹理时，我们将更多地讨论颜色状态。</li></ol><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">primitive: wgpu::PrimitiveState &#123;</span><br><span class="line">    topology: wgpu::PrimitiveTopology::TriangleList, <span class="comment">// 1.</span></span><br><span class="line">    strip_index_format: <span class="literal">None</span>,</span><br><span class="line">    front_face: wgpu::FrontFace::Ccw, <span class="comment">// 2.</span></span><br><span class="line">    cull_mode: <span class="literal">Some</span>(wgpu::Face::Back),</span><br><span class="line">    <span class="comment">// Setting this to anything other than Fill requires Features::NON_FILL_POLYGON_MODE</span></span><br><span class="line">    polygon_mode: wgpu::PolygonMode::Fill,</span><br><span class="line">    <span class="comment">// Requires Features::DEPTH_CLAMPING</span></span><br><span class="line">    clamp_depth: <span class="literal">false</span>,</span><br><span class="line">    <span class="comment">// Requires Features::CONSERVATIVE_RASTERIZATION</span></span><br><span class="line">    conservative: <span class="literal">false</span>,</span><br><span class="line">&#125;,</span><br><span class="line"><span class="comment">// continued ...</span></span><br></pre></td></tr></table></figure><p>The primitive field describes how to interpret our vertices when converting them into triangles.<br>primitive字段描述了在将顶点转换为三角形时如何解释顶点。</p><ol><li>Using PrimitiveTopology::TriangleList means that each three vertices will correspond to one triangle.</li><li>The front_face and cull_mode fields tell wgpu how to determine whether a given triangle is facing forward or not. FrontFace::Ccw means that a triangle is facing forward if the vertices are arranged in a counter clockwise direction. Triangles that are not considered facing forward are culled (not included in the render) as specified by CullMode::Back. We’ll cover culling a bit more when we cover Buffers.</li></ol><div></div><ol><li>使用PrimitiveTopology::TriangleList意味着每三个顶点对应一个三角形。</li><li>front_face和cull_mode字段告诉wgpu如何确定给定三角形是否朝前。FrontFace:：Ccw表示如果顶点按逆时针方向排列，则三角形朝前。根据CullMode:：Back的指定，将剔除（不包括在渲染中）不被视为朝前的三角形。当我们讨论缓冲区时，我们将更多地讨论剔除。</li></ol><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">    depth_stencil: <span class="literal">None</span>, <span class="comment">// 1.</span></span><br><span class="line">    multisample: wgpu::MultisampleState &#123;</span><br><span class="line">        count: <span class="number">1</span>, <span class="comment">// 2.</span></span><br><span class="line">        mask: !<span class="number">0</span>, <span class="comment">// 3.</span></span><br><span class="line">        alpha_to_coverage_enabled: <span class="literal">false</span>, <span class="comment">// 4.</span></span><br><span class="line">    &#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>The rest of the method is pretty simple:<br>该方法的其余部分非常简单：</p><ol><li>We’re not using a depth/stencil buffer currently, so we leave depth_stencil as None. This will change later.</li><li>This determines how many samples this pipeline will use. Multisampling is a complex topic, so we won’t get into it here.</li><li>sample_mask specifies which samples should be active. In this case we are using all of them.</li><li>alpha_to_coverage_enabled has to do with anti-aliasing. We’re not covering anti-aliasing here, so we’ll leave this as false now.</li></ol><div></div><ol><li>我们目前没有使用depth/stencil缓冲区，因此我们将depth/stencil保留为无。这将在以后改变。</li><li>这将确定此pipeline将使用多少个样本。多重采样是一个复杂的主题，因此我们在这里不进行讨论。</li><li>sample_mask指定哪些样本应处于活动状态。在本例中，我们使用了所有这些。</li><li>启用alpha_to_coverage_enabled与抗锯齿有关。我们这里不讨论反走样，所以现在将其保留为false。</li></ol><p>Now all we have to do is save the render_pipeline to State and then we can use it!</p><p>现在我们所要做的就是将render_pipeline保存到State，然后我们就可以使用它了！</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// new()</span></span><br><span class="line"><span class="keyword">Self</span> &#123;</span><br><span class="line">    surface,</span><br><span class="line">    device,</span><br><span class="line">    queue,</span><br><span class="line">    sc_desc,</span><br><span class="line">    swap_chain,</span><br><span class="line">    size,</span><br><span class="line">    <span class="comment">// NEW!</span></span><br><span class="line">    render_pipeline,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Using-a-pipeline"><a href="#Using-a-pipeline" class="headerlink" title="Using a pipeline"></a>Using a pipeline</h1><p>If you run your program now, it’ll take a little longer to start, but it will still show the blue screen we got in the last section. That’s because while we created the render_pipeline, we need to modify the code in render() to actually use it.</p><p>如果你现在运行你的程序，它将需要更长的时间来启动，但它仍然会显示我们在上一节中得到的蓝屏。这是因为当我们创建render_pipeline时，我们需要修改render()中的代码以实际使用它。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// render()</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 1.</span></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> render_pass = encoder.begin_render_pass(&amp;wgpu::RenderPassDescriptor &#123;</span><br><span class="line">        label: <span class="literal">Some</span>(<span class="string">&quot;Render Pass&quot;</span>),</span><br><span class="line">        color_attachments: &amp;[</span><br><span class="line">            <span class="comment">// This is what [[location(0)]] in the fragment shader targets</span></span><br><span class="line">            wgpu::RenderPassColorAttachment &#123;</span><br><span class="line">                view: &amp;frame.view,</span><br><span class="line">                resolve_target: <span class="literal">None</span>,</span><br><span class="line">                ops: wgpu::Operations &#123;</span><br><span class="line">                    load: wgpu::LoadOp::Clear(</span><br><span class="line">                        wgpu::Color &#123;</span><br><span class="line">                            r: <span class="number">0.1</span>,</span><br><span class="line">                            g: <span class="number">0.2</span>,</span><br><span class="line">                            b: <span class="number">0.3</span>,</span><br><span class="line">                            a: <span class="number">1.0</span>,</span><br><span class="line">                        &#125;</span><br><span class="line">                    ),</span><br><span class="line">                    store: <span class="literal">true</span>,</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        ],</span><br><span class="line">        depth_stencil_attachment: <span class="literal">None</span>,</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// NEW!</span></span><br><span class="line">    render_pass.set_pipeline(&amp;<span class="keyword">self</span>.render_pipeline); <span class="comment">// 2.</span></span><br><span class="line">    render_pass.draw(<span class="number">0</span>..<span class="number">3</span>, <span class="number">0</span>..<span class="number">1</span>); <span class="comment">// 3.</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure><p>We didn’t change much, but let’s talk about what we did change.<br>我们变化不大，但让我们谈谈我们改变了什么。</p><ol><li>We renamed _render_pass to render_pass and made it mutable.</li><li>We set the pipeline on the render_pass using the one we just created.</li><li>We tell wgpu to draw something with 3 vertices, and 1 instance. This is where [[builtin(vertex_index)]] comes from.</li></ol><div></div><ol><li>我们将_render_pass重命名为render_pass并使其可变。</li><li>我们将刚才创建的pipeline设置在render_pass上。</li><li>我们告诉wgpu用3个顶点和1个实例绘制一些东西。这就是[[builtin(vertex_index)]]的来源。</li></ol><p>With all that you should be seeing a lovely brown triangle.<br>所有这些，你应该看到一个可爱的棕色三角形。</p><h1 id="Challenge"><a href="#Challenge" class="headerlink" title="Challenge"></a>Challenge</h1><p>Create a second pipeline that uses the triangle’s position data to create a color that it then sends to the fragment shader. Have the app swap between these when you press the spacebar. Hint: you’ll need to modify VertexOutput</p><p>创建第二条管道，该管道使用三角形的位置数据创建颜色，然后发送到片段着色器。按空格键时，让应用程序在这两者之间切换。提示：您需要修改VertexOutput</p></div><footer class="post-footer"><div class="post-eof"></div></footer></article><article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://qianqians.github.io/2021/08/19/Wgpu%20The%20Swapchain/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.gif"><meta itemprop="name" content="qianqians"><meta itemprop="description" content=""></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="qianqians'blog"></span><header class="post-header"><h2 class="post-title" itemprop="name headline"> <a href="/2021/08/19/Wgpu%20The%20Swapchain/" class="post-title-link" itemprop="url">Wgpu The Swapchain</a></h2><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i></span> <span class="post-meta-item-text">发表于</span> <time title="创建时间：2021-08-19 16:08:20" itemprop="dateCreated datePublished" datetime="2021-08-19T16:08:20+08:00">2021-08-19</time></span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-calendar-check-o"></i></span> <span class="post-meta-item-text">更新于</span> <time title="修改时间：2021-08-20 15:16:56" itemprop="dateModified" datetime="2021-08-20T15:16:56+08:00">2021-08-20</time></span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-folder-o"></i></span> <span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Wgpu/" itemprop="url" rel="index"><span itemprop="name">Wgpu</span></a></span></span></div></header><div class="post-body" itemprop="articleBody"><h1 id="First-some-house-keeping-State"><a href="#First-some-house-keeping-State" class="headerlink" title="First, some house keeping: State"></a>First, some house keeping: State</h1><p>For convenience we’re going to pack all the fields into a struct, and create some methods on that.</p><p>为了方便起见，我们将把所有字段打包到一个结构中，并在此基础上创建一些方法。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main.rs</span></span><br><span class="line"><span class="keyword">use</span> winit::window::Window;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">State</span></span> &#123;</span><br><span class="line">    surface: wgpu::Surface,</span><br><span class="line">    device: wgpu::Device,</span><br><span class="line">    queue: wgpu::Queue,</span><br><span class="line">    sc_desc: wgpu::SwapChainDescriptor,</span><br><span class="line">    swap_chain: wgpu::SwapChain,</span><br><span class="line">    size: winit::dpi::PhysicalSize&lt;<span class="built_in">u32</span>&gt;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> State &#123;</span><br><span class="line">    <span class="comment">// Creating some of the wgpu types requires async code</span></span><br><span class="line">    <span class="keyword">async</span> <span class="function"><span class="keyword">fn</span> <span class="title">new</span></span>(window: &amp;Window) -&gt; <span class="keyword">Self</span> &#123;</span><br><span class="line">        todo!()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">resize</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, new_size: winit::dpi::PhysicalSize&lt;<span class="built_in">u32</span>&gt;) &#123;</span><br><span class="line">        todo!()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">input</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, event: &amp;WindowEvent) -&gt; <span class="built_in">bool</span> &#123;</span><br><span class="line">        todo!()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">update</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) &#123;</span><br><span class="line">        todo!()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">render</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) -&gt; <span class="built_in">Result</span>&lt;(), wgpu::SwapChainError&gt; &#123;</span><br><span class="line">        todo!()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>I’m glossing over States fields, but they’ll make more sense as I explain the code behind the methods.</p><p>我对States字段进行了润色，但当我解释方法背后的代码时，它们会更有意义。</p><h1 id="State-new"><a href="#State-new" class="headerlink" title="State::new()"></a>State::new()</h1><p>The code for this is pretty straight forward, but let’s break this down a bit.</p><p>这方面的代码非常简单，但是让我们把它分解一下。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span> State &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">async</span> <span class="function"><span class="keyword">fn</span> <span class="title">new</span></span>(window: &amp;Window) -&gt; <span class="keyword">Self</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> size = window.inner_size();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// The instance is a handle to our GPU</span></span><br><span class="line">        <span class="comment">// BackendBit::PRIMARY =&gt; Vulkan + Metal + DX12 + Browser WebGPU</span></span><br><span class="line">        <span class="keyword">let</span> instance = wgpu::Instance::new(wgpu::BackendBit::PRIMARY);</span><br><span class="line">        <span class="keyword">let</span> surface = <span class="keyword">unsafe</span> &#123; instance.create_surface(window) &#125;;</span><br><span class="line">        <span class="keyword">let</span> adapter = instance.request_adapter(</span><br><span class="line">            &amp;wgpu::RequestAdapterOptions &#123;</span><br><span class="line">                power_preference: wgpu::PowerPreference::default(),</span><br><span class="line">                compatible_surface: <span class="literal">Some</span>(&amp;surface),</span><br><span class="line">            &#125;,</span><br><span class="line">        ).<span class="keyword">await</span>.unwrap();</span><br></pre></td></tr></table></figure><p>The surface is used to create the swap_chain. Our window needs to implement raw-window-handle’s HasRawWindowHandle trait to access the native window implementation for wgpu to properly create the graphics backend. Fortunately, winit’s Window fits the bill. We also need it to request our adapter.</p><p>surface用于创建swap_chain。我们的窗口需要实现原始raw-window-handle’s HasRawWindowHandle特性，以便wgpu访问本机窗口实现，从而正确创建图形后端。幸运的是，winit的窗口符合要求。我们还需要它来请求适配器。</p><blockquote><p>The options I’ve passed to request_adapter aren’t guaranteed to work for all devices, but will work for most of them. If you want to get all adapters for a particular backend you can use enumerate_adapters. This will give you an iterator that you can loop over to check if one of the adapters works for your needs.<br>我传递给request_adapter的选项不能保证对所有设备都有效，但对大多数设备都有效。如果要获取特定后端的所有适配器，可以使用enumerate_adapters。这将为您提供一个迭代器，您可以循环检查其中一个适配器是否满足您的需要。</p></blockquote><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> adapter = instance</span><br><span class="line">   .enumerate_adapters(wgpu::BackendBit::PRIMARY)</span><br><span class="line">   .filter(|adapter| &#123;</span><br><span class="line">       <span class="comment">// Check if this adapter supports our surface</span></span><br><span class="line">       adapter.get_swap_chain_preferred_format(&amp;surface).is_some()</span><br><span class="line">   &#125;)</span><br><span class="line">   .first()</span><br><span class="line">   .unwrap()</span><br></pre></td></tr></table></figure><blockquote><p>For more fields you can use to refine you’re search check out the docs.<br>有关可用于优化搜索的更多字段，<a target="_blank" rel="noopener" href="https://docs.rs/wgpu/0.9.0/wgpu/struct.Adapter.html">请查看文档</a></p></blockquote><p>We need the adapter to create the device and queue.<br>我们需要适配器来创建设备和队列。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> (device, queue) = adapter.request_device(</span><br><span class="line">    &amp;wgpu::DeviceDescriptor &#123;</span><br><span class="line">        features: wgpu::Features::empty(),</span><br><span class="line">        limits: wgpu::Limits::default(),</span><br><span class="line">        label: <span class="literal">None</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="literal">None</span>, <span class="comment">// Trace path</span></span><br><span class="line">).<span class="keyword">await</span>.unwrap();</span><br></pre></td></tr></table></figure><p>The features field on DeviceDescriptor, allows us to specify what extra features we want. For this simple example, I’ve decided not to use any extra features.<br>DeviceDescriptor上的features字段允许我们指定所需的额外功能。对于这个简单的例子，我决定不使用任何额外的特性。</p><blockquote><p>The device you have limits the features you can use. If you want to use certain features you may need to limit what devices you support, or provide work arounds.<br>You can get a list of features supported by your device using adapter.features(), or device.features().<br>You can view a full list of features here.</p></blockquote><blockquote><p>您拥有的设备限制了您可以使用的功能。如果您想使用某些功能，您可能需要限制您支持的设备，或提供解决方案。<br>您可以使用adapter.features（）或device.features（）获取设备支持的功能列表。<br>您可以在此处查看功能的<a target="_blank" rel="noopener" href="https://docs.rs/wgpu/0.9.0/wgpu/struct.Features.html">完整列表</a>。</p></blockquote><p>The limits field describes the limit of certain types of resource we can create. We’ll use the defaults for this tutorial, so we can support most devices. You can view a list of limits here.</p><p>limits字段描述了我们可以创建的特定类型资源的限制。本教程将使用默认设置，因此我们可以支持大多数设备。您可以在此处查看<a target="_blank" rel="noopener" href="https://docs.rs/wgpu/0.9.0/wgpu/struct.Limits.html">limits列表</a>。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> sc_desc = wgpu::SwapChainDescriptor &#123;</span><br><span class="line">    usage: wgpu::TextureUsage::RENDER_ATTACHMENT,</span><br><span class="line">    format: adapter.get_swap_chain_preferred_format(&amp;surface).unwrap(),</span><br><span class="line">    width: size.width,</span><br><span class="line">    height: size.height,</span><br><span class="line">    present_mode: wgpu::PresentMode::Fifo,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> swap_chain = device.create_swap_chain(&amp;surface, &amp;sc_desc);</span><br></pre></td></tr></table></figure><p>Here we are defining and creating the swap_chain. The usage field describes how the swap_chain’s underlying textures will be used. RENDER_ATTACHMENT specifies that the textures will be used to write to the screen (we’ll talk about more TextureUsages later).</p><p>这里我们定义并创建swap_chain。usage字段描述如何使用swap_chain的基础纹理。RENDER_ATTACHMENT指定纹理将用于写入屏幕（稍后我们将讨论更多纹理图像）。</p><p>The format defines how the swap_chains textures will be stored on the gpu. Different displays prefer different formats. We use adapter.get_swap_chain_preferred_format() to figure out the best format to use.</p><p>该格式定义如何将swap_chains纹理存储在gpu上。不同的显示器喜欢不同的格式。我们使用adapter.get_swap_chain_preferred_format()来找出最佳的使用格式。</p><p>width and height, are the width and height in pixels of the swap chain. This should usually be the width and height of the window.</p><p>宽度和高度是swap_chain的宽度和高度(以像素为单位)。这通常应该是窗口的宽度和高度。</p><p>The present_mode uses the wgpu::PresentMode enum which determines how to sync the swap chain with the display. You can see all the options in the docs</p><p>当前模式使用wgpu::PresentMode枚举，该枚举确定如何将swap_chain与显示同步。您可以在文档中看到<a target="_blank" rel="noopener" href="https://docs.rs/wgpu/0.9.0/wgpu/enum.PresentMode.html">所有选项</a></p><p>At the end of the method, we simply return the resulting struct.</p><p>在方法的末尾，我们只返回结构体结果。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">        <span class="keyword">Self</span> &#123;</span><br><span class="line">            surface,</span><br><span class="line">            device,</span><br><span class="line">            queue,</span><br><span class="line">            sc_desc,</span><br><span class="line">            swap_chain,</span><br><span class="line">            size,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>We’ll want to call this in our main method before we enter the event loop.</p><p>在进入事件循环之前，我们希望在main方法中调用它。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Since main can&#x27;t be async, we&#x27;re going to need to block</span></span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut</span> state = pollster::block_on(State::new(&amp;window));</span><br></pre></td></tr></table></figure><blockquote><p>You can use heavier libraries like async_std and tokio to make main async, so you can await futures. I’ve elected not to use these crates as this tutorial is not about writing an async application, and the futures created by wgpu do not require special executor support. We just need some way to interact with wgpu’s async functions, and the pollster crate is enough for that.</p></blockquote><blockquote><p>您可以使用较重的库（如async_std和tokio）来实现main函数异步，因此您可以等待futures。我选择不使用这些crates，因为本教程不是关于编写异步应用程序的，而且wgpu创建的crates不需要特殊的执行器支持。我们只需要一些与wgpu的异步函数交互的方法，the pollster crate就足够了。</p></blockquote><h1 id="resize"><a href="#resize" class="headerlink" title="resize()"></a>resize()</h1><p>If we want to support resizing in our application, we’re going to need to recreate the swap_chain everytime the window’s size changes. That’s the reason we stored the physical size and the sc_desc used to create the swapchain. With all of these, the resize method is very simple.</p><p>如果我们想在应用程序中支持调整大小，我们需要在每次窗口大小更改时重新创建swap_chain。这就是我们存储用于创建swap_chain的物理大小和sc_desc的原因。有了所有这些，调整大小的方法非常简单。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// impl State</span></span><br><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">resize</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, new_size: winit::dpi::PhysicalSize&lt;<span class="built_in">u32</span>&gt;) &#123;</span><br><span class="line">    <span class="keyword">if</span> new_size.width &gt; <span class="number">0</span> &amp;&amp; new_size.height &gt; <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.size = new_size;</span><br><span class="line">        <span class="keyword">self</span>.sc_desc.width = new_size.width;</span><br><span class="line">        <span class="keyword">self</span>.sc_desc.height = new_size.height;</span><br><span class="line">        <span class="keyword">self</span>.swap_chain = <span class="keyword">self</span>.device.create_swap_chain(&amp;<span class="keyword">self</span>.surface, &amp;<span class="keyword">self</span>.sc_desc);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>There’s nothing really different here from creating the swap_chain initially, so I won’t get into it.</p><p>这里与最初创建swap_chain没有什么不同，所以我就不谈了。</p><p>We call this method in main() in the event loop for the following events.</p><p>对于以下事件，我们在main函数的事件循环的中调用此方法。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">match</span> event &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">if</span> window_id == window.id() =&gt; <span class="keyword">if</span> !state.input(event) &#123;</span><br><span class="line">        <span class="keyword">match</span> event &#123;</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">            WindowEvent::Resized(physical_size) =&gt; &#123;</span><br><span class="line">                state.resize(*physical_size);</span><br><span class="line">            &#125;</span><br><span class="line">            WindowEvent::ScaleFactorChanged &#123; new_inner_size, .. &#125; =&gt; &#123;</span><br><span class="line">                <span class="comment">// new_inner_size is &amp;&amp;mut so we have to dereference it twice</span></span><br><span class="line">                state.resize(**new_inner_size);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="input"><a href="#input" class="headerlink" title="input()"></a>input()</h1><p>input() returns a bool to indicate whether an event has been fully processed. If the method returns true, the main loop won’t process the event any further.</p><p>input函数返回一个bool以指示事件是否已被完全处理。如果该方法返回true，则主循环将不再进一步处理该事件。</p><p>We’re just going to return false for now because we don’t have any events we want to capture.</p><p>我们现在只返回false，因为我们没有任何要捕获的事件。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// impl State</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">input</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, event: &amp;WindowEvent) -&gt; <span class="built_in">bool</span> &#123;</span><br><span class="line">    <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>We need to do a little more work in the event loop. We want State to have priority over main(). Doing that (and previous changes) should have your loop looking like this.</p><p>我们需要在事件循环中做更多的工作。我们希望State优先于main（）。这样做（以及之前的更改）应该使循环看起来像这样。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main()</span></span><br><span class="line">event_loop.run(<span class="keyword">move</span> |event, _, control_flow| &#123;</span><br><span class="line">    <span class="keyword">match</span> event &#123;</span><br><span class="line">        Event::WindowEvent &#123;</span><br><span class="line">            <span class="keyword">ref</span> event,</span><br><span class="line">            window_id,</span><br><span class="line">        &#125; <span class="keyword">if</span> window_id == window.id() =&gt; <span class="keyword">if</span> !state.input(event) &#123; <span class="comment">// UPDATED!</span></span><br><span class="line">            <span class="keyword">match</span> event &#123;</span><br><span class="line">                WindowEvent::CloseRequested</span><br><span class="line">                | WindowEvent::KeyboardInput &#123;</span><br><span class="line">                    input:</span><br><span class="line">                        KeyboardInput &#123;</span><br><span class="line">                            state: ElementState::Pressed,</span><br><span class="line">                            virtual_keycode: <span class="literal">Some</span>(VirtualKeyCode::Escape),</span><br><span class="line">                            ..</span><br><span class="line">                        &#125;,</span><br><span class="line">                    ..</span><br><span class="line">                &#125; =&gt; *control_flow = ControlFlow::Exit,</span><br><span class="line">                WindowEvent::Resized(physical_size) =&gt; &#123;</span><br><span class="line">                    state.resize(*physical_size);</span><br><span class="line">                &#125;</span><br><span class="line">                WindowEvent::ScaleFactorChanged &#123; new_inner_size, .. &#125; =&gt; &#123;</span><br><span class="line">                    state.resize(**new_inner_size);</span><br><span class="line">                &#125;</span><br><span class="line">                _ =&gt; &#123;&#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        _ =&gt; &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h1 id="update"><a href="#update" class="headerlink" title="update()"></a>update()</h1><p>We don’t have anything to update yet, so leave the method empty.</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">update</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) &#123;</span><br><span class="line">    <span class="comment">// remove `todo!()`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="render"><a href="#render" class="headerlink" title="render()"></a>render()</h1><p>Here’s where the magic happens. First we need to get a frame to render to. This will include a wgpu::Texture and wgpu::TextureView that will hold the actual image we’re drawing to (we’ll cover this more when we talk about textures).</p><p>这就是魔法发生的地方。首先，我们需要得到一个帧来渲染。这将包括wgpu:：Texture和wgpu:：TextureView，它们将保存我们正在绘制的实际图像（我们将在讨论纹理时详细介绍这一点）。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// impl State</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">render</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) -&gt; <span class="built_in">Result</span>&lt;(), wgpu::SwapChainError&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> frame = <span class="keyword">self</span></span><br><span class="line">        .swap_chain</span><br><span class="line">        .get_current_frame()?</span><br><span class="line">        .output;</span><br></pre></td></tr></table></figure><p>We also need to create a CommandEncoder to create the actual commands to send to the gpu. Most modern graphics frameworks expect commands to be stored in a command buffer before being sent to the gpu. The encoder builds a command buffer that we can then send to the gpu.</p><p>我们还需要创建CommandEncoder来创建发送到gpu的实际命令。大多数现代图形框架都希望命令在发送到gpu之前存储在命令缓冲区中。编码器构建一个命令缓冲区，然后我们可以将其发送到gpu。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut</span> encoder = <span class="keyword">self</span>.device.create_command_encoder(&amp;wgpu::CommandEncoderDescriptor &#123;</span><br><span class="line">    label: <span class="literal">Some</span>(<span class="string">&quot;Render Encoder&quot;</span>),</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>Now we can actually get to clearing the screen (long time coming). We need to use the encoder to create a RenderPass. The RenderPass has all the methods to do the actual drawing. The code for creating a RenderPass is a bit nested, so I’ll copy it all here, and talk about the pieces.</p><p>现在我们可以开始清理屏幕了（很长一段时间就要到了）。我们需要使用编码器来创建一个RenderPass。RenderPass具有进行实际绘制的所有方法。创建RenderPass的代码有点嵌套，所以我将在这里全部复制，并讨论各个部分。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">let</span> _render_pass = encoder.begin_render_pass(&amp;wgpu::RenderPassDescriptor &#123;</span><br><span class="line">            label: <span class="literal">Some</span>(<span class="string">&quot;Render Pass&quot;</span>),</span><br><span class="line">            color_attachments: &amp;[</span><br><span class="line">                wgpu::RenderPassColorAttachment &#123;</span><br><span class="line">                    view: &amp;frame.view,</span><br><span class="line">                    resolve_target: <span class="literal">None</span>,</span><br><span class="line">                    ops: wgpu::Operations &#123;</span><br><span class="line">                        load: wgpu::LoadOp::Clear(wgpu::Color &#123;</span><br><span class="line">                            r: <span class="number">0.1</span>,</span><br><span class="line">                            g: <span class="number">0.2</span>,</span><br><span class="line">                            b: <span class="number">0.3</span>,</span><br><span class="line">                            a: <span class="number">1.0</span>,</span><br><span class="line">                        &#125;),</span><br><span class="line">                        store: <span class="literal">true</span>,</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            ],</span><br><span class="line">            depth_stencil_attachment: <span class="literal">None</span>,</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// submit will accept anything that implements IntoIter</span></span><br><span class="line">    <span class="keyword">self</span>.queue.submit(std::iter::once(encoder.finish()));</span><br><span class="line"></span><br><span class="line">    <span class="literal">Ok</span>(())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>First things first, let’s talk about the {}. encoder.begin_render_pass(…) borrows encoder mutably (aka &amp;mut self). We can’t call encoder.finish() until we release that mutable borrow. The {} around encoder.begin_render_pass(…) tells rust to drop any variables within them when the code leaves that scope thus releasing the mutable borrow on encoder and allowing us to finish() it. If you don’t like the {}, you can also use drop(render_pass) to achieve the same effect.</p><p>首先，让我们先谈谈{}包括的代码。 encoder.begin_render_pass(…)使encoder可变(aka &amp;mut self)。在释放该可变借用之前，我们无法调用encoder.finish()。使用{}包括encoder.begin_render_pass(…)告诉rust在代码离开该范围时删除其中的任何变量，从而释放借用的可变编码器，并允许我们完成它。如果不喜欢{}，也可以使用drop(render_pass)来实现相同的效果。</p><p>We can get the same results by removing the {}, and the let _render_pass = line, but we need access to the _render_pass in the next tutorial, so we’ll leave it as is.</p><p>我们可以通过删除{}和let _render_pass=line来获得相同的结果，但是我们需要在下一个教程中访问_render_pass，所以我们将保持原样。</p><p>The last lines of the code tell wgpu to finish the command buffer, and to submit it to the gpu’s render queue.</p><p>代码的最后几行告诉wgpu完成命令缓冲区，并将其提交到gpu的渲染队列。</p><p>We need to update the event loop again to call this method. We’ll also call update before it too.</p><p>我们需要再次更新事件循环以调用此方法。我们也会在更新之前调用update。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main()</span></span><br><span class="line">event_loop.run(<span class="keyword">move</span> |event, _, control_flow| &#123;</span><br><span class="line">    <span class="keyword">match</span> event &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        Event::RedrawRequested(_) =&gt; &#123;</span><br><span class="line">            state.update();</span><br><span class="line">            <span class="keyword">match</span> state.render() &#123;</span><br><span class="line">                <span class="literal">Ok</span>(_) =&gt; &#123;&#125;</span><br><span class="line">                <span class="comment">// Recreate the swap_chain if lost</span></span><br><span class="line">                <span class="literal">Err</span>(wgpu::SwapChainError::Lost) =&gt; state.resize(state.size),</span><br><span class="line">                <span class="comment">// The system is out of memory, we should probably quit</span></span><br><span class="line">                <span class="literal">Err</span>(wgpu::SwapChainError::OutOfMemory) =&gt; *control_flow = ControlFlow::Exit,</span><br><span class="line">                <span class="comment">// All other errors (Outdated, Timeout) should be resolved by the next frame</span></span><br><span class="line">                <span class="literal">Err</span>(e) =&gt; eprintln!(<span class="string">&quot;&#123;:?&#125;&quot;</span>, e),</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        Event::MainEventsCleared =&gt; &#123;</span><br><span class="line">            <span class="comment">// RedrawRequested will only trigger once, unless we manually</span></span><br><span class="line">            <span class="comment">// request it.</span></span><br><span class="line">            window.request_redraw();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h1 id="Wait-what’s-going-on-with-RenderPassDescriptor"><a href="#Wait-what’s-going-on-with-RenderPassDescriptor" class="headerlink" title="Wait, what’s going on with RenderPassDescriptor?"></a>Wait, what’s going on with RenderPassDescriptor?</h1><p>Some of you may be able to tell what’s going on just by looking at it, but I’d be remiss if I didn’t go over it. Let’s take a look at the code again.</p><p>你们中的一些人可能仅仅通过看它就能知道发生了什么，但如果我不仔细看一下，那我就是失职了。让我们再看一遍代码。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&amp;wgpu::RenderPassDescriptor &#123;</span><br><span class="line">    label: <span class="literal">Some</span>(<span class="string">&quot;Render Pass&quot;</span>),</span><br><span class="line">    color_attachments: &amp;[</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    ],</span><br><span class="line">    depth_stencil_attachment: <span class="literal">None</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>A RenderPassDescriptor only has three fields: label, color_attachments and depth_stencil_attachment. The color_attachements describe where we are going to draw our color to. We’ll use depth_stencil_attachment later, but we’ll set it to None for now.</p><p>RenderPassDescriptor只有三个字段：label、color_attachments和depth_stencil_attachment。color_attachments描述了我们将在何处绘制颜色。稍后我们将使用depth_stencil_attachment，但现在将其设置为None。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">wgpu::RenderPassColorAttachment &#123;</span><br><span class="line">    view: &amp;frame.view,</span><br><span class="line">    resolve_target: <span class="literal">None</span>,</span><br><span class="line">    ops: wgpu::Operations &#123;</span><br><span class="line">        load: wgpu::LoadOp::Clear(wgpu::Color &#123;</span><br><span class="line">            r: <span class="number">0.1</span>,</span><br><span class="line">            g: <span class="number">0.2</span>,</span><br><span class="line">            b: <span class="number">0.3</span>,</span><br><span class="line">            a: <span class="number">1.0</span>,</span><br><span class="line">        &#125;),</span><br><span class="line">        store: <span class="literal">true</span>,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>The RenderPassColorAttachment has the view field which informs wgpu what texture to save the colors to. In this case we specify frame.view that we created using swap_chain.get_current_frame(). This means that any colors we draw to this attachment will get drawn to the screen.</p><p>RenderPassColorAttachment有一个视图字段，用于通知wgpu要保存颜色的纹理。在本例中，我们指定使用swap_chain.get_current_frame()创建的frame.view。这意味着我们在此附件中绘制的任何颜色都将被绘制到屏幕上。</p><p>The resolve_target is the texture that will receive the resolved output. This will be the same as attachment unless multisampling is enabled. We don’t need to specify this, so we leave it as None.</p><p>resolve_target是将接收解析输出的纹理。除非启用了多重采样，否则这将与attachment相同。我们不需要指定它，所以我们将其保留为None。</p><p>The ops field takes a wpgu::Operations object. This tells wgpu what to do with the colors on the screen (specified by frame.view). The load field tells wgpu how to handle colors stored from the previous frame. Currently we are clearing the screen with a bluish color.</p><p>ops字段接受一个wpgu::Operations对象。这告诉wgpu如何处理屏幕上的颜色(由frame.view指定)。load字段告诉wgpu如何处理从上一帧存储的颜色。目前，我们正在清除带有蓝色的屏幕。</p><h1 id="Challenge"><a href="#Challenge" class="headerlink" title="Challenge"></a>Challenge</h1><p>Modify the input() method to capture mouse events, and update the clear color using that. Hint: you’ll probably need to use WindowEvent::CursorMoved.</p><p>修改input()方法以捕获鼠标事件，并使用该方法更新清除颜色。提示：您可能需要使用WindowEvent::CursorMoved。</p><p><a target="_blank" rel="noopener" href="https://github.com/sotrh/learn-wgpu/tree/master/code/beginner/tutorial2-swapchain/">Check out the code!</a></p></div><footer class="post-footer"><div class="post-eof"></div></footer></article><article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://qianqians.github.io/2021/08/17/WebGPU%203.4.2.%20Memory%20Model/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.gif"><meta itemprop="name" content="qianqians"><meta itemprop="description" content=""></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="qianqians'blog"></span><header class="post-header"><h2 class="post-title" itemprop="name headline"> <a href="/2021/08/17/WebGPU%203.4.2.%20Memory%20Model/" class="post-title-link" itemprop="url">WebGPU 3.4.2. Memory Model</a></h2><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i></span> <span class="post-meta-item-text">发表于</span> <time title="创建时间：2021-08-17 16:53:49 / 修改时间：17:25:58" itemprop="dateCreated datePublished" datetime="2021-08-17T16:53:49+08:00">2021-08-17</time></span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-folder-o"></i></span> <span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/WebGPU/" itemprop="url" rel="index"><span itemprop="name">WebGPU</span></a></span></span></div></header><div class="post-body" itemprop="articleBody"><p>Once a GPUDevice has been obtained during an application initialization routine, we can describe the WebGPU platform as consisting of the following layers:</p><ol><li>User agent implementing the specification.</li><li>Operating system with low-level native API drivers for this device.</li><li>Actual CPU and GPU hardware.</li></ol><p>在应用程序初始化例程中获得GPU设备后，我们可以将WebGPU平台描述为由以下层组成:</p><ol><li>实现规范的用户代理。</li><li>此设备具有低级本机API驱动的操作系统。</li><li>实际的CPU和GPU硬件。</li></ol><p>Each layer of the WebGPU platform may have different memory types that the user agent needs to consider when implementing the specification:</p><ul><li>The script-owned memory, such as an ArrayBuffer created by the script, is generally not accessible by a GPU driver.</li><li>A user agent may have different processes responsible for running the content and communication to the GPU driver. In this case, it uses inter-process shared memory to transfer data.</li><li>Dedicated GPUs have their own memory with high bandwidth, while integrated GPUs typically share memory with the system.</li></ul><p>WebGPU平台的每一层可能有不同的内存类型，用户代理在执行规范时需要考虑:</p><ul><li>脚本拥有的内存（如脚本创建的ArrayBuffer）通常不可由GPU驱动程序访问。</li><li>用户代理可以具有负责运行内容和与GPU驱动程序通信的不同进程。在这种情况下，它使用进程间共享内存来传输数据。</li><li>专用GPU拥有自己的高带宽内存，而集成GPU通常与系统共享内存。</li></ul><p>Most physical resources are allocated in the memory of type that is efficient for computation or rendering by the GPU. When the user needs to provide new data to the GPU, the data may first need to cross the process boundary in order to reach the user agent part that communicates with the GPU driver. Then it may need to be made visible to the driver, which sometimes requires a copy into driver-allocated staging memory. Finally, it may need to be transferred to the dedicated GPU memory, potentially changing the internal layout into one that is most efficient for GPUs to operate on.</p><p>大多数物理资源都分配在GPU高效计算或渲染的内存中。当用户需要向GPU提供新数据时，数据可能首先需要跨越进程边界以到达与GPU驱动程序通信的用户代理部分。然后可能需要使其对驱动程序可见，这有时需要将副本复制到驱动程序分配的暂存内存中。最后，可能需要将其传输到专用GPU内存，从而可能会将内部布局更改为GPU操作最有效的布局。</p><p>All of these transitions are done by the WebGPU implementation of the user agent.</p><p>所有这些转换都由用户代理的WebGPU实现完成。</p><blockquote><p>Note: This example describes the worst case, while in practice the implementation may not need to cross the process boundary, or may be able to expose the driver-managed memory directly to the user behind an ArrayBuffer, thus avoiding any data copies.</p></blockquote><blockquote><p>注: 本例描述了最坏的情况，而实际上实现可能不需要跨越进程边界，或者可能能够将驱动程序管理的内存直接暴露给ArrayBuffer后面的用户，从而避免任何数据拷贝。</p></blockquote></div><footer class="post-footer"><div class="post-eof"></div></footer></article><article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://qianqians.github.io/2021/08/13/WebGPU%203.4.1.%20Timelines/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.gif"><meta itemprop="name" content="qianqians"><meta itemprop="description" content=""></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="qianqians'blog"></span><header class="post-header"><h2 class="post-title" itemprop="name headline"> <a href="/2021/08/13/WebGPU%203.4.1.%20Timelines/" class="post-title-link" itemprop="url">WebGPU 3.4.1. Timelines</a></h2><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i></span> <span class="post-meta-item-text">发表于</span> <time title="创建时间：2021-08-13 15:10:14" itemprop="dateCreated datePublished" datetime="2021-08-13T15:10:14+08:00">2021-08-13</time></span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-calendar-check-o"></i></span> <span class="post-meta-item-text">更新于</span> <time title="修改时间：2021-08-17 16:45:14" itemprop="dateModified" datetime="2021-08-17T16:45:14+08:00">2021-08-17</time></span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-folder-o"></i></span> <span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/WebGPU/" itemprop="url" rel="index"><span itemprop="name">WebGPU</span></a></span></span></div></header><div class="post-body" itemprop="articleBody"><p>A computer system with a user agent at the front-end and GPU at the back-end has components working on different timelines in parallel:</p><p>Content timeline<br>Associated with the execution of the Web script. It includes calling all methods described by this specification.<br>Steps executed on the content timeline look like this.</p><p>Device timeline<br>Associated with the GPU device operations that are issued by the user agent. It includes creation of adapters, devices, and GPU resources and state objects, which are typically synchronous operations from the point of view of the user agent part that controls the GPU, but can live in a separate OS process.<br>Steps executed on the device timeline look like this.</p><p>Queue timeline<br>Associated with the execution of operations on the compute units of the GPU. It includes actual draw, copy, and compute jobs that run on the GPU.<br>Steps executed on the queue timeline look like this.</p><p>一个前端有用户代理，后端有GPU的计算机系统的组件在不同的时间线上并行工作：</p><p>内容时间轴<br>与Web脚本的执行关联。它包括调用本规范描述的所有方法。<br>在内容时间轴上执行的步骤如下所示。</p><p>设备时间轴<br>与用户代理发出的GPU设备操作关联。它包括创建适配器、设备、GPU资源和状态对象，从控制GPU的用户代理部分的角度来看，这些通常是同步操作，并且可以存在于单独的操作系统进程中。<br>在设备时间轴上执行的步骤如下所示。</p><p>队列时间轴<br>与在GPU的计算单元上执行操作有关。它包括在GPU上运行的实际绘制、复制和计算作业。<br>在队列时间轴上执行的步骤如下所示。</p><p>In this specification, asynchronous operations are used when the result value depends on work that happens on any timeline other than the Content timeline. They are represented by callbacks and promises in JavaScript.</p><p>在本规范中，当结果值取决于除内容时间线以外的任何时间线上发生的工作时，将使用异步操作。它们由JavaScript中的回调和promises表示。</p><blockquote><p>EXAMPLE 1<br>GPUComputePassEncoder.dispatch():</p><blockquote><ol><li>User encodes a dispatch command by calling a method of the GPUComputePassEncoder which happens on the Content timeline.</li><li>User issues GPUQueue.submit() that hands over the GPUCommandBuffer to the user agent, which processes it on the Device timeline by calling the OS driver to do a low-level submission.</li><li>The submit gets dispatched by the GPU invocation scheduler onto the actual compute units for execution, which happens on the Queue timeline.</li></ol></blockquote><blockquote><ol><li>用户通过调用发生在内容时间轴上的GPUComputePassEncoder方法对调度命令进行编码。</li><li>用户发出GPUQueue.submit()，将GPUCommandBuffer移交给用户代理，用户代理通过调用操作系统驱动程序进行低级提交，在设备时间轴上对其进行处理。</li><li>提交由GPU调用调度器调度到实际的计算单元上执行，这发生在队列时间线上。</li></ol></blockquote></blockquote><blockquote><p>EXAMPLE 2<br>GPUDevice.createBuffer():</p><blockquote><ol><li>User fills out a GPUBufferDescriptor and creates a GPUBuffer with it, which happens on the Content timeline.</li><li>User agent creates a low-level buffer on the Device timeline.</li></ol></blockquote><blockquote><ol><li>用户填写一个GPUBufferDescriptor并用它创建一个GPUBuffer，这发生在内容时间轴上。</li><li>用户代理在设备时间轴上创建低级缓冲区。</li></ol></blockquote></blockquote><blockquote><p>EXAMPLE 3<br>GPUBuffer.mapAsync():</p><blockquote><ol><li>User requests to map a GPUBuffer on the Content timeline and gets a promise in return.</li><li>User agent checks if the buffer is currently used by the GPU and makes a reminder to itself to check back when this usage is over.</li><li>After the GPU operating on Queue timeline is done using the buffer, the user agent maps it to memory and resolves the promise.</li></ol></blockquote><blockquote><ol><li>用户请求将GPUBuffer映射到内容时间轴上，并得到一个promise作为返回值。</li><li>用户代理检查缓冲区当前是否由GPU使用，并提醒自己在使用结束时检查。</li><li>在GPU使用缓冲区对队列时间轴进行操作之后，用户代理将其映射到内存并resolves the promise。</li></ol></blockquote></blockquote></div><footer class="post-footer"><div class="post-eof"></div></footer></article><article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://qianqians.github.io/2021/08/13/WebGPU%203.3.%20Coordinate%20Systems/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.gif"><meta itemprop="name" content="qianqians"><meta itemprop="description" content=""></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="qianqians'blog"></span><header class="post-header"><h2 class="post-title" itemprop="name headline"> <a href="/2021/08/13/WebGPU%203.3.%20Coordinate%20Systems/" class="post-title-link" itemprop="url">WebGPU 3.3. Coordinate Systems</a></h2><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i></span> <span class="post-meta-item-text">发表于</span> <time title="创建时间：2021-08-13 11:52:13 / 修改时间：14:49:34" itemprop="dateCreated datePublished" datetime="2021-08-13T11:52:13+08:00">2021-08-13</time></span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-folder-o"></i></span> <span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/WebGPU/" itemprop="url" rel="index"><span itemprop="name">WebGPU</span></a></span></span></div></header><div class="post-body" itemprop="articleBody"><ul><li><p>Y-axis is up in normalized device coordinate (NDC): point(-1.0, -1.0) in NDC is located at the bottom-left corner of NDC. In addition, x and y in NDC should be between -1.0 and 1.0 inclusive, while z in NDC should be between 0.0 and 1.0 inclusive. Vertices out of this range in NDC will not introduce any errors, but they will be clipped.</p></li><li><p>Y-axis is down in framebuffer coordinate, viewport coordinate and fragment/pixel coordinate: origin(0, 0) is located at the top-left corner in these coordinate systems.</p></li><li><p>Window/present coordinate matches framebuffer coordinate.</p></li><li><p>UV of origin(0, 0) in texture coordinate represents the first texel (the lowest byte) in texture memory.</p></li><li><p>Y轴在归一化设备坐标（NDC）中向上：NDC中的点（-1.0，-1.0）位于NDC的左下角。此外，NDC中的x和y应介于-1.0和1.0之间，而NDC中的z应介于0.0和1.0之间。NDC中超出此范围的顶点不会引入任何错误，但它们将被剪裁。</p></li><li><p>Y轴在帧缓冲区坐标、视口坐标和片段/像素坐标中向下：原点（0，0）位于这些坐标系的左上角。</p></li><li><p>窗口/当前坐标与帧缓冲区坐标匹配。</p></li><li><p>纹理坐标中的UV原点（0,0）表示纹理内存中的第一个texel（最低字节）。</p></li></ul><p>Note: WebGPU’s coordinate systems match DirectX and Metal’s coordinate systems in a graphics pipeline.</p><p>注：WebGPU的坐标系在图形管道中与DirectX和Metal的坐标系匹配。</p></div><footer class="post-footer"><div class="post-eof"></div></footer></article><article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://qianqians.github.io/2021/08/10/WebGPU%203.2.%20Invalid%20Internal%20Objects%20&%20Contagious%20Invalidity/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.gif"><meta itemprop="name" content="qianqians"><meta itemprop="description" content=""></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="qianqians'blog"></span><header class="post-header"><h2 class="post-title" itemprop="name headline"> <a href="/2021/08/10/WebGPU%203.2.%20Invalid%20Internal%20Objects%20&%20Contagious%20Invalidity/" class="post-title-link" itemprop="url">WebGPU 3.2. Invalid Internal Objects & Contagious Invalidity</a></h2><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i></span> <span class="post-meta-item-text">发表于</span> <time title="创建时间：2021-08-10 14:46:03 / 修改时间：15:29:14" itemprop="dateCreated datePublished" datetime="2021-08-10T14:46:03+08:00">2021-08-10</time></span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-folder-o"></i></span> <span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/WebGPU/" itemprop="url" rel="index"><span itemprop="name">WebGPU</span></a></span></span></div></header><div class="post-body" itemprop="articleBody"><p>If an object is successfully created, it is valid at that moment. An internal object may be invalid. It may become invalid during its lifetime, but it will never become valid again.</p><p>如果成功创建了一个对象，则该对象此时有效。内部对象可能无效。它可能在其生命周期内失效，并且永远不会再次生效。</p><p>Invalid objects result from a number of situations, including:<br>&nbsp;If there is an error in the creation of an object, it is immediately invalid. This can happen, for example, if the object descriptor doesn’t describe a valid object, or if there is not enough memory to allocate a resource.<br>&nbsp;If an object is explicitly destroyed (e.g. GPUBuffer.destroy()), it becomes invalid.<br>&nbsp;If the device that owns an object is lost, the object becomes invalid.</p><p>无效对象由多种情况造成，包括：<br>&nbsp;如果在创建对象时出错，则该对象立即无效。例如，如果对象描述符没有描述有效的对象，或者没有足够的内存来分配资源，就会发生这种情况。<br>&nbsp;如果对象被显式销毁(例如GPUBuffer.destroy())，则该对象将无效。<br>&nbsp;如果拥有对象的设备丢失，该对象将无效。</p><p>To determine if a given GPUObjectBase object is valid to use with a targetObject, run the following steps:<br>&nbsp;1.If any of the following conditions are unsatisfied return false:<br>&nbsp;&nbsp;object is valid<br>&nbsp;&nbsp;object.[[device]] is valid.<br>&nbsp;&nbsp;object.[[device]] is targetObject.[[device]].<br>&nbsp;2.Return true.</p><p>要确定给定的GPUObjectBase对象是否可与targetObject一起使用，请运行以下步骤：<br>&nbsp;1.如果以下任一条件不满足，则返回false：<br>&nbsp;&nbsp;对象是有效的<br>&nbsp;&nbsp;object.[[device]]是有效的<br>&nbsp;&nbsp;object.[[device]]是targetObject.[[device]].<br>&nbsp;2.返回true.</p></div><footer class="post-footer"><div class="post-eof"></div></footer></article><article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://qianqians.github.io/2021/08/10/WebGPU%203.1.%20Conventions/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.gif"><meta itemprop="name" content="qianqians"><meta itemprop="description" content=""></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="qianqians'blog"></span><header class="post-header"><h2 class="post-title" itemprop="name headline"> <a href="/2021/08/10/WebGPU%203.1.%20Conventions/" class="post-title-link" itemprop="url">WebGPU 3.1. Conventions</a></h2><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i></span> <span class="post-meta-item-text">发表于</span> <time title="创建时间：2021-08-10 10:24:11 / 修改时间：11:35:30" itemprop="dateCreated datePublished" datetime="2021-08-10T10:24:11+08:00">2021-08-10</time></span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-folder-o"></i></span> <span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/WebGPU/" itemprop="url" rel="index"><span itemprop="name">WebGPU</span></a></span></span></div></header><div class="post-body" itemprop="articleBody"><p>3.1.1. Dot Syntax</p><p>In this specification, the . (“dot”) syntax, common in programming languages, is used. The phrasing “Foo.Bar” means “the Bar member of the value (or interface) Foo.”</p><p>在本规范中，使用编程语言中常见的(“点”)语法。短语”Foo.Bar”表示”对象(或接口)Foo的Bar成员”</p><p>The ?. (“optional chaining”) syntax, adopted from JavaScript, is also used. The phrasing “Foo?.Bar” means “if Foo is null or undefined, Foo; otherwise, Foo.Bar”.</p><p>采纳自JavaScript的”?.”语法同样被使用。”Foo?.Bar”表示”如果Foo为null或undefined，则为undefined；否则，Foo.Bar”。</p><p>For example, where buffer is a GPUBuffer, buffer?.[[device]].[[adapter]] means “if buffer is null or undefined, then undefined, otherwise, the [[adapter]] internal slot of the [[device]] internal slot of buffer.</p><p>例如，buffer是一个GPUBuffer对象，buffer?.[[device]].[[adapter]]表示”如果buffer为null或undefined，则为undefined，否则buffer的内部插槽[[device]]的内部插槽[[adapter]]”</p><p>3.1.2. Internal Objects</p><p>An internal object is a conceptual, non-exposed WebGPU object. Internal objects track the state of an API object and hold any underlying implementation. If the state of a particular internal object can change in parallel from multiple agents, those changes are always atomic with respect to all agents.</p><p>内部对象是概念性的、未公开的WebGPU对象。内部对象跟踪API对象的状态并保存任何底层实现。如果特定内部对象的状态可以从多个代理并行更改，那么这些更改对于所有代理来说都是原子性的。</p><p>Note: An “agent” refers to a JavaScript “thread” (i.e. main thread, or Web Worker).</p><p>注：”agent”是指JavaScript”线程”(即主线程或Web工作线程)。</p><p>3.1.3. WebGPU Interfaces</p><p>A WebGPU interface is an exposed interface which encapsulates an internal object. It provides the interface through which the internal object’s state is changed.</p><p>WebGPU接口是封装内部对象的公开接口。它提供用于更改内部对象状态的接口。</p><p>As a matter of convention, if a WebGPU interface is referred to as invalid, it means that the internal object it encapsulates is invalid.</p><p>按照惯例，如果WebGPU接口被援引为无效，则意味着它封装的内部对象无效。</p><p>Any interface which includes GPUObjectBase is a WebGPU interface.</p><p>任何包含GPUObjectBase的接口都是WebGPU接口。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">interface mixin GPUObjectBase &#123;</span><br><span class="line">    attribute USVString? label;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>GPUObjectBase has the following attributes:</p><p>GPUObjectBase具有以下属性:</p><p>label, of type USVString, nullable<br>A label which can be used by development tools (such as error/warning messages, browser developer tools, or platform debugging utilities) to identify the underlying internal object to the developer. It has no specified format, and therefore cannot be reliably machine-parsed.</p><p>In any given situation, the user agent may or may not choose to use this label.</p><p>label, USVString类型，可为空<br>开发工具（如错误/警告消息、浏览器开发工具或平台调试实用程序）可以使用的标签，用于向开发人员标识底层内部对象。它没有指定的格式，因此无法可靠地进行机器分析。</p><p>在任何给定的情况下，用户代理都可能或可能不选择使用此标签。</p><p>GPUObjectBase has the following internal slots:</p><p>[[device]], of type device, readonly<br> An internal slot holding the device which owns the internal object.</p><p>[[device]], 类型device, 只读<br> 一个内部插槽持有拥有内部对象的设备</p><p>3.1.4. Object Descriptors</p><p>An object descriptor holds the information needed to create an object, which is typically done via one of the create* methods of GPUDevice.</p><p>对象描述符保存创建对象所需的信息，这通常通过GPUDevice的create*方法之一完成。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dictionary GPUObjectDescriptorBase &#123;</span><br><span class="line">    USVString label;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>GPUObjectDescriptorBase has the following members:</p><p>label, of type USVString<br> The initial value of GPUObjectBase.label.</p><p>GPUObjectDescriptorBase有如下成员:</p><p>label, USVString类型<br> GPUObjectBase.label的初始值。</p></div><footer class="post-footer"><div class="post-eof"></div></footer></article><article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://qianqians.github.io/2021/08/09/WebGPU%202.8.%20Privacy/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.gif"><meta itemprop="name" content="qianqians"><meta itemprop="description" content=""></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="qianqians'blog"></span><header class="post-header"><h2 class="post-title" itemprop="name headline"> <a href="/2021/08/09/WebGPU%202.8.%20Privacy/" class="post-title-link" itemprop="url">WebGPU 2.8. Privacy</a></h2><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i></span> <span class="post-meta-item-text">发表于</span> <time title="创建时间：2021-08-09 14:48:47 / 修改时间：15:12:06" itemprop="dateCreated datePublished" datetime="2021-08-09T14:48:47+08:00">2021-08-09</time></span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-folder-o"></i></span> <span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/WebGPU/" itemprop="url" rel="index"><span itemprop="name">WebGPU</span></a></span></span></div></header><div class="post-body" itemprop="articleBody"><p>2.8.1. Machine-specific limits</p><p>WebGPU can expose a lot of detail on the underlying GPU architecture and the device geometry. This includes available physical adapters, many limits on the GPU and CPU resources that could be used (such as the maximum texture size), and any optional hardware-specific capabilities that are available.</p><p>WebGPU可以公开很多关于底层GPU架构和设备几何结构的细节。这包括可用的物理适配器、对可使用的GPU和CPU资源的许多限制（如最大纹理大小）以及任何可选的硬件特定功能。</p><p>User agents are not obligated to expose the real hardware limits, they are in full contol of how much the machine specifics are exposed. One strategy to reduce fingeprinting is binning all the target platforms into a few number of bins. In general, the privacy impact of exposing the hardware limits matches the one of WebGL.</p><p>用户代理没有义务公开真正的硬件限制，他们完全控制机器细节的公开程度。减少fingeprinting的一个策略是将所有目标平台放入几个箱子中。一般来说，公开硬件限制对隐私的影响与WebGL的影响相匹配。</p><p>The default limits are also deliberately high enough to allow most application to work without requesting higher limits. All the usage of the API is validated according to the requested limits, so the actual hardware capabilities are not exposed to the users by accident.</p><p>默认限制也有意设置得足够高，以允许大多数应用程序在不请求更高限制的情况下工作。API的所有使用都是根据请求的限制进行验证的，因此实际的硬件功能不会意外地暴露给用户。</p><p>2.8.2. Machine-specific artifacts</p><p>There are some machine-specific rasterization/precision artifacts and performance differences that can be observed roughly in the same way as in WebGL. This applies to rasterization coverage and patterns, interpolation precision of the varyings between shader stages, compute unit scheduling, and more aspects of execution.</p><p>存在一些特定于机器的光栅化/精度瑕疵和性能差异，其观察方式与WebGL大致相同。这适用于光栅化覆盖率和模式、着色器阶段之间变量的插值精度、计算单元调度以及执行的更多方面。</p><p>Generally, rasterization and precision fingerprints are identical across most or all of the devices of each vendor. Performance differences are relatively intractable, but also relatively low-signal (as with JS execution performance).</p><p>通常，每个供应商的大部分或所有设备上的光栅化和精确指纹都是相同的。性能差异比较棘手，但信号也相对较低（与JS执行性能一样）。</p><p>Privacy-critical applications and user agents should utilize software implementations to eliminate such artifacts.</p><p>隐私关键型应用程序和用户代理应利用软件实现消除此类组件。</p><p>2.8.3. Machine-specific performance</p><p>Another factor for differentiating users is measuring the performance of specific operations on the GPU. Even with low precision timing, repeated execution of an operation can show if the user’s machine is fast at specific workloads. This is a fairly common vector (present in both WebGL and Javascript), but it’s also low-signal and relatively intractable to truly normalize.</p><p>区分用户的另一个因素是衡量GPU上特定操作的性能。即使使用低精度计时，重复执行操作也可以显示用户的机器在特定工作负载下是否快速。这是一个相当常见的向量（存在于WebGL和Javascript中），但它也是一个低信号，要真正规范化它相对困难。</p><p>WebGPU compute pipelines expose access to GPU unobstructed by the fixed-function hardware. This poses an additional risk for unique device fingerprinting. User agents can take steps to dissociate logical GPU invocations with actual compute units to reduce this risk.</p><p>WebGPU计算管道公开对GPU的访问，不受固定功能硬件的阻碍。这给独特的设备指纹识别带来了额外的风险。用户代理可以采取步骤将逻辑GPU调用与实际计算单元分离，以降低这种风险。</p><p>2.8.4. User Agent State</p><p>This specification doesn’t define any additional user-agent state for an origin. However it is expected that user agents will have compilation caches for the result of expensive compilation like GPUShaderModule, GPURenderPipeline and GPUComputePipeline. These caches are important to improve the loading time of WebGPU applications after the first visit.</p><p>此规范没有为源定义任何其他用户代理状态。但是，预计用户代理将为昂贵的编译结果（如GPUShaderModule、GPURenderPipeline和GPUComputePipeline）提供编译缓存。这些缓存对于提高首次访问后WebGPU应用程序的加载时间非常重要。</p><p>For the specification, these caches are indifferentiable from incredibly fast compilation, but for applications it would be easy to measure how long createComputePipelineAsync() takes to resolve. This can leak information across origins (like “did the user access a site with this specific shader”) so user agents should follow the best practices in storage partitioning.</p><p>对于规范来说，这些缓存与异常快速的编译是不可区分的，但是对于应用程序来说，很容易测量createComputePipelineAsync()解析所需的时间。这可能会跨源泄漏信息（如“用户是否使用此特定着色器访问了站点”），因此用户代理应遵循存储分区中的最佳做法。</p><p>The system’s GPU driver may also have its own cache of compiled shaders and pipelines. User agents may want to disable these when at all possible, or add per-partition data to shaders in ways that will make the GPU driver consider them different.</p><p>系统的GPU驱动程序也可能有自己的编译着色器和管道缓存。用户代理可能想在所有可能的情况下禁用这些，或者将每个分区数据添加到着色器中，这将使GPU驱动程序认为它们是不同的。</p></div><footer class="post-footer"><div class="post-eof"></div></footer></article><article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://qianqians.github.io/2021/08/09/WebGPU%202.7.%20Workload%20identification/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.gif"><meta itemprop="name" content="qianqians"><meta itemprop="description" content=""></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="qianqians'blog"></span><header class="post-header"><h2 class="post-title" itemprop="name headline"> <a href="/2021/08/09/WebGPU%202.7.%20Workload%20identification/" class="post-title-link" itemprop="url">WebGPU 2.7. Workload identification</a></h2><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i></span> <span class="post-meta-item-text">发表于</span> <time title="创建时间：2021-08-09 12:13:34 / 修改时间：14:48:05" itemprop="dateCreated datePublished" datetime="2021-08-09T12:13:34+08:00">2021-08-09</time></span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-folder-o"></i></span> <span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/WebGPU/" itemprop="url" rel="index"><span itemprop="name">WebGPU</span></a></span></span></div></header><div class="post-body" itemprop="articleBody"><p>WebGPU provides access to constrained global resources shared between different programs (and web pages) running on the same machine. An application can try to indirectly probe how constrained these global resources are, in order to reason about workloads performed by other open web pages, based on the patterns of usage of these shared resources. These issues are generally analogous to issues with Javascript, such as system memory and CPU execution throughput. WebGPU does not provide any additional mitigations for this.</p><p>WebGPU提供对在同一台计算机上运行的不同程序（和网页）之间共享的受限全局资源的访问。应用程序可以尝试间接探测这些全局资源的约束程度，以便根据这些共享资源的使用模式推断其他开放网页执行的工作负载。这些问题通常类似于Javascript的问题，例如系统内存和CPU执行吞吐量。WebGPU不为此提供任何其他缓解措施。</p><p>2.7.1. Memory resources</p><p>WebGPU exposes fallible allocations from machine-global memory heaps, such as VRAM. This allows for probing the size of the system’s remaining available memory (for a given heap type) by attempting to allocate and watching for allocation failures.</p><p>WebGPU暴露了来自硬件的全局内存堆（如VRAM）的易出错的分配。这允许通过尝试分配和观察分配失败来探测系统剩余可用内存的大小（对于给定堆类型）。</p><p>GPUs internally have one or more (typically only two) heaps of memory shared by all running applications. When a heap is depleted, WebGPU would fail to create a resource. This is observable, which may allow a malicious application to guess what heaps are used by other applications, and how much they allocate from them.</p><p>GPU内部有一个或多个（通常只有两个）由所有运行的应用程序共享的内存堆。当堆耗尽时，WebGPU将无法创建资源。这是可以观察到的，这可能允许恶意应用程序猜测其他应用程序使用了哪些堆，以及它们从中分配了多少。</p><p>2.7.2. Computation resources</p><p>If one site uses WebGPU at the same time as another, it may observe the increase in time it takes to process some work. For example, if a site constantly submits compute workloads and tracks completion of work on the queue, it may observe that something else also started using the GPU.</p><p>如果一个站点与其他页面同时使用WebGPU，它可能会观察到处理某些工作所需的时间增加。例如，如果站点不断提交计算工作负载并跟踪队列上的工作完成情况，那么它可能会发现其他东西也开始使用GPU。</p><p>A GPU has many parts that can be tested independently, such as the arithmetic units, texture sampling units, atomic units, etc. A malicious application may sense when some of these units are stressed, and attempt to guess the workload of another application by analyzing the stress patterns. This is analogous to the realities of CPU execution of Javascript.</p><p>GPU有许多可以独立测试的部分，如算术单元、纹理采样单元、原子单元等。恶意应用程序可能会感知其中一些单元何时受到压力，并试图通过分析压力模式来猜测另一个应用程序的工作负载。这类似于Javascript的CPU执行。</p></div><footer class="post-footer"><div class="post-eof"></div></footer></article><article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://qianqians.github.io/2021/08/09/WebGPU%202.6.%20Denial%20of%20service/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.gif"><meta itemprop="name" content="qianqians"><meta itemprop="description" content=""></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="qianqians'blog"></span><header class="post-header"><h2 class="post-title" itemprop="name headline"> <a href="/2021/08/09/WebGPU%202.6.%20Denial%20of%20service/" class="post-title-link" itemprop="url">WebGPU 2.6. Denial of service</a></h2><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i></span> <span class="post-meta-item-text">发表于</span> <time title="创建时间：2021-08-09 12:07:58" itemprop="dateCreated datePublished" datetime="2021-08-09T12:07:58+08:00">2021-08-09</time></span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-calendar-check-o"></i></span> <span class="post-meta-item-text">更新于</span> <time title="修改时间：2021-08-10 10:47:44" itemprop="dateModified" datetime="2021-08-10T10:47:44+08:00">2021-08-10</time></span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-folder-o"></i></span> <span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/WebGPU/" itemprop="url" rel="index"><span itemprop="name">WebGPU</span></a></span></span></div></header><div class="post-body" itemprop="articleBody"><p>WebGPU applications have access to GPU memory and compute units. A WebGPU implementation may limit the available GPU memory to an application, in order to keep other applications responsive. For GPU processing time, a WebGPU implementation may set up “watchdog” timer that makes sure an application doesn’t cause GPU unresponsiveness for more than a few seconds. These measures are similar to those used in WebGL.</p><p>WebGPU应用程序可以访问显存和GPU计算单元。WebGPU实现可能会将可用GPU内存限制在应用程序上，以保持其他应用程序的响应性。对于GPU处理时间，WebGPU实现可能会设置”看门狗”计时器，以确保应用程序不会导致GPU不响应超过几秒钟。这些措施与WebGL中使用的措施类似。</p></div><footer class="post-footer"><div class="post-eof"></div></footer></article><nav class="pagination"> <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a></nav></div><script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script></div></div></main><footer class="footer"><div class="footer-inner"><div class="copyright"> &copy; <span itemprop="copyrightYear">2021</span><span class="with-love"><i class="fa fa-user"></i></span> <span class="author" itemprop="copyrightHolder">qianqians</span></div><div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动</div></div></footer></div><script src="/lib/anime.min.js"></script><script src="/lib/velocity/velocity.min.js"></script><script src="/lib/velocity/velocity.ui.min.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/pisces.js"></script><script src="/js/next-boot.js"></script><script src="/js/bookmark.js"></script></body></html>