<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">
  <link rel="manifest" href="/images/manifest.json">
  <meta name="msapplication-config" content="/images/browserconfig.xml">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">
<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"qianqians.github.io","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"remove","padding":18,"offset":12,"onmobile":true},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":true,"scrollpercent":true},"bookmark":{"enable":true,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="qianqians&#39;blog">
<meta property="og:url" content="https://qianqians.github.io/index.html">
<meta property="og:site_name" content="qianqians&#39;blog">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="qianqians">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://qianqians.github.io/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>qianqians'blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">qianqians'blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档<span class="badge">39</span></a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>分类<span class="badge">10</span></a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-fw fa-user"></i>关于</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <a role="button" class="book-mark-link book-mark-link-fixed"></a>

  <a href="https://github.com/qianqians" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://qianqians.github.io/2024/01/28/pyo3-asyncio/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="qianqians">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="qianqians'blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/01/28/pyo3-asyncio/" class="post-title-link" itemprop="url">python Rust互相调用</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-01-28 19:26:19" itemprop="dateCreated datePublished" datetime="2024-01-28T19:26:19+08:00">2024-01-28</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-01-31 17:49:00" itemprop="dateModified" datetime="2024-01-31T17:49:00+08:00">2024-01-31</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/rust/" itemprop="url" rel="index"><span itemprop="name">rust</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/python/" itemprop="url" rel="index"><span itemprop="name">python</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/pyo3-asyncio/" itemprop="url" rel="index"><span itemprop="name">pyo3-asyncio</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">future</span> = Python::<span class="title function_ invoke__">with_gil</span>(|py| &#123;</span><br><span class="line">    <span class="comment">// import the module containing the py_sleep function</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">example</span> = py.<span class="title function_ invoke__">import</span>(<span class="string">&quot;example&quot;</span>)?;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// calling the py_sleep method like a normal function returns a coroutine</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">coroutine</span> = example.<span class="title function_ invoke__">call_method0</span>(<span class="string">&quot;py_sleep&quot;</span>)?;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// convert the coroutine into a Rust future</span></span><br><span class="line">    pyo3_asyncio::<span class="title function_ invoke__">into_future</span>(coroutine)</span><br><span class="line">&#125;)?;</span><br><span class="line"></span><br><span class="line"><span class="comment">// await the future</span></span><br><span class="line">future.<span class="keyword">await</span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[pyfunction]</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">call_rust_sleep</span>(py: Python) <span class="punctuation">-&gt;</span> PyResult&lt;PyObject&gt; &#123;</span><br><span class="line">    pyo3_asyncio::async_std::<span class="title function_ invoke__">into_coroutine</span>(py, <span class="keyword">async</span> <span class="keyword">move</span> &#123;</span><br><span class="line">        <span class="title function_ invoke__">rust_sleep</span>().<span class="keyword">await</span>;</span><br><span class="line">        <span class="title function_ invoke__">Ok</span>(())</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">pyo3_asyncio::tokio::<span class="title function_ invoke__">future_into_py</span>(py, <span class="keyword">async</span> <span class="keyword">move</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">_server_handle</span> = _server.<span class="title function_ invoke__">as_ref</span>().<span class="title function_ invoke__">lock</span>().<span class="keyword">await</span>;</span><br><span class="line">    _server_handle.<span class="title function_ invoke__">entry_direct_hub_server</span>(hub_name).<span class="keyword">await</span>;</span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(())</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://qianqians.github.io/2024/01/25/ice_Dictionaries/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="qianqians">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="qianqians'blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/01/25/ice_Dictionaries/" class="post-title-link" itemprop="url">Dictionaries</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2024-01-25 22:41:09 / 修改时间：22:50:32" itemprop="dateCreated datePublished" datetime="2024-01-25T22:41:09+08:00">2024-01-25</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/ice/" itemprop="url" rel="index"><span itemprop="name">ice</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>Dictionary Syntax and Semantics</p>
<p>A dictionary is a mapping from a key type to a value type.</p>
<p>dictionary是从键类型到值类型的映射</p>
<p>For example:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> M</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Employee</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">long</span>   number;</span><br><span class="line">        string firstName;</span><br><span class="line">        string lastName;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    dictionary&lt;<span class="type">long</span>, Employee&gt; EmployeeMap;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>This definition creates a dictionary named EmployeeMap that maps from an employee number to a structure containing the details for an employee. Whether or not the key type (the employee number, of type long in this example) is also part of the value type (the Employee structure in this example) is up to you — as far as Slice is concerned, there is no need to include the key as part of the value.</p>
<p>此定义创建一个名为 EmployeeMap 的dictionary，该dictionary从员工编号映射到包含员工详细信息的结构。 键类型（员工编号，本例中为 long 类型）是否也是值类型（本例中为 Employee 结构）的一部分取决于您 — 就 Slice 而言，不需要 包含键作为值的一部分。</p>
<p>Dictionaries can be used to implement sparse arrays, or any lookup data structure with non-integral key type. Even though a sequence of structures containing key-value pairs could be used to model the same thing, a dictionary is more appropriate:</p>
<p>dictionary可用于实现稀疏数组或任何具有非整数键类型的查找数据结构。 尽管包含键值对的结构序列可用于对同一事物进行建模，但dictionary更合适：</p>
<p>A dictionary clearly signals the intent of the designer, namely, to provide a mapping from a domain of values to a range of values. (A sequence of structures of key-value pairs does not signal that same intent as clearly.)</p>
<p>dictionary清楚地表明了设计者的意图，即提供从值域到值范围的映射。 （键值对结构的sequence并不能清楚地表明相同的意图。）</p>
<p>At the programming language level, sequences are implemented as vectors (or possibly lists), that is, they are not well suited to model sparsely populated domains and require a linear search to locate an element with a particular value. On the other hand, dictionaries are implemented as a data structure (typically a hash table or red-black tree) that supports efficient searching in O(log n) average time or better.</p>
<p>在编程语言级别，sequences被实现为数组（或可能是list），也就是说，它们不太适合对稀疏填充的域进行建模，并且需要线性搜索来定位具有特定值的元素。 另一方面，dictionary被实现为另一种数据结构（通常是哈希表或红黑树），支持平均时间为 O(log n) 或更好的高效搜索。</p>
<p>Allowable Types for Dictionary Keys and Values</p>
<p>The key type of a dictionary need not be an integral type. For example, we could use the following definition to translate the names of the days of the week:</p>
<p>dictionary的键类型不必是整型。 例如，我们可以使用以下定义来翻译一周中各天的名称：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dictionary&lt;string, string&gt; WeekdaysEnglishToGerman;</span><br></pre></td></tr></table></figure>

<p>The server implementation would take care of initializing this map with the key-value pairs Monday-Montag, Tuesday-Dienstag, and so on.</p>
<p>服务器实现将负责使用键值对 Monday-Montag、Tuesday-Dienstag 等初始化该映射。</p>
<p>The value type of a dictionary can be any Slice type. However, the key type of a dictionary is limited to one of the following types:</p>
<p>dictionary的值类型可以是任何 Slice 类型。 但是，字典的键类型仅限于以下类型之一：</p>
<p>Integral types (short, int, long)<br>bool<br>byte<br>string<br>enum<br>Structures containing only data members of legal key types</p>
<p>Other complex types, such as dictionaries, and floating-point types (float and double) cannot be used as the key type. Complex types are disallowed because they complicate the language mappings for dictionaries, and floating-point types are disallowed because representational changes of values as they cross machine boundaries can lead to ill-defined semantics for equality.</p>
<p>其他复杂类型，例如dictionary和浮点类型（float 和 double）不能用作键类型。 不允许使用复杂类型，因为它们使dictionary的语言映射变得复杂；并且不允许使用浮点类型，因为跨机器边界时值的表示变化可能会导致平等语义定义不明确。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://qianqians.github.io/2024/01/24/ice_Sequences/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="qianqians">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="qianqians'blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/01/24/ice_Sequences/" class="post-title-link" itemprop="url">Sequences</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2024-01-24 22:39:43 / 修改时间：22:44:06" itemprop="dateCreated datePublished" datetime="2024-01-24T22:39:43+08:00">2024-01-24</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/ice/" itemprop="url" rel="index"><span itemprop="name">ice</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>Sequences are variable-length collections of elements:</p>
<p>Sequences是可变长度的元素集合：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> M</span><br><span class="line">&#123;</span><br><span class="line">    sequence&lt;Fruit&gt; FruitPlatter;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>A sequence can be empty — that is, it can contain no elements, or it can hold any number of elements up to the memory limits of your platform.</p>
<p>Sequences can contain elements that are themselves sequences. This arrangement allows you to create lists of lists:</p>
<p>sequence可以是空的，即不包含任何元素，也可以包含任意数量的元素，但不得超过平台的内存限制。</p>
<p>sequence可以包含本身就是sequence的元素。通过这种安排，您可以创建列表的列表：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> M</span><br><span class="line">&#123;</span><br><span class="line">    sequence&lt;FruitPlatter&gt; FruitBanquet;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Sequences are used to model a variety of collections, such as vectors, lists, queues, sets, bags, or trees. (It is up to the application to decide whether or not order is important; by discarding order, a sequence serves as a set or bag.)</p>
<p>Sequences用于对各种集合建模，例如向量、列表、队列、集合、包或树。 （由应用程序决定顺序是否重要；通过丢弃顺序，Sequences充当集合或包。）</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://qianqians.github.io/2024/01/03/ice_Structures/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="qianqians">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="qianqians'blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/01/03/ice_Structures/" class="post-title-link" itemprop="url">Structures</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2024-01-03 23:13:38 / 修改时间：23:21:10" itemprop="dateCreated datePublished" datetime="2024-01-03T23:13:38+08:00">2024-01-03</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/ice/" itemprop="url" rel="index"><span itemprop="name">ice</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>Slice supports structures containing one or more named members of arbitrary type, including user-defined complex types. For example:</p>
<p>Slice 支持包含一个或多个任意类型的命名成员的结构，包括用户定义的复杂类型。 例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> M</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">TimeOfDay</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">short</span> hour;         <span class="comment">// 0 - 23</span></span><br><span class="line">        <span class="type">short</span> minute;       <span class="comment">// 0 - 59</span></span><br><span class="line">        <span class="type">short</span> second;       <span class="comment">// 0 - 59</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>As in C++, this definition introduces a new type called TimeOfDay. Structure definitions form a namespace, so the names of the structure members need to be unique only within their enclosing structure.</p>
<p>Data member definitions using a named type are the only construct that can appear inside a structure. It is impossible to, for example, define a structure inside a structure:</p>
<p>与 C++ 中一样，此定义引入了一种称为 TimeOfDay 的新类型。 结构定义形成命名空间，因此结构成员的名称仅在其封闭结构内必须是唯一的。</p>
<p>使用确定类型的数据成员定义是唯一可以出现在结构内部的构造。 例如，不可能在结构内定义结构：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">TwoPoints</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Point</span>      <span class="comment">// 非法!</span></span><br><span class="line">    &#123;            </span><br><span class="line">        <span class="type">short</span> x;</span><br><span class="line">        <span class="type">short</span> y;</span><br><span class="line">    &#125;</span><br><span class="line">    Point coord1;</span><br><span class="line">    Point coord2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>This rule applies to Slice in general: type definitions cannot be nested (except for modules, which do support nesting). The reason for this rule is that nested type definitions can be difficult to implement for some target languages and, even if implementable, greatly complicate the scope resolution rules. For a specification language, such as Slice, nested type definitions are unnecessary – you can always write the above definitions as follows (which is stylistically cleaner as well):</p>
<p>此规则一般适用于 Slice：类型定义不能嵌套（模块除外，模块支持嵌套）。 此规则的原因是嵌套类型定义对于某些目标语言可能难以实现，并且即使可以实现，也会使范围解析规则变得非常复杂。 对于规范语言，例如 Slice，嵌套类型定义是不必要的 - 您始终可以按如下方式编写上述定义（这在风格上也更清晰）：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Point</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">short</span> x;</span><br><span class="line">    <span class="type">short</span> y;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">TwoPoints</span>      <span class="comment">// Legal (and cleaner!)</span></span><br><span class="line">&#123;   </span><br><span class="line">    Point coord1;</span><br><span class="line">    Point coord2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>You can specify a default value for a data member that has one of the following types:</p>
<p>您可以为具有以下类型之一的数据成员指定默认值：</p>
<ol>
<li>An integral type (byte, short, int, long)</li>
<li>A floating point type (float or double)</li>
<li>string</li>
<li>bool</li>
<li>enum</li>
</ol>
<p>For example:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Location</span></span><br><span class="line">&#123;</span><br><span class="line">    string name;</span><br><span class="line">    Point pt;</span><br><span class="line">    <span class="type">bool</span> display = <span class="literal">true</span>;</span><br><span class="line">    string source = <span class="string">&quot;GPS&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>The legal syntax for literal values is the same as for Slice constants, and you may also use a constant as a default value. The language mapping guarantees that data members are initialized to their declared default values using a language-specific mechanism.</p>
<p>字符值的合法语法与 Slice 常量相同，您也可以使用常量作为默认值。 语言映射保证使用特定于语言的机制将数据成员初始化为其声明的默认值。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://qianqians.github.io/2023/12/11/ice_Enumerations/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="qianqians">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="qianqians'blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/12/11/ice_Enumerations/" class="post-title-link" itemprop="url">Enumerations</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2023-12-11 23:01:14 / 修改时间：23:07:26" itemprop="dateCreated datePublished" datetime="2023-12-11T23:01:14+08:00">2023-12-11</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/ice/" itemprop="url" rel="index"><span itemprop="name">ice</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>Enumeration Syntax and Semantics</p>
<p>Slice 枚举类型定义看起来与 C++ 相同：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> M</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">enum</span> <span class="title class_">Fruit</span> &#123; Apple, Pear, Orange &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>This definition introduces a type named Fruit that becomes a new type in its own right. Slice guarantees that the values of enumerators increase from left to right, so Apple compares less than Pear in every language mapping. By default, the first enumerator has a value of zero, with sequentially increasing values for subsequent enumerators.</p>
<p>A Slice enum type introduces a new namespace scope, so the following is legal:</p>
<p>这个定义引入了一个名为 Fruit 的类型，它本身就成为一种新类型。 Slice 保证枚举数的值从左到右递增，因此 Apple 在每种语言映射中都比 Pear 进行比较。 默认情况下，第一个枚举数的值为零，后续枚举数的值依次增加。</p>
<p>Slice 枚举类型引入了新的命名空间范围，因此以下内容是合法的：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> M</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">enum</span> <span class="title class_">Fruit</span> &#123; Apple, Pear, Orange &#125;</span><br><span class="line">    <span class="keyword">enum</span> <span class="title class_">ComputerBrands</span> &#123; Apple, Dell, HP, Lenovo &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>The example below shows how to refer to an enumerator from a different scope:</p>
<p>下面的示例展示了如何从不同的范围引用枚举：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> M</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">enum</span> <span class="title class_">Color</span> &#123; Red, Green, Blue &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">module</span> N</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Pixel</span></span><br><span class="line">    &#123;</span><br><span class="line">        M::Color c = Blue;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Slice does not permit empty enumerations.</p>
<p>Slice 不允许空枚举。</p>
<p>In Ice releases prior to Ice 3.7, an enum type did not create a new namespace and its enumerators were in the same namespace as the enum type itself. With these releases, you had to select longer enumerator names to avoid a naming clash.</p>
<p>在 Ice 3.7 之前的 Ice 版本中，枚举类型不会创建新的命名空间，并且其枚举器与枚举类型本身位于同一命名空间中。 在这些版本中，您必须选择更长的枚举器名称以避免命名冲突。</p>
<p>Custom Enumerator Values</p>
<p>Slice also permits you to assign custom values to enumerators:</p>
<p>Slice 还允许您为枚举器分配自定义值：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> PearValue = <span class="number">7</span>;</span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">Fruit</span> &#123; Apple = <span class="number">0</span>, Pear = PearValue, Orange &#125;</span><br></pre></td></tr></table></figure>

<p>Custom values must be unique and non-negative, and may refer to Slice constants of integer types. If no custom value is specified for an enumerator, its value is one greater than the enumerator that immediately precedes it. In the example above, Orange has the value 8.</p>
<p>The maximum value for an enumerator value is the same as the maximum value for int, 2 31 - 1.</p>
<p>Slice does not require custom enumerator values to be declared in increasing order:</p>
<p>自定义值必须是唯一且非负的，并且可以引用整数类型的 Slice 常量。 如果没有为枚举器指定自定义值，则其值比紧邻其前面的枚举器大 1。 在上面的示例中，Orange的值为 8。</p>
<p>枚举值的最大值与 int 的最大值相同，即 2^31 - 1。</p>
<p>Slice 不需要按升序声明自定义枚举值：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Fruit</span> &#123; Apple = <span class="number">5</span>, Pear = <span class="number">3</span>, Orange = <span class="number">1</span> &#125;   <span class="comment">// 合法的</span></span><br></pre></td></tr></table></figure>

<p>Note however that when there is an inconsistency between the declaration order and the numerical order of the enumerators, the behavior of comparison operations may vary between language mappings.</p>
<p>但请注意，当声明顺序与枚举数的数字顺序不一致时，比较操作的行为可能会因语言映射而异。</p>
<p>For an application that is still using version 1.0 of the Ice encoding, changing the definition of an enumerated type may break backward compatibility with existing applications. For more information, please refer to the encoding rules for enumerators.</p>
<p>对于仍在使用 Ice 编码 1.0 版的应用程序，更改枚举类型的定义可能会破坏与现有应用程序的向后兼容性。 更多信息请参考枚举数的编码规则。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://qianqians.github.io/2023/12/06/ice_Basic_Types/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="qianqians">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="qianqians'blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/12/06/ice_Basic_Types/" class="post-title-link" itemprop="url">Basic Types</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2023-12-06 21:27:32 / 修改时间：21:39:04" itemprop="dateCreated datePublished" datetime="2023-12-06T21:27:32+08:00">2023-12-06</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/ice/" itemprop="url" rel="index"><span itemprop="name">ice</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>Basic Types</p>
<p>Built-In Basic Types<br>Slice provides a number of built-in basic types, as shown in this table:</p>
<p>内置基本类型<br>Slice 提供了许多内置的基本类型，如下表所示：</p>
<table>
<thead>
<tr>
<th align="center">Type</th>
<th align="center">Range of Mapped Type</th>
<th align="center">Size of Mapped Type</th>
</tr>
</thead>
<tbody><tr>
<td align="center">bool</td>
<td align="center">false or true</td>
<td align="center">≥ 1bit</td>
</tr>
<tr>
<td align="center">byte</td>
<td align="center">-128-127 or 0-255</td>
<td align="center">≥ 8 bits</td>
</tr>
<tr>
<td align="center">short</td>
<td align="center">-2^15 to 2^15 -1</td>
<td align="center">≥ 16 bits</td>
</tr>
<tr>
<td align="center">int</td>
<td align="center">-2^31 to 2^31 -1</td>
<td align="center">≥ 32 bits</td>
</tr>
<tr>
<td align="center">long</td>
<td align="center">-2^63 to 2^63 -1</td>
<td align="center">≥ 64 bits</td>
</tr>
<tr>
<td align="center">float</td>
<td align="center">IEEE single-precision</td>
<td align="center">≥ 32 bits</td>
</tr>
<tr>
<td align="center">double</td>
<td align="center">IEEE double-precision</td>
<td align="center">≥ 64 bits</td>
</tr>
<tr>
<td align="center">string</td>
<td align="center">All Unicode characters</td>
<td align="center">Variable-length</td>
</tr>
</tbody></table>
<p>The range depends on whether byte maps to a signed or an unsigned type.</p>
<p>范围取决于字节映射到有符号类型还是无符号类型。</p>
<p>All the basic types (except byte) are subject to changes in representation as they are transmitted between clients and servers. For example, a long value is byte-swapped when sent from a little-endian to a big-endian machine. However, these changes are transparent to the programmer and do exactly what is required.</p>
<p>所有基本类型（字节除外）在客户端和服务器之间传输时都会发生表示形式的变化。 例如，长值在从小端机器发送到大端机器时会进行字节交换。 然而，这些更改对程序员来说是透明的，并且完全按照要求进行。</p>
<p>Integer Types</p>
<p>Slice provides integer types short, int, and long, with 16-bit, 32-bit, and 64-bit ranges, respectively. Note that, on some architectures, any of these types may be mapped to a native type that is wider. Also note that no unsigned types are provided. (This choice was made because unsigned types are difficult to map into languages without native unsigned types, such as Java. In addition, the unsigned integers add little value to a language.</p>
<p>Slice 提供整数类型short、int 和long，分别具有16 位、32 位和64 位范围。 请注意，在某些体系结构上，这些类型中的任何一个都可以映射到更宽的本机类型。 另请注意，不提供无符号类型。 （做出这个选择是因为无符号类型很难映射到没有本机无符号类型的语言，例如 Java。此外，无符号整数对语言几乎没有增加价值。</p>
<p>Floating-Point Types</p>
<p>These types follow the IEEE specification for single- and double-precision floating-point representation [1]. If an implementation cannot support IEEE format floating-point values, the Ice run time converts values into the native floating-point representation (possibly at a loss of precision or even magnitude, depending on the capabilities of the native floating-point format).</p>
<p>这些类型遵循单精度和双精度浮点表示的 IEEE 规范 [1]。 如果实现无法支持 IEEE 格式浮点值，Ice run time 会将值转换为本机浮点表示形式（可能会损失精度甚至幅度，具体取决于本机浮点格式的功能）。</p>
<p>Strings</p>
<p>Slice strings use the Unicode character set and are encoded using UTF-8 when transmitted between clients and servers.</p>
<p>Slice字符串使用 Unicode 字符集，并在客户端和服务器之间传输时使用 UTF-8 进行编码。</p>
<p>Booleans</p>
<p>Boolean values can have only the values false and true. Language mappings use the corresponding native boolean type if one is available.</p>
<p>布尔值只能有 false 和 true 值。 语言映射使用相应的本机布尔类型（如果可用）。</p>
<p>Bytes</p>
<p>The Slice type byte is an (at least) 8-bit type that is guaranteed not to undergo any changes in representation as it is transmitted between address spaces. This guarantee permits exchange of binary data such that it is not tampered with in transit. All other Slice types are subject to changes in representation during transmission.</p>
<p>Slice 类型字节是（至少）8 位类型，保证在地址空间之间传输时不会发生任何表示形式的变化。 此保证允许交换二进制数据，使其在传输过程中不会被篡改。 所有其他切片类型在传输过程中的表示形式都会发生变化。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://qianqians.github.io/2023/12/04/ice_Modules/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="qianqians">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="qianqians'blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/12/04/ice_Modules/" class="post-title-link" itemprop="url">Modules</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2023-12-04 20:51:43 / 修改时间：20:58:47" itemprop="dateCreated datePublished" datetime="2023-12-04T20:51:43+08:00">2023-12-04</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/ice/" itemprop="url" rel="index"><span itemprop="name">ice</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>Modules Reduce Clutter</p>
<p>A common problem in large systems is pollution of the global namespace: over time, as isolated systems are integrated, name clashes become quite likely. Slice provides the module construct to alleviate this problem:</p>
<p>大型系统中的一个常见问题是全局名称空间的污染：随着时间的推移，随着孤立的系统的集成，名称冲突变得很可能。 Slice 提供了模块构造来缓解这个问题：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> ZeroC </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">module</span> Client </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Definitions here...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">module</span> Server </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Definitions here...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>A module can contain any legal Slice construct, including other module definitions. Using modules to group related definitions together avoids polluting the global namespace and makes accidental name clashes quite unlikely. (You can use a well-known name, such as a company or product name, as the name of the outermost module.)</p>
<p>模块可以包含任何合法的 Slice 构造，包括其他模块定义。 使用模块将相关定义分组在一起可以避免污染全局名称空间，并且不太可能发生意外的名称冲突。 （您可以使用众所周知的名称，例如公司或产品名称，作为最外层模块的名称。）</p>
<p>Modules are Mandatory</p>
<p>Slice requires all definitions to be nested inside a module, that is, you cannot define anything other than a module at global scope. For example, the following is illegal:</p>
<p>Slice 要求所有定义都嵌套在模块内，也就是说，您不能在全局范围内定义除模块之外的任何内容。 例如，以下行为是非法的：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">interface I   <span class="comment">// Error: only modules can appear at global scope</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Definitions at global scope are prohibited because they cause problems with some implementation languages (such as Python, which does not have a true global scope).</p>
<p>禁止在全局范围内进行定义，因为它们会导致某些实现语言（例如 Python，它没有真正的全局范围）出现问题。</p>
<p>Throughout the Ice manual, you will occasionally see Slice definitions that are not nested inside a module. This is to keep the examples short and free of clutter. Whenever you see such a definition, assume that it is nested in module M.</p>
<p>在整个 Ice 手册中，您偶尔会看到未嵌套在模块内的 Slice 定义。 这是为了保持示例简短且整洁。 每当您看到这样的定义时，请假设它嵌套在模块 M 中。</p>
<p>Reopening Modules</p>
<p>Modules can be reopened:</p>
<p>可以重新打开模块：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> ZeroC</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Definitions here...</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// Possibly in a different source file:</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">module</span> ZeroC <span class="comment">// OK, reopened module</span></span><br><span class="line">&#123;  </span><br><span class="line">    <span class="comment">// More definitions here...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Reopened modules are useful for larger projects: they allow you to split the contents of a module over several different source files. The advantage of doing this is that, when a developer makes a change to one part of the module, only files dependent on the changed part need be recompiled (instead of having to recompile all files that use the module).</p>
<p>重新打开的模块对于较大的项目很有用：它们允许您将模块的内容拆分为多个不同的源文件。 这样做的好处是，当开发人员对模块的一部分进行更改时，只需重新编译依赖于更改部分的文件（而不需要重新编译使用该模块的所有文件）。</p>
<p>Module Mapping</p>
<p>Modules map to a corresponding scoping construct in each programming language. (For example, for C++ and C#, Slice modules map to namespaces whereas, for Java, they map to packages.) This allows you to use an appropriate C++ using or Java import declaration to avoid excessively long identifiers in your source code.</p>
<p>模块映射到每种编程语言中相应的作用域构造。 （例如，对于 C++ 和 C#，Slice 模块映射到命名空间，而对于 Java，它们映射到包。）这允许您使用适当的 C++ using 或 Java import 声明来避免源代码中的标识符过长。</p>
<p>The Ice Module</p>
<p>APIs for the Ice run time, apart from a small number of language-specific calls that cannot be expressed in Ice, are defined in the Ice module. In other words, most of the Ice API is actually expressed as Slice definitions. The advantage of doing this is that a single Slice definition is sufficient to define the API for the Ice run time for all supported languages. The respective language mapping rules then determine the exact shape of each Ice API for each implementation language.</p>
<p>We will incrementally explore the contents of the Ice module throughout this manual.</p>
<p>Ice 运行时的 API，除了少数无法在 Ice 中表达的特定于语言的调用之外，均在 Ice 模块中定义。 换句话说，大部分 Ice API 实际上都是表达为 Slice 定义的。 这样做的优点是单个 Slice 定义足以为所有支持的语言定义 Ice 运行时的 API。 然后，相应的语言映射规则确定每种实现语言的每个 Ice API 的确切形态。</p>
<p>我们将在本手册中逐步探索 Ice 模块的内容。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://qianqians.github.io/2023/11/26/ice_Lexical_Rules/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="qianqians">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="qianqians'blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/11/26/ice_Lexical_Rules/" class="post-title-link" itemprop="url">Lexical Rules</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2023-11-26 22:46:10 / 修改时间：23:01:50" itemprop="dateCreated datePublished" datetime="2023-11-26T22:46:10+08:00">2023-11-26</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/ice/" itemprop="url" rel="index"><span itemprop="name">ice</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>Lexical Rules</p>
<p>Slice’s lexical rules are very similar to those of C++ and Java, except for some differences for identifiers.</p>
<p>Slice 的词法规则与 C++ 和 Java 的非常相似，除了标识符的一些差异之外。</p>
<p>Comments</p>
<p>Slice definitions permit both the C and the C++ style of writing comments:</p>
<p>Slice定义允许使用 C 和 C++ 风格编写注释：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * C-style comment.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// C++-style comment extending to the end of this line.</span></span><br></pre></td></tr></table></figure>

<p>Keywords<br>Slice uses a number of keywords, which must be spelled in lowercase. For example, class and dictionary are keywords and must be spelled as shown. There are three exceptions to this lowercase rule: LocalObject, Object and Value are keywords and must be capitalized as shown.</p>
<p>Slice 使用许多关键字，这些关键字必须以小写形式拼写。 例如，class 和dictionary 是关键字，必须按所示拼写。 此小写规则有三个例外：LocalObject、Object 和 Value 是关键字，必须大写，如图所示。</p>
<p>Identifiers</p>
<p>Identifiers begin with an alphabetic character followed by any number of alphabetic characters or digits. Underscores are also permitted in identifiers with the following limitations:</p>
<p>an identifier cannot begin or end with an underscore<br>an identifier cannot contain multiple consecutive underscores<br>Given these rules, the identifier get_account_name is legal but not <em>account, account</em>, or get__account.</p>
<p>Slice identifiers are restricted to the ASCII range of alphabetic characters and cannot contain non-English letters, such as Å. (Supporting non-ASCII identifiers would make it very difficult to map Slice to target languages that lack support for this feature.)</p>
<p>标识符以字母字符开头，后跟任意数量的字母字符或数字。 标识符中也允许使用下划线，但有以下限制：</p>
<p>标识符不能以下划线开头或结尾<br>标识符不能包含多个连续的下划线<br>根据这些规则，标识符 get_account_name 合法，但 <em>account、account</em> 或 get__account 不合法。</p>
<p>Slice标识符仅限于 ASCII 范围内的字母字符，不能包含非英文字母，例如 Å。 （支持非 ASCII 标识符将使将 Slice 映射到不支持此功能的目标语言变得非常困难。）</p>
<p>Case Sensitivity</p>
<p>Identifiers are case-insensitive but must be capitalized consistently. For example, TimeOfDay and TIMEOFDAY are considered the same identifier within a naming scope. However, Slice enforces consistent capitalization. After you have introduced an identifier, you must capitalize it consistently throughout; otherwise, the compiler will reject it as illegal. This rule exists to permit mappings of Slice to languages that ignore case in identifiers as well as to languages that treat differently capitalized identifiers as distinct.</p>
<p>标识符不区分大小写，但大小写必须一致。 例如，TimeOfDay 和 TIMEOFDAY 在命名范围内被视为相同的标识符。 然而，Slice 强制使用一致的大小写。 引入标识符后，必须始终将其大写； 否则，编译器将认为它是非法的而拒绝它。 存在此规则是为了允许将 Slice 映射到忽略标识符大小写的语言以及将不同大写标识符视为不同的语言。</p>
<p>Identifiers That Are Keywords</p>
<p>You can define Slice identifiers that are keywords in one or more implementation languages. For example, switch is a perfectly good Slice identifier but is a C++ and Java keyword. Each language mapping defines rules for dealing with such identifiers. The solution typically involves using a prefix to map away from the keyword. For example, the Slice identifier switch is mapped to _cpp_switch in C++ and _switch in Java.</p>
<p>The rules for dealing with keywords can result in hard-to-read source code. Identifiers such as native, throw, or export will clash with C++ or Java keywords (or both). To make life easier for yourself and others, try to avoid Slice identifiers that are implementation language keywords. Keep in mind that mappings for new languages may be added to Ice in the future. While it is not reasonable to expect you to compile a list of all keywords in all popular programming languages, you should make an attempt to avoid at least common keywords. Slice identifiers such as self, import, and while are definitely not a good idea.</p>
<p>您可以定义作为一种或多种实现语言中的关键字的Slice标识符。 例如，switch 是一个非常好的 Slice 标识符，但却是一个 C++ 和 Java 关键字。 每种语言映射都定义了处理此类标识符的规则。 该解决方案通常涉及使用前缀来映射关键字。 例如，Slice 标识符 switch 在 C++ 中映射为 _cpp_switch，在 Java 中映射为 _switch。</p>
<p>处理关键字的规则可能会导致源代码难以阅读。 诸如native、 throw 或export 之类的标识符将与C++ 或Java 关键字（或两者）发生冲突。 为了让您和他人的生活更轻松，请尽量避免使用作为实现语言关键字的Slice标识符。 请记住，将来可能会将新语言的映射添加到 Ice 中。 虽然期望您编译所有流行编程语言中的所有关键字的列表是不合理的，但您应该尝试至少避免常见关键字。 self、import 和 while 等Slice标识符绝对不是一个好主意。</p>
<p>Escaped Identifiers</p>
<p>It is possible to use a Slice keyword as an identifier by prefixing the keyword with a backslash, for example:</p>
<p>可以通过在关键字前面加上反斜杠来使用 Slice 关键字作为标识符，例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">dictionary</span>     <span class="comment">// Error!</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">struct</span> \dictionary    <span class="comment">// OK</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">struct</span> \foo           <span class="comment">// Legal, same as &quot;struct foo&quot;</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>The backslash escapes the usual meaning of a keyword; in the preceding example, \dictionary is treated as the identifier dictionary. The escape mechanism exists to permit keywords to be added to the Slice language over time with minimal disruption to existing specifications: if a pre-existing specification happens to use a newly-introduced keyword, that specification can be fixed by simply prepending a backslash to the new keyword. Note that, as a matter of style, you should avoid using Slice keywords as identifiers (even though the backslash escapes allow you to do this).</p>
<p>It is legal (though redundant) to precede an identifier that is not a keyword with a backslash — the backslash is ignored in that case.</p>
<p>反斜杠转义了关键字的通常含义； 在前面的示例中，\dictionary 被视为标识符dictionary 。 转义机制的存在是为了允许关键字随着时间的推移添加到 Slice 语言中，同时对现有规范的干扰最小：如果预先存在的规范碰巧使用了新引入的关键字，则只需在该规范前面添加一个反斜杠即可修复该规范。 新的关键字。 请注意，就风格而言，您应该避免使用 Slice 关键字作为标识符（即使反斜杠转义允许您这样做）。</p>
<p>在不是关键字的标识符前面加上反斜杠是合法的（尽管是多余的）——在这种情况下，反斜杠将被忽略。</p>
<p>Reserved Identifiers</p>
<p>Slice reserves the identifier Ice and all identifiers beginning with Ice (in any capitalization) for the Ice implementation. For example, if you try to define a type named Icecream, the Slice compiler will issue an error message.</p>
<p>Slice 为 Ice 实现保留了标识符 Ice 和所有以 Ice 开头的标识符（任何大小写）。 例如，如果您尝试定义名为 Icecream 的类型，Slice 编译器将发出错误消息。</p>
<p>You can suppress this behavior by using the ice-prefix Slice metadata directive, which enables definition of identifiers beginning with Ice. However, do not use this directive unless you are compiling the Slice definitions for the Ice run time itself.</p>
<p>您可以使用ice-prefix Slice元数据指令来抑制此行为，该指令允许定义以Ice开头的标识符。 但是，除非您正在为 Ice 运行时本身编译 Slice 定义，否则不要使用此指令。</p>
<p>Slice identifiers ending in any of the suffixes Async, Disp, Helper, Holder, Prx, and Ptr are also reserved. These endings are used by the various language mappings and are reserved to prevent name clashes in the generated code.</p>
<p>以任何后缀 Async、Disp、Helper、Holder、Prx 和 Ptr 结尾的Slice标识符也被保留。 这些结尾由各种语言映射使用，并被保留以防止生成的代码中发生名称冲突。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://qianqians.github.io/2023/11/24/ice_Slice_Source_Files/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="qianqians">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="qianqians'blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/11/24/ice_Slice_Source_Files/" class="post-title-link" itemprop="url">Slice Source Files</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2023-11-24 22:04:03 / 修改时间：22:31:58" itemprop="dateCreated datePublished" datetime="2023-11-24T22:04:03+08:00">2023-11-24</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/ice/" itemprop="url" rel="index"><span itemprop="name">ice</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>Slice defines a number of rules for the naming and contents of Slice source files.</p>
<p>Slice 定义了许多 Slice 源文件的命名和内容的规则。</p>
<p>File Naming<br>Files containing Slice definitions must end in a .ice file extension, for example, Clock.ice is a valid file name. Other file extensions are rejected by the compilers.</p>
<p>For case-insensitive file systems, the file extension may be written as uppercase or lowercase, so Clock.ICE is legal. For case-sensitive file systems (such as Unix), Clock.ICE is illegal. (The extension must be in lowercase.)</p>
<p>文件命名<br>包含Slice定义的文件必须以 .ice 文件扩展名结尾，例如，Clock.ice 是有效的文件名。 其他文件扩展名会被编译器拒绝。</p>
<p>对于不区分大小写的文件系统，文件扩展名可以写为大写或小写，因此 Clock.ICE 是合法的。 对于区分大小写的文件系统（例如Unix），Clock.ICE 是非法的。 （扩展名必须为小写。）</p>
<p>File Format<br>Slice is a free-form language so you can use spaces, horizontal and vertical tab stops, form feeds, and newline characters to lay out your code in any way you wish. (White space characters are token separators). Slice does not attach semantics to the layout of a definition. You may wish to follow the style we have used for the Slice examples throughout this book.</p>
<p>Slice files can be ASCII text files or use the UTF-8 character encoding with an optional byte order marker (BOM) at the beginning of each file. However, Slice identifiers are limited to ASCII letters and digits; non-ASCII letters can appear only in comments and string literals.</p>
<p>文件格式<br>Slice 是一种自由格式的语言，因此您可以使用空格、水平和垂直制表位、换页符和换行符以您希望的任何方式布局代码。 （空白字符是标记分隔符）。 Slice 不会将语义附加到定义的布局上。 您可能希望遵循我们在本书中使用的 Slice 示例的风格。</p>
<p>Slice文件可以是 ASCII 文本文件，也可以使用 UTF-8 字符编码，并在每个文件的开头带有可选的字节顺序标记 (BOM)。 然而，Slice标识符仅限于 ASCII 字母和数字； 非 ASCII 字母只能出现在注释和字符串文字中。</p>
<p>Preprocessing<br>Slice supports the same preprocessor directives as C++, so you can use directives such as #include and macro definitions. However, Slice permits #include directives only at the beginning of a file, before any Slice definitions.</p>
<p>If you use #include directives, it is a good idea to protect them with guards to prevent double inclusion of a file:</p>
<p>预处理<br>Slice 支持与 C++ 相同的预处理器指令，因此您可以使用 #include 和宏定义等指令。 但是，Slice 只允许在文件开头、任何 Slice 定义之前使用 #include 指令。</p>
<p>如果您使用 #include 指令，最好使用防护装置来保护它们，以防止文件的双重包含：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// File Clock.ice</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _CLOCK_ICE</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _CLOCK_ICE</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// #include directives here...</span></span><br><span class="line"><span class="comment">// Definitions here...</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> _CLOCK_ICE</span></span><br></pre></td></tr></table></figure>

<p>The following #pragma directive offers a simpler way to achieve the same result:</p>
<p>以下 #pragma 指令提供了一种更简单的方法来实现相同的结果：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// File Clock.ice</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// #include directives here...</span></span><br><span class="line"><span class="comment">// Definitions here...</span></span><br></pre></td></tr></table></figure>

<p>#include directives permit a Slice definition to use types defined in a different source file. The Slice compilers parse all of the code in a source file, including the code in subordinate #include files. However, the compilers generate code only for the top-level file(s) nominated on the command line. You must separately compile subordinate #include files to obtain generated code for all the files that make up your Slice definition.</p>
<p>Note that you should avoid #include with double quotes:</p>
<p>#include 指令允许 Slice 定义使用不同源文件中定义的类型。 Slice 编译器解析源文件中的所有代码，包括从属 #include 文件中的代码。 但是，编译器仅为命令行上指定的顶级文件生成代码。 您必须单独编译从属 #include 文件，以获得构成 Slice 定义的所有文件的生成代码。</p>
<p>请注意，您应该避免使用双引号#include：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Clock.ice&quot;</span> <span class="comment">// Not recommended!</span></span></span><br></pre></td></tr></table></figure>

<p>While double quotes will work, the directory in which the preprocessor tries to locate the file can vary depending on the operating system, so the included file may not always be found where you expect it. Instead, use angle brackets (&lt;&gt;); you can control which directories are searched for the file with the -I option of the Slice compiler.</p>
<p>Also note that, if you include a path separator in a #include directive, you must use a forward slash:</p>
<p>虽然双引号可以工作，但预处理器尝试在其中查找文件的目录可能会因操作系统而异，因此可能并不总是能在您期望的位置找到包含的文件。 相反，请使用尖括号 (&lt;&gt;)； 您可以使用 Slice 编译器的 -I 选项来控制在哪些目录中搜索文件。</p>
<p>另请注意，如果在 #include 指令中包含路径分隔符，则必须使用正斜杠：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;SliceDefs/Clock.ice&gt;</span>  <span class="comment">// OK</span></span></span><br></pre></td></tr></table></figure>

<p>You cannot use a backslash in #include directives:</p>
<p>您不能在 #include 指令中使用反斜杠：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;SliceDefs\Clock.ice&gt;</span>  <span class="comment">// Illegal</span></span></span><br></pre></td></tr></table></figure>

<p>Detecting Ice Versions<br>The Slice compilers define the preprocessor macro <strong>ICE_VERSION</strong> with a numeric representation of the Ice version. The value of this macro is the same as the C++ macro ICE_INT_VERSION. You can use this macro to make your Slice definitions backward-compatible with older Ice releases, while still taking advantage of newer Ice features when possible. For example, the Slice definition shown below makes use of custom enumerator values:</p>
<p>检测 Ice 版本<br>Slice 编译器使用 Ice 版本的数字表示来定义预处理器宏 <strong>ICE_VERSION</strong> 。 该宏的值与 C++ 宏 ICE_INT_VERSION 相同。 您可以使用此宏使您的 Slice 定义向后兼容较旧的 Ice 版本，同时尽可能利用较新的 Ice 功能。 例如，下面显示的 Slice 定义使用自定义枚举值：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">if</span> defined(__ICE_VERSION__) &amp;&amp; __ICE_VERSION__ &gt;= 030500</span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">Fruit</span> &#123; Apple, Pear = <span class="number">3</span>, Orange &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="keyword">enum</span> Fruit &#123; Apple, Pear, Orange &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>Although this example is intended to show how to use the ICE_VERSION macro, it also highlights a potential pitfall that you must be aware of when trying to maintain backward compatibility: the two definitions of Fruit are not wire-compatible. </p>
<p>尽管此示例旨在展示如何使用 ICE_VERSION 宏，但它也强调了在尝试保持向后兼容性时必须注意的潜在陷阱：Fruit 的两个定义不兼容。</p>
<p>Detecting Slice Compilers<br>Each Slice compiler defines its own macro so that you can customize your Slice code for certain language mappings. The macro name is <strong><compiler name in upper case></strong>, such as <strong>SLICE2CPP</strong> and <strong>SLICE2MATLAB</strong> for slice2cpp resp. slice2matlab.</p>
<p>检测Slice编译器<br>每个 Slice 编译器都定义自己的宏，以便您可以针对某些语言映射自定义 Slice 代码。 宏名称为 __&lt;大写的编译器名称&gt;__，例如 slice2cpp 的宏名称为 <strong>SLICE2CPP</strong> 和 __SLICE2MATLAB__。 slice2matlab。</p>
<p>For example, .NET developers may elect to avoid the use of default values for structure members because the presence of default values changes the C# mapping of the structure from struct to class:</p>
<p>例如，.NET 开发人员可能会选择避免对结构成员使用默认值，因为默认值的存在会更改结构从结构到类的 C# 映射：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Record</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> __SLICE2CS__</span></span><br><span class="line">    <span class="type">bool</span> active;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="type">bool</span> active = <span class="literal">true</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Definition Order<br>Slice constructs, such as modules, interfaces, or type definitions, can appear in any order you prefer. However, identifiers must be declared before they can be used.</p>
<p>定义顺序<br>Slice构造（例如模块、接口或类型定义）可以按您喜欢的任何顺序出现。 但是，标识符在使用之前必须先声明。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://qianqians.github.io/2023/11/22/ice_Slice_Compilation/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="qianqians">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="qianqians'blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/11/22/ice_Slice_Compilation/" class="post-title-link" itemprop="url">Slice Compilation</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2023-11-22 21:36:12 / 修改时间：21:52:05" itemprop="dateCreated datePublished" datetime="2023-11-22T21:36:12+08:00">2023-11-22</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/ice/" itemprop="url" rel="index"><span itemprop="name">ice</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>Slice Compilation</p>
<p>Compilation<br>A Slice compiler produces source files that must be combined with application code to produce client and server executables.</p>
<p>Slice 编译器生成的源文件必须与应用程序代码组合才能生成客户端和服务器可执行文件。</p>
<p>Single Development Environment for Client and Server</p>
<p>The figure below shows the situation when both client and server are developed in C++. The Slice compiler generates two files from a Slice definition in a source file Printer.ice: a header file (Printer.h) and a source file (Printer.cpp)</p>
<p>下图展示了客户端和服务器端均采用C++开发时的情况。 Slice 编译器根据源文件 Printer.ice 中的 Slice 定义生成两个文件：头文件 (Printer.h) 和源文件 (Printer.cpp)</p>
<p><img src="https://doc.zeroc.com/ice/files/3.7/14026220/25591829/1/1515168282000/Client_server_same_development_environment.gif" alt="Alt text"></p>
<p>Development process if client and server share the same development environment.</p>
<p>The Printer.h header file contains definitions that correspond to the types used in the Slice definition. It is included in the source code of both client and server to ensure that client and server agree about the types and interfaces used by the application.<br>The Printer.cpp source file provides an API to the client for sending messages to remote objects. The client source code (Client.cpp, written by the client developer) contains the client-side application logic. The generated source code and the client code are compiled and linked into the client executable.</p>
<p>客户端和服务器共享相同开发环境的开发流程。</p>
<p>Printer.h 头文件包含与 Slice 定义中使用的类型相对应的定义。 它包含在客户端和服务器的源代码中，以确保客户端和服务器就应用程序使用的类型和接口达成一致。<br>Printer.cpp 源文件向客户端提供 API，用于将消息发送到远程对象。 客户端源代码（Client.cpp，由客户端开发人员编写）包含客户端应用程序逻辑。 生成的源代码和客户端代码被编译并链接到客户端可执行文件中。</p>
<p>The Printer.cpp source file also contains source code that provides an up-call interface from the Ice run time into the server code written by the developer and provides the connection between the networking layer of Ice and the application code. The server implementation file (Server.cpp, written by the server developer) contains the server-side application logic (the object implementations, properly termed servants). The generated source code and the implementation source code are compiled and linked into the server executable.</p>
<p>Printer.cpp 源文件还包含源代码，该源代码提供从 Ice 运行时到开发人员编写的服务器代码的上行调用接口，并提供 Ice 网络层和应用程序代码之间的连接。 服务器实现文件（Server.cpp，由服务器开发人员编写）包含服务器端应用程序逻辑（对象实现，正确称为servants）。 生成的源代码和实现源代码被编译并链接到服务器可执行文件中。</p>
<p>Both client and server also link with an Ice library that provides the necessary run-time support.</p>
<p>客户端和服务器还与提供必要的运行时支持的 Ice 库链接。</p>
<p>You are not limited to a single implementation of a client or server. For example, you can build multiple servers, each of which implements the same interfaces but uses different implementations (for example, with different performance characteristics). Multiple such server implementations can coexist in the same system. This arrangement provides one fundamental scalability mechanism in Ice: if you find that a server process starts to bog down as the number of objects increases, you can run an additional server for the same interfaces on a different machine. Such federated servers provide a single logical service that is distributed over a number of processes on different machines. Each server in the federation implements the same interfaces but hosts different object instances. (Of course, federated servers must somehow ensure consistency of any databases they share across the federation.)</p>
<p>您不限于客户端或服务器的单一实现。 例如，您可以构建多个服务器，每个服务器都实现相同的接口，但使用不同的实现（例如，具有不同的性能特征）。 多个此类服务器实现可以共存于同一系统中。 这种安排在 Ice 中提供了一种基本的可扩展性机制：如果您发现服务器进程随着对象数量的增加而开始陷入困境，您可以为不同机器上的相同接口运行额外的服务器。 此类联合服务器提供分布在不同机器上的多个进程上的单一逻辑服务。 联合中的每个服务器都实现相同的接口，但托管不同的对象实例。 （当然，联合服务器必须以某种方式确保它们在联合中共享的任何数据库的一致性。）</p>
<p>Ice also provides support for replicated servers. Replication permits multiple servers to each implement the same set of object instances. This improves performance and scalability (because client load can be shared over a number of servers) as well as redundancy (because each object is implemented in more than one server).</p>
<p>Ice 还提供对复制服务器的支持。 复制允许多个服务器各自实现同一组对象实例。 这提高了性能和可伸缩性（因为客户端负载可以在多个服务器上共享）以及冗余（因为每个对象都在多个服务器中实现）。</p>
<p>Different Development Environments for Client and Server</p>
<p>Client and server cannot share any source or binary components if they are developed in different languages. For example, a client written in Java cannot include a C++ header file.</p>
<p>如果客户端和服务器使用不同语言开发，则不能共享任何源代码或二进制组件。 例如，用 Java 编写的客户端不能包含 C++ 头文件。</p>
<p>This figure shows the situation when a client written in Java and the corresponding server is written in C++. In this case, the client and server developers are completely independent, and each uses his or her own development environment and language mapping. The only link between client and server developers is the Slice definition each one uses.</p>
<p>该图显示了当客户端用Java编写而相应的服务器用C++编写时的情况。 在这种情况下，客户端和服务器开发人员是完全独立的，并且各自使用自己的开发环境和语言映射。 客户端和服务器开发人员之间的唯一联系是各自使用的 Slice 定义。</p>
<p><img src="https://doc.zeroc.com/ice/files/3.7/14026220/25591831/1/1515168283000/Development_process_different_development_environment.gif" alt="Alt text"></p>
<p>Development process for different development environments.</p>
<p>For Java, the slice compiler creates a number of files whose names depend on the names of various Slice constructs. (These files are collectively referred to as *.java in the above figure.)</p>
<p>针对不同开发环境的开发流程。</p>
<p>对于 Java，slice编译器创建许多文件，其名称取决于各种 Slice 构造的名称。 （这些文件在上图中统称为*.java。）</p>
<p>Slice Compilation and your Build Environment</p>
<p>One way to integrate Slice compilation in your build system is to compile your Slice files manually, and then keep (check-in) the generated files like other source files. Later on, each time you change a Slice file, you have to remember to recompile this Slice file and update the generated files. While simple, this approach can lead to inconsistencies and bugs if you forget to recompile a modified Slice file.</p>
<p>将 Slice 编译集成到构建系统中的一种方法是手动编译 Slice 文件，然后像其他源文件一样保留（签入）生成的文件。 以后，每次更改 Slice 文件时，都必须记住重新编译该 Slice 文件并更新生成的文件。 虽然简单，但如果您忘记重新编译修改后的 Slice 文件，这种方法可能会导致不一致和错误。</p>
<p>We recommend you use instead an Ice Builder for your build environment to manage the compilation of your Slice files. An Ice Builder is a simple plug-in or task for your build environment that compiles or recompiles Slice files when it detects the corresponding generated files are missing or out of date. A Builder performs this Slice compilation by invoking the Slice compiler for the target programming language–it does compile the files itself and usually supports several versions of Ice.</p>
<p>我们建议您在构建环境中使用 Ice Builder 来管理 Slice 文件的编译。 Ice Builder 是一个适用于构建环境的简单插件或任务，当它检测到相应的生成文件丢失或过期时，它会编译或重新编译 Slice 文件。 Builder 通过调用目标编程语言的 Slice 编译器来执行此 Slice 编译 - 它本身会编译文件，并且通常支持多个版本的 Ice。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">qianqians</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>

<script src="/js/bookmark.js"></script>




  















  

  

</body>
</html>
