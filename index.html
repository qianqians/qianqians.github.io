<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">
  <link rel="manifest" href="/images/manifest.json">
  <meta name="msapplication-config" content="/images/browserconfig.xml">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">
<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"qianqians.github.io","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"remove","padding":18,"offset":12,"onmobile":true},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":true,"scrollpercent":true},"bookmark":{"enable":true,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="qianqians&#39;blog">
<meta property="og:url" content="https://qianqians.github.io/index.html">
<meta property="og:site_name" content="qianqians&#39;blog">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="qianqians">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://qianqians.github.io/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>qianqians'blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">qianqians'blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档<span class="badge">41</span></a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>分类<span class="badge">9</span></a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-fw fa-user"></i>关于</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <a role="button" class="book-mark-link book-mark-link-fixed"></a>

  <a href="https://github.com/qianqians" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://qianqians.github.io/2024/04/06/ice_Constants_and_Literals/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="qianqians">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="qianqians'blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/04/06/ice_Constants_and_Literals/" class="post-title-link" itemprop="url">Constants and Literals</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2024-04-06 18:44:04 / 修改时间：20:28:22" itemprop="dateCreated datePublished" datetime="2024-04-06T18:44:04+08:00">2024-04-06</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/ice/" itemprop="url" rel="index"><span itemprop="name">ice</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>Allowable Types for Constants<br>常量允许的类型</p>
<p>Slice allows you to define constants for the following types:</p>
<p>An integral type (bool, byte, short, int, long)<br>A floating point type (float or double)<br>string<br>enum</p>
<p>Slice 允许定义以下类型的常量：<br>整型（bool、byte、short、int、long）<br>浮点类型（float 或 double）<br>字符串<br>枚举</p>
<p>Here are a few examples:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> M</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">bool</span>      AppendByDefault = <span class="literal">true</span>;</span><br><span class="line">    <span class="type">const</span> byte      LowerNibble = <span class="number">0x0f</span>;</span><br><span class="line">    <span class="type">const</span> string    Advice = <span class="string">&quot;Don&#x27;t Panic!&quot;</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">short</span>     TheAnswer = <span class="number">42</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">double</span>    PI = <span class="number">3.1416</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">enum</span> <span class="title class_">Fruit</span> &#123; Apple, Pear, Orange &#125;</span><br><span class="line">    <span class="type">const</span> Fruit     FavoriteFruit = Pear;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>The syntax for literals is the same as for C++ and Java (with a few minor exceptions).<br>文字的语法与 C++ 和 Java 相同（有一些小例外）。</p>
<p>Boolean constants<br>Boolean constants can only be initialized with the keywords false and true. (You cannot use 0 and 1 to represent false and true.)<br>布尔常量只能使用关键字 false 和 true 进行初始化。 （不能用 0 和 1 来表示 false 和 true。）</p>
<p>Integer literals<br>Integer literals can be specified in decimal, octal, or hexadecimal notation.<br>整数可以用十进制、八进制或十六进制表示法指定。</p>
<p>For example:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> byte TheAnswer = <span class="number">42</span>;</span><br><span class="line"><span class="type">const</span> byte TheAnswerInOctal = <span class="number">052</span>;</span><br><span class="line"><span class="type">const</span> byte TheAnswerInHex = <span class="number">0x2A</span>;       </span><br></pre></td></tr></table></figure>

<p>Be aware that, if you interpret byte as a number instead of a bit pattern, you may get different results in different languages. For example, for C++, byte maps to unsigned char whereas, for Java, byte maps to byte, which is a signed type.</p>
<p>Note that suffixes to indicate long and unsigned constants (l, L, u, U, used by C++) are illegal:</p>
<p>请注意，如果将字节解释为数字而不是位模式，则在不同语言中可能会得到不同的结果。 例如，对于 C++，字节映射到 unsigned char，而对于 Java，字节映射到 byte，这是一种有符号类型。<br>请注意，表示长整型和无符号常量（C++ 使用的 l、L、u、U）的后缀是非法的：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">long</span> Wrong = <span class="number">0u</span>;          <span class="comment">// Syntax error</span></span><br><span class="line"><span class="type">const</span> <span class="type">long</span> WrongToo = <span class="number">1000000L</span>; <span class="comment">// Syntax error</span></span><br></pre></td></tr></table></figure>

<p>The value of an integer literal must be within the range of its constant type, as shown in the Built-In Basic Types table; otherwise the compiler will issue a diagnostic.<br>整数的值必须在其常量类型的范围内，如内置基本类型表所示； 否则编译器将发出诊断信息。</p>
<p>Floating-point literals<br>Floating-point literals use C++ syntax, except that you cannot use an l or L suffix to indicate an extended floating-point constant; however, f and F are legal (but are ignored).<br>浮点文字使用 C++ 语法，但不能使用 l 或 L 后缀来指示扩展浮点常量； 然而，f 和 F 是合法的（但被忽略）。<br>Here are a few examples:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">float</span> P1 = <span class="number">-3.14f</span>;    <span class="comment">// Integer &amp; fraction, with suffix</span></span><br><span class="line"><span class="type">const</span> <span class="type">float</span> P2 = +<span class="number">3.1e-3</span>;   <span class="comment">// Integer, fraction, and exponent</span></span><br><span class="line"><span class="type">const</span> <span class="type">float</span> P3 = <span class="number">.1</span>;        <span class="comment">// Fraction part only</span></span><br><span class="line"><span class="type">const</span> <span class="type">float</span> P4 = <span class="number">1.</span>;        <span class="comment">// Integer part only</span></span><br><span class="line"><span class="type">const</span> <span class="type">float</span> P5 = <span class="number">.9E5</span>;      <span class="comment">// Fraction part and exponent</span></span><br><span class="line"><span class="type">const</span> <span class="type">float</span> P6 = <span class="number">5e2</span>;       <span class="comment">// Integer part and exponent</span></span><br></pre></td></tr></table></figure>

<p>Floating-point literals must be within the range of the constant type (float or double); otherwise, the compiler will issue a diagnostic.<br>浮点变量必须在常量类型（float 或 double）的范围内； 否则，编译器将发出诊断信息。</p>
<p>String literals<br>Slice string literals support the same escape sequences as C++, with the exception of hexadecimal escape sequences that are limited to two hexadecimal digits.<br>Slice字符串变量支持与 C++ 相同的转义序列，但十六进制转义序列除外，该序列仅限于两个十六进制数字。</p>
<table>
<thead>
<tr>
<th align="left">Escape Sequence</th>
<th align="left">Name</th>
<th align="left">Corresponding ASCII or Unicode Code Point</th>
<th align="left">Notes</th>
</tr>
</thead>
<tbody><tr>
<td align="left">\&#39;</td>
<td align="left">single quote</td>
<td align="left">0x27</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">\&quot;</td>
<td align="left">double quote</td>
<td align="left">0x22</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">\?</td>
<td align="left">question mark</td>
<td align="left">0x3f</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">\\</td>
<td align="left">backslash</td>
<td align="left">0x5c</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">\\a</td>
<td align="left">audible bell</td>
<td align="left">0x07</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">\\b</td>
<td align="left">backspace</td>
<td align="left">0x08</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">\\f</td>
<td align="left">form feed</td>
<td align="left">0x0c</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">\\n</td>
<td align="left">line feed</td>
<td align="left">0x0a</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">\\r</td>
<td align="left">carriage return</td>
<td align="left">0x0d</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">\\t</td>
<td align="left">horizontal tab</td>
<td align="left">0x09</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">\\v</td>
<td align="left">vertical tab</td>
<td align="left">0x0b</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">\\nnn</td>
<td align="left">octal escape sequence</td>
<td align="left"></td>
<td align="left">1 to 3 octal digits (0-7) that represent a byte value between 0 and 255</td>
</tr>
<tr>
<td align="left">\\xnn</td>
<td align="left">hexadecimal escape sequence</td>
<td align="left"></td>
<td align="left">1 to 2 hexadecimal digits (0-9, a-f, A-F)</td>
</tr>
<tr>
<td align="left">\\unnnn</td>
<td align="left">universal character name</td>
<td align="left">U+nnnn</td>
<td align="left">Exactly 4 hexadecimal digits. Use the \Unnnnnnnn notation for astral characters.</td>
</tr>
<tr>
<td align="left">\\Unnnnnnnn</td>
<td align="left">universal character name</td>
<td align="left">U+nnnnnnnn Exactly 8 hexadecimal digits.</td>
<td align="left"></td>
</tr>
</tbody></table>
<p>A backslash () followed by another character is simply preserved as is.</p>
<p>Octal and hexadecimal escape sequences can represent ASCII characters (ordinal value 0 to 127) or the UTF-8 encoding of non-ASCII characters.</p>
<p>A string literal can contain printable ASCII characters (including the escape sequences presented above) and non-ASCII characters; non-printable ASCII characters (such as an unescaped tab) are not allowed.</p>
<p>反斜杠 () 后跟另一个字符将按原样保留。<br>八进制和十六进制转义序列可以表示 ASCII 字符（序数值 0 到 127）或非 ASCII 字符的 UTF-8 编码。<br>字符串文字可以包含可打印的 ASCII 字符（包括上面介绍的转义序列）和非 ASCII 字符； 不允许使用不可打印的 ASCII 字符（例如未转义的制表符）。</p>
<p>Here are some examples:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> string AnOrdinaryString = <span class="string">&quot;Hello World!&quot;</span>;</span><br><span class="line"> </span><br><span class="line"><span class="type">const</span> string DoubleQuote =      <span class="string">&quot;\&quot;&quot;</span>;</span><br><span class="line"><span class="type">const</span> string TwoSingleQuotes =  <span class="string">&quot;&#x27;\&#x27;&quot;</span>;     <span class="comment">// &#x27; and \&#x27; are OK</span></span><br><span class="line"><span class="type">const</span> string QuestionMark =     <span class="string">&quot;\?&quot;</span>;</span><br><span class="line"><span class="type">const</span> string Backslash =        <span class="string">&quot;\\&quot;</span>;</span><br><span class="line"><span class="type">const</span> string AudibleBell =      <span class="string">&quot;\a&quot;</span>;</span><br><span class="line"><span class="type">const</span> string Backspace =        <span class="string">&quot;\b&quot;</span>;</span><br><span class="line"><span class="type">const</span> string FormFeed =         <span class="string">&quot;\f&quot;</span>;</span><br><span class="line"><span class="type">const</span> string Newline =          <span class="string">&quot;\n&quot;</span>;</span><br><span class="line"><span class="type">const</span> string CarriageReturn =   <span class="string">&quot;\r&quot;</span>;</span><br><span class="line"><span class="type">const</span> string HorizontalTab =    <span class="string">&quot;\t&quot;</span>;</span><br><span class="line"><span class="type">const</span> string VerticalTab =      <span class="string">&quot;\v&quot;</span>;</span><br><span class="line"> </span><br><span class="line"><span class="type">const</span> string OctalEscape =    <span class="string">&quot;\007&quot;</span>;     <span class="comment">// Same as \a</span></span><br><span class="line"><span class="type">const</span> string HexEscape1  =    <span class="string">&quot;\x07&quot;</span>;     <span class="comment">// Ditto</span></span><br><span class="line"><span class="type">const</span> string HexEscape2 =     <span class="string">&quot;\x41F&quot;</span>;    <span class="comment">// Same as AF</span></span><br><span class="line"><span class="type">const</span> string Universal1 =     <span class="string">&quot;\u0041&quot;</span>;   <span class="comment">// Same as A</span></span><br><span class="line"><span class="type">const</span> string Universal2 = <span class="string">&quot;\U00000041&quot;</span>;   <span class="comment">// Ditto</span></span><br><span class="line">  </span><br><span class="line"><span class="type">const</span> string EuroSign1 =           <span class="string">&quot;€&quot;</span>;   <span class="comment">// Euro sign (U+20AC)</span></span><br><span class="line"><span class="type">const</span> string EuroSign2 =      <span class="string">&quot;\u20AC&quot;</span>;   <span class="comment">// Euro sign as a short universal character name</span></span><br><span class="line"><span class="type">const</span> string EuroSign3 =  <span class="string">&quot;\U000020ac&quot;</span>;   <span class="comment">// Euro sign as a long universal character name</span></span><br><span class="line"><span class="type">const</span> string EuroSign4 = <span class="string">&quot;\xe2\x82\xAC&quot;</span>;  <span class="comment">// Euro sign in UTF-8 encoding, using hex escape sequences</span></span><br><span class="line"><span class="type">const</span> string EuroSign5 = <span class="string">&quot;\342\202\254&quot;</span>;  <span class="comment">// Euro sign in UTF-8 encoding, using octal escape sequences</span></span><br><span class="line"><span class="type">const</span> string EuroSign6 = <span class="string">&quot;\342\x82\254&quot;</span>;  <span class="comment">// Euro sign in UTF-8 encoding, using a mix or hex and octal escape sequences</span></span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> string NullString = null;    <span class="comment">// Illegal!</span></span><br></pre></td></tr></table></figure>

<p>Null strings simply do not exist in Slice and, therefore, do not exist as a legal value for a string anywhere in the Ice platform. The reason for this decision is that null strings do not exist in many programming languages.<br>空字符串根本不存在于 Slice 中，因此在 Ice 平台中的任何位置都不作为字符串的合法值存在。 做出此决定的原因是许多编程语言中不存在空字符串。</p>
<p>Constant Expressions<br>A constant definition may also refer to another constant. It is not necessary for both constants to have the same Slice type, but the value of the existing constant must be compatible with the type of the constant being defined.</p>
<p>常量定义也可以引用另一个常量。 两个常量不必具有相同的 Slice 类型，但现有常量的值必须与正在定义的常量的类型兼容。</p>
<p>Consider the examples below:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> SIZE = <span class="number">500</span>;</span><br><span class="line"> </span><br><span class="line"><span class="type">const</span> <span class="type">int</span> DEFAULT_SIZE = SIZE; <span class="comment">// OK</span></span><br><span class="line"><span class="type">const</span> <span class="type">short</span> SHORT_SIZE = SIZE; <span class="comment">// OK</span></span><br><span class="line"><span class="type">const</span> byte BYTE_SIZE = SIZE;   <span class="comment">// ERROR</span></span><br></pre></td></tr></table></figure>

<p>The DEFAULT_SIZE constant is legal because it has the same type as SIZE, and SHORT_SIZE is legal because the value of SIZE (500) is within the range of the Slice short type. However, BYTE_SIZE is illegal because the value of SIZE is outside the range of the byte type.<br>DEFAULT_SIZE 常量是合法的，因为它与 SIZE 具有相同的类型，SHORT_SIZE 是合法的，因为 SIZE (500) 的值在 Slice Short 类型的范围内。 但是，BYTE_SIZE 是非法的，因为 SIZE 的值超出了字节类型的范围。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://qianqians.github.io/2024/02/16/rust_icon/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="qianqians">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="qianqians'blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/02/16/rust_icon/" class="post-title-link" itemprop="url">Rust窗口图标</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-02-16 20:43:24" itemprop="dateCreated datePublished" datetime="2024-02-16T20:43:24+08:00">2024-02-16</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-02-17 21:01:43" itemprop="dateModified" datetime="2024-02-17T21:01:43+08:00">2024-02-17</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Rust/" itemprop="url" rel="index"><span itemprop="name">Rust</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><a target="_blank" rel="noopener" href="https://anthropicstudios.com/2021/01/05/setting-a-rust-windows-exe-icon">https://anthropicstudios.com/2021/01/05/setting-a-rust-windows-exe-icon</a></p>
<p><a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/1277512/icon-is-not-in-3-00-format">https://stackoverflow.com/questions/1277512/icon-is-not-in-3-00-format</a></p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/366341784">https://zhuanlan.zhihu.com/p/366341784</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://qianqians.github.io/2024/01/28/pyo3-asyncio/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="qianqians">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="qianqians'blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/01/28/pyo3-asyncio/" class="post-title-link" itemprop="url">python Rust互相调用</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-01-28 19:26:19" itemprop="dateCreated datePublished" datetime="2024-01-28T19:26:19+08:00">2024-01-28</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-02-17 21:01:50" itemprop="dateModified" datetime="2024-02-17T21:01:50+08:00">2024-02-17</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Rust/" itemprop="url" rel="index"><span itemprop="name">Rust</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/python/" itemprop="url" rel="index"><span itemprop="name">python</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/pyo3-asyncio/" itemprop="url" rel="index"><span itemprop="name">pyo3-asyncio</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">future</span> = Python::<span class="title function_ invoke__">with_gil</span>(|py| &#123;</span><br><span class="line">    <span class="comment">// import the module containing the py_sleep function</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">example</span> = py.<span class="title function_ invoke__">import</span>(<span class="string">&quot;example&quot;</span>)?;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// calling the py_sleep method like a normal function returns a coroutine</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">coroutine</span> = example.<span class="title function_ invoke__">call_method0</span>(<span class="string">&quot;py_sleep&quot;</span>)?;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// convert the coroutine into a Rust future</span></span><br><span class="line">    pyo3_asyncio::<span class="title function_ invoke__">into_future</span>(coroutine)</span><br><span class="line">&#125;)?;</span><br><span class="line"></span><br><span class="line"><span class="comment">// await the future</span></span><br><span class="line">future.<span class="keyword">await</span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[pyfunction]</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">call_rust_sleep</span>(py: Python) <span class="punctuation">-&gt;</span> PyResult&lt;PyObject&gt; &#123;</span><br><span class="line">    pyo3_asyncio::async_std::<span class="title function_ invoke__">into_coroutine</span>(py, <span class="keyword">async</span> <span class="keyword">move</span> &#123;</span><br><span class="line">        <span class="title function_ invoke__">rust_sleep</span>().<span class="keyword">await</span>;</span><br><span class="line">        <span class="title function_ invoke__">Ok</span>(())</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">pyo3_asyncio::tokio::<span class="title function_ invoke__">future_into_py</span>(py, <span class="keyword">async</span> <span class="keyword">move</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">_server_handle</span> = _server.<span class="title function_ invoke__">as_ref</span>().<span class="title function_ invoke__">lock</span>().<span class="keyword">await</span>;</span><br><span class="line">    _server_handle.<span class="title function_ invoke__">entry_direct_hub_server</span>(hub_name).<span class="keyword">await</span>;</span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(())</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://qianqians.github.io/2024/01/25/ice_Dictionaries/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="qianqians">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="qianqians'blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/01/25/ice_Dictionaries/" class="post-title-link" itemprop="url">Dictionaries</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2024-01-25 22:41:09 / 修改时间：22:50:32" itemprop="dateCreated datePublished" datetime="2024-01-25T22:41:09+08:00">2024-01-25</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/ice/" itemprop="url" rel="index"><span itemprop="name">ice</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>Dictionary Syntax and Semantics</p>
<p>A dictionary is a mapping from a key type to a value type.</p>
<p>dictionary是从键类型到值类型的映射</p>
<p>For example:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> M</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Employee</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">long</span>   number;</span><br><span class="line">        string firstName;</span><br><span class="line">        string lastName;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    dictionary&lt;<span class="type">long</span>, Employee&gt; EmployeeMap;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>This definition creates a dictionary named EmployeeMap that maps from an employee number to a structure containing the details for an employee. Whether or not the key type (the employee number, of type long in this example) is also part of the value type (the Employee structure in this example) is up to you — as far as Slice is concerned, there is no need to include the key as part of the value.</p>
<p>此定义创建一个名为 EmployeeMap 的dictionary，该dictionary从员工编号映射到包含员工详细信息的结构。 键类型（员工编号，本例中为 long 类型）是否也是值类型（本例中为 Employee 结构）的一部分取决于您 — 就 Slice 而言，不需要 包含键作为值的一部分。</p>
<p>Dictionaries can be used to implement sparse arrays, or any lookup data structure with non-integral key type. Even though a sequence of structures containing key-value pairs could be used to model the same thing, a dictionary is more appropriate:</p>
<p>dictionary可用于实现稀疏数组或任何具有非整数键类型的查找数据结构。 尽管包含键值对的结构序列可用于对同一事物进行建模，但dictionary更合适：</p>
<p>A dictionary clearly signals the intent of the designer, namely, to provide a mapping from a domain of values to a range of values. (A sequence of structures of key-value pairs does not signal that same intent as clearly.)</p>
<p>dictionary清楚地表明了设计者的意图，即提供从值域到值范围的映射。 （键值对结构的sequence并不能清楚地表明相同的意图。）</p>
<p>At the programming language level, sequences are implemented as vectors (or possibly lists), that is, they are not well suited to model sparsely populated domains and require a linear search to locate an element with a particular value. On the other hand, dictionaries are implemented as a data structure (typically a hash table or red-black tree) that supports efficient searching in O(log n) average time or better.</p>
<p>在编程语言级别，sequences被实现为数组（或可能是list），也就是说，它们不太适合对稀疏填充的域进行建模，并且需要线性搜索来定位具有特定值的元素。 另一方面，dictionary被实现为另一种数据结构（通常是哈希表或红黑树），支持平均时间为 O(log n) 或更好的高效搜索。</p>
<p>Allowable Types for Dictionary Keys and Values</p>
<p>The key type of a dictionary need not be an integral type. For example, we could use the following definition to translate the names of the days of the week:</p>
<p>dictionary的键类型不必是整型。 例如，我们可以使用以下定义来翻译一周中各天的名称：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dictionary&lt;string, string&gt; WeekdaysEnglishToGerman;</span><br></pre></td></tr></table></figure>

<p>The server implementation would take care of initializing this map with the key-value pairs Monday-Montag, Tuesday-Dienstag, and so on.</p>
<p>服务器实现将负责使用键值对 Monday-Montag、Tuesday-Dienstag 等初始化该映射。</p>
<p>The value type of a dictionary can be any Slice type. However, the key type of a dictionary is limited to one of the following types:</p>
<p>dictionary的值类型可以是任何 Slice 类型。 但是，字典的键类型仅限于以下类型之一：</p>
<p>Integral types (short, int, long)<br>bool<br>byte<br>string<br>enum<br>Structures containing only data members of legal key types</p>
<p>Other complex types, such as dictionaries, and floating-point types (float and double) cannot be used as the key type. Complex types are disallowed because they complicate the language mappings for dictionaries, and floating-point types are disallowed because representational changes of values as they cross machine boundaries can lead to ill-defined semantics for equality.</p>
<p>其他复杂类型，例如dictionary和浮点类型（float 和 double）不能用作键类型。 不允许使用复杂类型，因为它们使dictionary的语言映射变得复杂；并且不允许使用浮点类型，因为跨机器边界时值的表示变化可能会导致平等语义定义不明确。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://qianqians.github.io/2024/01/24/ice_Sequences/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="qianqians">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="qianqians'blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/01/24/ice_Sequences/" class="post-title-link" itemprop="url">Sequences</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2024-01-24 22:39:43 / 修改时间：22:44:06" itemprop="dateCreated datePublished" datetime="2024-01-24T22:39:43+08:00">2024-01-24</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/ice/" itemprop="url" rel="index"><span itemprop="name">ice</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>Sequences are variable-length collections of elements:</p>
<p>Sequences是可变长度的元素集合：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> M</span><br><span class="line">&#123;</span><br><span class="line">    sequence&lt;Fruit&gt; FruitPlatter;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>A sequence can be empty — that is, it can contain no elements, or it can hold any number of elements up to the memory limits of your platform.</p>
<p>Sequences can contain elements that are themselves sequences. This arrangement allows you to create lists of lists:</p>
<p>sequence可以是空的，即不包含任何元素，也可以包含任意数量的元素，但不得超过平台的内存限制。</p>
<p>sequence可以包含本身就是sequence的元素。通过这种安排，您可以创建列表的列表：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> M</span><br><span class="line">&#123;</span><br><span class="line">    sequence&lt;FruitPlatter&gt; FruitBanquet;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Sequences are used to model a variety of collections, such as vectors, lists, queues, sets, bags, or trees. (It is up to the application to decide whether or not order is important; by discarding order, a sequence serves as a set or bag.)</p>
<p>Sequences用于对各种集合建模，例如向量、列表、队列、集合、包或树。 （由应用程序决定顺序是否重要；通过丢弃顺序，Sequences充当集合或包。）</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://qianqians.github.io/2024/01/03/ice_Structures/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="qianqians">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="qianqians'blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/01/03/ice_Structures/" class="post-title-link" itemprop="url">Structures</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2024-01-03 23:13:38 / 修改时间：23:21:10" itemprop="dateCreated datePublished" datetime="2024-01-03T23:13:38+08:00">2024-01-03</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/ice/" itemprop="url" rel="index"><span itemprop="name">ice</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>Slice supports structures containing one or more named members of arbitrary type, including user-defined complex types. For example:</p>
<p>Slice 支持包含一个或多个任意类型的命名成员的结构，包括用户定义的复杂类型。 例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> M</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">TimeOfDay</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">short</span> hour;         <span class="comment">// 0 - 23</span></span><br><span class="line">        <span class="type">short</span> minute;       <span class="comment">// 0 - 59</span></span><br><span class="line">        <span class="type">short</span> second;       <span class="comment">// 0 - 59</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>As in C++, this definition introduces a new type called TimeOfDay. Structure definitions form a namespace, so the names of the structure members need to be unique only within their enclosing structure.</p>
<p>Data member definitions using a named type are the only construct that can appear inside a structure. It is impossible to, for example, define a structure inside a structure:</p>
<p>与 C++ 中一样，此定义引入了一种称为 TimeOfDay 的新类型。 结构定义形成命名空间，因此结构成员的名称仅在其封闭结构内必须是唯一的。</p>
<p>使用确定类型的数据成员定义是唯一可以出现在结构内部的构造。 例如，不可能在结构内定义结构：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">TwoPoints</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Point</span>      <span class="comment">// 非法!</span></span><br><span class="line">    &#123;            </span><br><span class="line">        <span class="type">short</span> x;</span><br><span class="line">        <span class="type">short</span> y;</span><br><span class="line">    &#125;</span><br><span class="line">    Point coord1;</span><br><span class="line">    Point coord2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>This rule applies to Slice in general: type definitions cannot be nested (except for modules, which do support nesting). The reason for this rule is that nested type definitions can be difficult to implement for some target languages and, even if implementable, greatly complicate the scope resolution rules. For a specification language, such as Slice, nested type definitions are unnecessary – you can always write the above definitions as follows (which is stylistically cleaner as well):</p>
<p>此规则一般适用于 Slice：类型定义不能嵌套（模块除外，模块支持嵌套）。 此规则的原因是嵌套类型定义对于某些目标语言可能难以实现，并且即使可以实现，也会使范围解析规则变得非常复杂。 对于规范语言，例如 Slice，嵌套类型定义是不必要的 - 您始终可以按如下方式编写上述定义（这在风格上也更清晰）：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Point</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">short</span> x;</span><br><span class="line">    <span class="type">short</span> y;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">TwoPoints</span>      <span class="comment">// Legal (and cleaner!)</span></span><br><span class="line">&#123;   </span><br><span class="line">    Point coord1;</span><br><span class="line">    Point coord2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>You can specify a default value for a data member that has one of the following types:</p>
<p>您可以为具有以下类型之一的数据成员指定默认值：</p>
<ol>
<li>An integral type (byte, short, int, long)</li>
<li>A floating point type (float or double)</li>
<li>string</li>
<li>bool</li>
<li>enum</li>
</ol>
<p>For example:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Location</span></span><br><span class="line">&#123;</span><br><span class="line">    string name;</span><br><span class="line">    Point pt;</span><br><span class="line">    <span class="type">bool</span> display = <span class="literal">true</span>;</span><br><span class="line">    string source = <span class="string">&quot;GPS&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>The legal syntax for literal values is the same as for Slice constants, and you may also use a constant as a default value. The language mapping guarantees that data members are initialized to their declared default values using a language-specific mechanism.</p>
<p>字符值的合法语法与 Slice 常量相同，您也可以使用常量作为默认值。 语言映射保证使用特定于语言的机制将数据成员初始化为其声明的默认值。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://qianqians.github.io/2023/12/11/ice_Enumerations/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="qianqians">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="qianqians'blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/12/11/ice_Enumerations/" class="post-title-link" itemprop="url">Enumerations</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2023-12-11 23:01:14 / 修改时间：23:07:26" itemprop="dateCreated datePublished" datetime="2023-12-11T23:01:14+08:00">2023-12-11</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/ice/" itemprop="url" rel="index"><span itemprop="name">ice</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>Enumeration Syntax and Semantics</p>
<p>Slice 枚举类型定义看起来与 C++ 相同：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> M</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">enum</span> <span class="title class_">Fruit</span> &#123; Apple, Pear, Orange &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>This definition introduces a type named Fruit that becomes a new type in its own right. Slice guarantees that the values of enumerators increase from left to right, so Apple compares less than Pear in every language mapping. By default, the first enumerator has a value of zero, with sequentially increasing values for subsequent enumerators.</p>
<p>A Slice enum type introduces a new namespace scope, so the following is legal:</p>
<p>这个定义引入了一个名为 Fruit 的类型，它本身就成为一种新类型。 Slice 保证枚举数的值从左到右递增，因此 Apple 在每种语言映射中都比 Pear 进行比较。 默认情况下，第一个枚举数的值为零，后续枚举数的值依次增加。</p>
<p>Slice 枚举类型引入了新的命名空间范围，因此以下内容是合法的：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> M</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">enum</span> <span class="title class_">Fruit</span> &#123; Apple, Pear, Orange &#125;</span><br><span class="line">    <span class="keyword">enum</span> <span class="title class_">ComputerBrands</span> &#123; Apple, Dell, HP, Lenovo &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>The example below shows how to refer to an enumerator from a different scope:</p>
<p>下面的示例展示了如何从不同的范围引用枚举：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> M</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">enum</span> <span class="title class_">Color</span> &#123; Red, Green, Blue &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">module</span> N</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Pixel</span></span><br><span class="line">    &#123;</span><br><span class="line">        M::Color c = Blue;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Slice does not permit empty enumerations.</p>
<p>Slice 不允许空枚举。</p>
<p>In Ice releases prior to Ice 3.7, an enum type did not create a new namespace and its enumerators were in the same namespace as the enum type itself. With these releases, you had to select longer enumerator names to avoid a naming clash.</p>
<p>在 Ice 3.7 之前的 Ice 版本中，枚举类型不会创建新的命名空间，并且其枚举器与枚举类型本身位于同一命名空间中。 在这些版本中，您必须选择更长的枚举器名称以避免命名冲突。</p>
<p>Custom Enumerator Values</p>
<p>Slice also permits you to assign custom values to enumerators:</p>
<p>Slice 还允许您为枚举器分配自定义值：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> PearValue = <span class="number">7</span>;</span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">Fruit</span> &#123; Apple = <span class="number">0</span>, Pear = PearValue, Orange &#125;</span><br></pre></td></tr></table></figure>

<p>Custom values must be unique and non-negative, and may refer to Slice constants of integer types. If no custom value is specified for an enumerator, its value is one greater than the enumerator that immediately precedes it. In the example above, Orange has the value 8.</p>
<p>The maximum value for an enumerator value is the same as the maximum value for int, 2 31 - 1.</p>
<p>Slice does not require custom enumerator values to be declared in increasing order:</p>
<p>自定义值必须是唯一且非负的，并且可以引用整数类型的 Slice 常量。 如果没有为枚举器指定自定义值，则其值比紧邻其前面的枚举器大 1。 在上面的示例中，Orange的值为 8。</p>
<p>枚举值的最大值与 int 的最大值相同，即 2^31 - 1。</p>
<p>Slice 不需要按升序声明自定义枚举值：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Fruit</span> &#123; Apple = <span class="number">5</span>, Pear = <span class="number">3</span>, Orange = <span class="number">1</span> &#125;   <span class="comment">// 合法的</span></span><br></pre></td></tr></table></figure>

<p>Note however that when there is an inconsistency between the declaration order and the numerical order of the enumerators, the behavior of comparison operations may vary between language mappings.</p>
<p>但请注意，当声明顺序与枚举数的数字顺序不一致时，比较操作的行为可能会因语言映射而异。</p>
<p>For an application that is still using version 1.0 of the Ice encoding, changing the definition of an enumerated type may break backward compatibility with existing applications. For more information, please refer to the encoding rules for enumerators.</p>
<p>对于仍在使用 Ice 编码 1.0 版的应用程序，更改枚举类型的定义可能会破坏与现有应用程序的向后兼容性。 更多信息请参考枚举数的编码规则。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://qianqians.github.io/2023/12/06/ice_Basic_Types/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="qianqians">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="qianqians'blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/12/06/ice_Basic_Types/" class="post-title-link" itemprop="url">Basic Types</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2023-12-06 21:27:32 / 修改时间：21:39:04" itemprop="dateCreated datePublished" datetime="2023-12-06T21:27:32+08:00">2023-12-06</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/ice/" itemprop="url" rel="index"><span itemprop="name">ice</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>Basic Types</p>
<p>Built-In Basic Types<br>Slice provides a number of built-in basic types, as shown in this table:</p>
<p>内置基本类型<br>Slice 提供了许多内置的基本类型，如下表所示：</p>
<table>
<thead>
<tr>
<th align="center">Type</th>
<th align="center">Range of Mapped Type</th>
<th align="center">Size of Mapped Type</th>
</tr>
</thead>
<tbody><tr>
<td align="center">bool</td>
<td align="center">false or true</td>
<td align="center">≥ 1bit</td>
</tr>
<tr>
<td align="center">byte</td>
<td align="center">-128-127 or 0-255</td>
<td align="center">≥ 8 bits</td>
</tr>
<tr>
<td align="center">short</td>
<td align="center">-2^15 to 2^15 -1</td>
<td align="center">≥ 16 bits</td>
</tr>
<tr>
<td align="center">int</td>
<td align="center">-2^31 to 2^31 -1</td>
<td align="center">≥ 32 bits</td>
</tr>
<tr>
<td align="center">long</td>
<td align="center">-2^63 to 2^63 -1</td>
<td align="center">≥ 64 bits</td>
</tr>
<tr>
<td align="center">float</td>
<td align="center">IEEE single-precision</td>
<td align="center">≥ 32 bits</td>
</tr>
<tr>
<td align="center">double</td>
<td align="center">IEEE double-precision</td>
<td align="center">≥ 64 bits</td>
</tr>
<tr>
<td align="center">string</td>
<td align="center">All Unicode characters</td>
<td align="center">Variable-length</td>
</tr>
</tbody></table>
<p>The range depends on whether byte maps to a signed or an unsigned type.</p>
<p>范围取决于字节映射到有符号类型还是无符号类型。</p>
<p>All the basic types (except byte) are subject to changes in representation as they are transmitted between clients and servers. For example, a long value is byte-swapped when sent from a little-endian to a big-endian machine. However, these changes are transparent to the programmer and do exactly what is required.</p>
<p>所有基本类型（字节除外）在客户端和服务器之间传输时都会发生表示形式的变化。 例如，长值在从小端机器发送到大端机器时会进行字节交换。 然而，这些更改对程序员来说是透明的，并且完全按照要求进行。</p>
<p>Integer Types</p>
<p>Slice provides integer types short, int, and long, with 16-bit, 32-bit, and 64-bit ranges, respectively. Note that, on some architectures, any of these types may be mapped to a native type that is wider. Also note that no unsigned types are provided. (This choice was made because unsigned types are difficult to map into languages without native unsigned types, such as Java. In addition, the unsigned integers add little value to a language.</p>
<p>Slice 提供整数类型short、int 和long，分别具有16 位、32 位和64 位范围。 请注意，在某些体系结构上，这些类型中的任何一个都可以映射到更宽的本机类型。 另请注意，不提供无符号类型。 （做出这个选择是因为无符号类型很难映射到没有本机无符号类型的语言，例如 Java。此外，无符号整数对语言几乎没有增加价值。</p>
<p>Floating-Point Types</p>
<p>These types follow the IEEE specification for single- and double-precision floating-point representation [1]. If an implementation cannot support IEEE format floating-point values, the Ice run time converts values into the native floating-point representation (possibly at a loss of precision or even magnitude, depending on the capabilities of the native floating-point format).</p>
<p>这些类型遵循单精度和双精度浮点表示的 IEEE 规范 [1]。 如果实现无法支持 IEEE 格式浮点值，Ice run time 会将值转换为本机浮点表示形式（可能会损失精度甚至幅度，具体取决于本机浮点格式的功能）。</p>
<p>Strings</p>
<p>Slice strings use the Unicode character set and are encoded using UTF-8 when transmitted between clients and servers.</p>
<p>Slice字符串使用 Unicode 字符集，并在客户端和服务器之间传输时使用 UTF-8 进行编码。</p>
<p>Booleans</p>
<p>Boolean values can have only the values false and true. Language mappings use the corresponding native boolean type if one is available.</p>
<p>布尔值只能有 false 和 true 值。 语言映射使用相应的本机布尔类型（如果可用）。</p>
<p>Bytes</p>
<p>The Slice type byte is an (at least) 8-bit type that is guaranteed not to undergo any changes in representation as it is transmitted between address spaces. This guarantee permits exchange of binary data such that it is not tampered with in transit. All other Slice types are subject to changes in representation during transmission.</p>
<p>Slice 类型字节是（至少）8 位类型，保证在地址空间之间传输时不会发生任何表示形式的变化。 此保证允许交换二进制数据，使其在传输过程中不会被篡改。 所有其他切片类型在传输过程中的表示形式都会发生变化。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://qianqians.github.io/2023/12/04/ice_Modules/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="qianqians">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="qianqians'blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/12/04/ice_Modules/" class="post-title-link" itemprop="url">Modules</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2023-12-04 20:51:43 / 修改时间：20:58:47" itemprop="dateCreated datePublished" datetime="2023-12-04T20:51:43+08:00">2023-12-04</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/ice/" itemprop="url" rel="index"><span itemprop="name">ice</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>Modules Reduce Clutter</p>
<p>A common problem in large systems is pollution of the global namespace: over time, as isolated systems are integrated, name clashes become quite likely. Slice provides the module construct to alleviate this problem:</p>
<p>大型系统中的一个常见问题是全局名称空间的污染：随着时间的推移，随着孤立的系统的集成，名称冲突变得很可能。 Slice 提供了模块构造来缓解这个问题：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> ZeroC </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">module</span> Client </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Definitions here...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">module</span> Server </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Definitions here...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>A module can contain any legal Slice construct, including other module definitions. Using modules to group related definitions together avoids polluting the global namespace and makes accidental name clashes quite unlikely. (You can use a well-known name, such as a company or product name, as the name of the outermost module.)</p>
<p>模块可以包含任何合法的 Slice 构造，包括其他模块定义。 使用模块将相关定义分组在一起可以避免污染全局名称空间，并且不太可能发生意外的名称冲突。 （您可以使用众所周知的名称，例如公司或产品名称，作为最外层模块的名称。）</p>
<p>Modules are Mandatory</p>
<p>Slice requires all definitions to be nested inside a module, that is, you cannot define anything other than a module at global scope. For example, the following is illegal:</p>
<p>Slice 要求所有定义都嵌套在模块内，也就是说，您不能在全局范围内定义除模块之外的任何内容。 例如，以下行为是非法的：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">interface I   <span class="comment">// Error: only modules can appear at global scope</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Definitions at global scope are prohibited because they cause problems with some implementation languages (such as Python, which does not have a true global scope).</p>
<p>禁止在全局范围内进行定义，因为它们会导致某些实现语言（例如 Python，它没有真正的全局范围）出现问题。</p>
<p>Throughout the Ice manual, you will occasionally see Slice definitions that are not nested inside a module. This is to keep the examples short and free of clutter. Whenever you see such a definition, assume that it is nested in module M.</p>
<p>在整个 Ice 手册中，您偶尔会看到未嵌套在模块内的 Slice 定义。 这是为了保持示例简短且整洁。 每当您看到这样的定义时，请假设它嵌套在模块 M 中。</p>
<p>Reopening Modules</p>
<p>Modules can be reopened:</p>
<p>可以重新打开模块：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> ZeroC</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Definitions here...</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// Possibly in a different source file:</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">module</span> ZeroC <span class="comment">// OK, reopened module</span></span><br><span class="line">&#123;  </span><br><span class="line">    <span class="comment">// More definitions here...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Reopened modules are useful for larger projects: they allow you to split the contents of a module over several different source files. The advantage of doing this is that, when a developer makes a change to one part of the module, only files dependent on the changed part need be recompiled (instead of having to recompile all files that use the module).</p>
<p>重新打开的模块对于较大的项目很有用：它们允许您将模块的内容拆分为多个不同的源文件。 这样做的好处是，当开发人员对模块的一部分进行更改时，只需重新编译依赖于更改部分的文件（而不需要重新编译使用该模块的所有文件）。</p>
<p>Module Mapping</p>
<p>Modules map to a corresponding scoping construct in each programming language. (For example, for C++ and C#, Slice modules map to namespaces whereas, for Java, they map to packages.) This allows you to use an appropriate C++ using or Java import declaration to avoid excessively long identifiers in your source code.</p>
<p>模块映射到每种编程语言中相应的作用域构造。 （例如，对于 C++ 和 C#，Slice 模块映射到命名空间，而对于 Java，它们映射到包。）这允许您使用适当的 C++ using 或 Java import 声明来避免源代码中的标识符过长。</p>
<p>The Ice Module</p>
<p>APIs for the Ice run time, apart from a small number of language-specific calls that cannot be expressed in Ice, are defined in the Ice module. In other words, most of the Ice API is actually expressed as Slice definitions. The advantage of doing this is that a single Slice definition is sufficient to define the API for the Ice run time for all supported languages. The respective language mapping rules then determine the exact shape of each Ice API for each implementation language.</p>
<p>We will incrementally explore the contents of the Ice module throughout this manual.</p>
<p>Ice 运行时的 API，除了少数无法在 Ice 中表达的特定于语言的调用之外，均在 Ice 模块中定义。 换句话说，大部分 Ice API 实际上都是表达为 Slice 定义的。 这样做的优点是单个 Slice 定义足以为所有支持的语言定义 Ice 运行时的 API。 然后，相应的语言映射规则确定每种实现语言的每个 Ice API 的确切形态。</p>
<p>我们将在本手册中逐步探索 Ice 模块的内容。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://qianqians.github.io/2023/11/26/ice_Lexical_Rules/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="qianqians">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="qianqians'blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/11/26/ice_Lexical_Rules/" class="post-title-link" itemprop="url">Lexical Rules</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2023-11-26 22:46:10 / 修改时间：23:01:50" itemprop="dateCreated datePublished" datetime="2023-11-26T22:46:10+08:00">2023-11-26</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/ice/" itemprop="url" rel="index"><span itemprop="name">ice</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>Lexical Rules</p>
<p>Slice’s lexical rules are very similar to those of C++ and Java, except for some differences for identifiers.</p>
<p>Slice 的词法规则与 C++ 和 Java 的非常相似，除了标识符的一些差异之外。</p>
<p>Comments</p>
<p>Slice definitions permit both the C and the C++ style of writing comments:</p>
<p>Slice定义允许使用 C 和 C++ 风格编写注释：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * C-style comment.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// C++-style comment extending to the end of this line.</span></span><br></pre></td></tr></table></figure>

<p>Keywords<br>Slice uses a number of keywords, which must be spelled in lowercase. For example, class and dictionary are keywords and must be spelled as shown. There are three exceptions to this lowercase rule: LocalObject, Object and Value are keywords and must be capitalized as shown.</p>
<p>Slice 使用许多关键字，这些关键字必须以小写形式拼写。 例如，class 和dictionary 是关键字，必须按所示拼写。 此小写规则有三个例外：LocalObject、Object 和 Value 是关键字，必须大写，如图所示。</p>
<p>Identifiers</p>
<p>Identifiers begin with an alphabetic character followed by any number of alphabetic characters or digits. Underscores are also permitted in identifiers with the following limitations:</p>
<p>an identifier cannot begin or end with an underscore<br>an identifier cannot contain multiple consecutive underscores<br>Given these rules, the identifier get_account_name is legal but not <em>account, account</em>, or get__account.</p>
<p>Slice identifiers are restricted to the ASCII range of alphabetic characters and cannot contain non-English letters, such as Å. (Supporting non-ASCII identifiers would make it very difficult to map Slice to target languages that lack support for this feature.)</p>
<p>标识符以字母字符开头，后跟任意数量的字母字符或数字。 标识符中也允许使用下划线，但有以下限制：</p>
<p>标识符不能以下划线开头或结尾<br>标识符不能包含多个连续的下划线<br>根据这些规则，标识符 get_account_name 合法，但 <em>account、account</em> 或 get__account 不合法。</p>
<p>Slice标识符仅限于 ASCII 范围内的字母字符，不能包含非英文字母，例如 Å。 （支持非 ASCII 标识符将使将 Slice 映射到不支持此功能的目标语言变得非常困难。）</p>
<p>Case Sensitivity</p>
<p>Identifiers are case-insensitive but must be capitalized consistently. For example, TimeOfDay and TIMEOFDAY are considered the same identifier within a naming scope. However, Slice enforces consistent capitalization. After you have introduced an identifier, you must capitalize it consistently throughout; otherwise, the compiler will reject it as illegal. This rule exists to permit mappings of Slice to languages that ignore case in identifiers as well as to languages that treat differently capitalized identifiers as distinct.</p>
<p>标识符不区分大小写，但大小写必须一致。 例如，TimeOfDay 和 TIMEOFDAY 在命名范围内被视为相同的标识符。 然而，Slice 强制使用一致的大小写。 引入标识符后，必须始终将其大写； 否则，编译器将认为它是非法的而拒绝它。 存在此规则是为了允许将 Slice 映射到忽略标识符大小写的语言以及将不同大写标识符视为不同的语言。</p>
<p>Identifiers That Are Keywords</p>
<p>You can define Slice identifiers that are keywords in one or more implementation languages. For example, switch is a perfectly good Slice identifier but is a C++ and Java keyword. Each language mapping defines rules for dealing with such identifiers. The solution typically involves using a prefix to map away from the keyword. For example, the Slice identifier switch is mapped to _cpp_switch in C++ and _switch in Java.</p>
<p>The rules for dealing with keywords can result in hard-to-read source code. Identifiers such as native, throw, or export will clash with C++ or Java keywords (or both). To make life easier for yourself and others, try to avoid Slice identifiers that are implementation language keywords. Keep in mind that mappings for new languages may be added to Ice in the future. While it is not reasonable to expect you to compile a list of all keywords in all popular programming languages, you should make an attempt to avoid at least common keywords. Slice identifiers such as self, import, and while are definitely not a good idea.</p>
<p>您可以定义作为一种或多种实现语言中的关键字的Slice标识符。 例如，switch 是一个非常好的 Slice 标识符，但却是一个 C++ 和 Java 关键字。 每种语言映射都定义了处理此类标识符的规则。 该解决方案通常涉及使用前缀来映射关键字。 例如，Slice 标识符 switch 在 C++ 中映射为 _cpp_switch，在 Java 中映射为 _switch。</p>
<p>处理关键字的规则可能会导致源代码难以阅读。 诸如native、 throw 或export 之类的标识符将与C++ 或Java 关键字（或两者）发生冲突。 为了让您和他人的生活更轻松，请尽量避免使用作为实现语言关键字的Slice标识符。 请记住，将来可能会将新语言的映射添加到 Ice 中。 虽然期望您编译所有流行编程语言中的所有关键字的列表是不合理的，但您应该尝试至少避免常见关键字。 self、import 和 while 等Slice标识符绝对不是一个好主意。</p>
<p>Escaped Identifiers</p>
<p>It is possible to use a Slice keyword as an identifier by prefixing the keyword with a backslash, for example:</p>
<p>可以通过在关键字前面加上反斜杠来使用 Slice 关键字作为标识符，例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">dictionary</span>     <span class="comment">// Error!</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">struct</span> \dictionary    <span class="comment">// OK</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">struct</span> \foo           <span class="comment">// Legal, same as &quot;struct foo&quot;</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>The backslash escapes the usual meaning of a keyword; in the preceding example, \dictionary is treated as the identifier dictionary. The escape mechanism exists to permit keywords to be added to the Slice language over time with minimal disruption to existing specifications: if a pre-existing specification happens to use a newly-introduced keyword, that specification can be fixed by simply prepending a backslash to the new keyword. Note that, as a matter of style, you should avoid using Slice keywords as identifiers (even though the backslash escapes allow you to do this).</p>
<p>It is legal (though redundant) to precede an identifier that is not a keyword with a backslash — the backslash is ignored in that case.</p>
<p>反斜杠转义了关键字的通常含义； 在前面的示例中，\dictionary 被视为标识符dictionary 。 转义机制的存在是为了允许关键字随着时间的推移添加到 Slice 语言中，同时对现有规范的干扰最小：如果预先存在的规范碰巧使用了新引入的关键字，则只需在该规范前面添加一个反斜杠即可修复该规范。 新的关键字。 请注意，就风格而言，您应该避免使用 Slice 关键字作为标识符（即使反斜杠转义允许您这样做）。</p>
<p>在不是关键字的标识符前面加上反斜杠是合法的（尽管是多余的）——在这种情况下，反斜杠将被忽略。</p>
<p>Reserved Identifiers</p>
<p>Slice reserves the identifier Ice and all identifiers beginning with Ice (in any capitalization) for the Ice implementation. For example, if you try to define a type named Icecream, the Slice compiler will issue an error message.</p>
<p>Slice 为 Ice 实现保留了标识符 Ice 和所有以 Ice 开头的标识符（任何大小写）。 例如，如果您尝试定义名为 Icecream 的类型，Slice 编译器将发出错误消息。</p>
<p>You can suppress this behavior by using the ice-prefix Slice metadata directive, which enables definition of identifiers beginning with Ice. However, do not use this directive unless you are compiling the Slice definitions for the Ice run time itself.</p>
<p>您可以使用ice-prefix Slice元数据指令来抑制此行为，该指令允许定义以Ice开头的标识符。 但是，除非您正在为 Ice 运行时本身编译 Slice 定义，否则不要使用此指令。</p>
<p>Slice identifiers ending in any of the suffixes Async, Disp, Helper, Holder, Prx, and Ptr are also reserved. These endings are used by the various language mappings and are reserved to prevent name clashes in the generated code.</p>
<p>以任何后缀 Async、Disp、Helper、Holder、Prx 和 Ptr 结尾的Slice标识符也被保留。 这些结尾由各种语言映射使用，并被保留以防止生成的代码中发生名称冲突。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/5/">5</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">qianqians</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>

<script src="/js/bookmark.js"></script>




  















  

  

</body>
</html>
